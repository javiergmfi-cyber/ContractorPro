# ContractorPro Codebase Export
# Generated: Mon Jan 12 21:02:14 EST 2026


=================================================================================
FILE: ./.claude/settings.local.json
=================================================================================

{
  "permissions": {
    "allow": [
      "Bash(npx create-expo-app@latest . --template blank-typescript --yes)",
      "Bash(echo:*)",
      "Skill(ralph-loop:ralph-loop)",
      "Bash(node --version:*)",
      "Bash(npm --version:*)",
      "Bash(curl:*)",
      "Bash(bash -s -- --skip-shell)",
      "Bash(~/.fnm/fnm install --lts)",
      "Bash(export PATH=\"$HOME/.fnm:$PATH\")",
      "Bash(npx expo install expo-router expo-linking expo-constants expo-status-bar)",
      "Bash(npm install:*)",
      "Bash(npx tailwindcss init)",
      "Bash(npm ls:*)",
      "Bash(npm uninstall:*)",
      "Bash(npx expo install:*)",
      "Bash(npx tsc:*)",
      "Bash(timeout 30 npx expo start:*)",
      "Bash(npx expo export:*)",
      "Bash(npx expo start)",
      "Bash(pkill:*)",
      "Bash(npx expo start:*)",
      "Bash(open:*)",
      "Bash(xcrun simctl boot:*)",
      "Bash(xcrun simctl list:*)",
      "Bash(gh auth status:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(dd:*)",
      "Bash(unzip:*)",
      "Bash(chmod:*)",
      "Bash(~/.local/bin/gh --version)",
      "Bash(~/.local/bin/gh auth status)",
      "Bash(~/.local/bin/gh repo create:*)",
      "Bash(xcode-select:*)",
      "Bash(xcodebuild:*)",
      "Bash(pod:*)",
      "Bash(sudo gem install:*)",
      "Bash(gem install:*)",
      "Bash(export PATH=\"$HOME/.gem/ruby/2.6.0/bin:$PATH\")",
      "Bash(git push:*)",
      "Bash(git revert:*)",
      "WebSearch",
      "WebFetch(domain:github.com)",
      "Bash(claude mcp add gemini -s user -- env GEMINI_API_KEY=AIzaSyBav1Q48t_6d5UMEWPh3OirWtmoxab5z9I npx -y @rlabs-inc/gemini-mcp)",
      "Bash(git -C /Users/javier/ContractorPro log --oneline -15)",
      "Bash(brew install:*)",
      "Bash(sh:*)",
      "Bash(/usr/local/bin/npx --version)",
      "Bash(/opt/homebrew/bin/npx --version)",
      "Bash(/Users/javier/.local/bin/supabase init:*)",
      "Bash(/Users/javier/.local/bin/supabase projects list:*)",
      "Bash(export SUPABASE_ACCESS_TOKEN=sbp_ad8ddffbe609cb5d059bcf4585896afaf0e33884)",
      "Bash(/Users/javier/.local/bin/supabase link --project-ref wijyqeogfpkjpszrowzg)",
      "Bash(/Users/javier/.local/bin/supabase db push:*)",
      "Bash(/Users/javier/.local/bin/supabase db execute:*)",
      "Bash(/Users/javier/.local/bin/supabase --help)",
      "Bash(/Users/javier/.local/bin/supabase storage:*)",
      "Bash(/Users/javier/.local/bin/supabase db dump:*)",
      "Bash(export PATH=\"/Users/javier/.fnm/node-versions/v24.12.0/installation/bin:$PATH\":*)",
      "Bash(xcrun simctl openurl:*)",
      "Bash(ls:*)"
    ]
  }
}


=================================================================================
FILE: ./app.json
=================================================================================

{
  "expo": {
    "name": "ContractorPro",
    "slug": "ContractorPro",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-router",
      "expo-font"
    ]
  }
}


=================================================================================
FILE: ./app/_layout.tsx
=================================================================================

import { useEffect } from "react";
import { Stack, useRouter, useSegments } from "expo-router";
import { StatusBar } from "expo-status-bar";
import { SafeAreaProvider } from "react-native-safe-area-context";
import { View, ActivityIndicator } from "react-native";
import { ThemeProvider, useTheme } from "../lib/theme";
import { AuthProvider, useAuth } from "../contexts/AuthContext";
import "../global.css";

function AuthGuard({ children }: { children: React.ReactNode }) {
  const { session, isLoading } = useAuth();
  const segments = useSegments();
  const router = useRouter();

  useEffect(() => {
    if (isLoading) return;

    const inAuthGroup = segments[0] === "(auth)";

    if (!session && !inAuthGroup) {
      // Redirect to login if not authenticated
      router.replace("/(auth)/login");
    } else if (session && inAuthGroup) {
      // Redirect to home if authenticated and trying to access auth screens
      router.replace("/(tabs)");
    }
  }, [session, isLoading, segments]);

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return <>{children}</>;
}

function RootLayoutContent() {
  const { isDark, colors } = useTheme();

  return (
    <>
      <StatusBar style={isDark ? "light" : "dark"} />
      <AuthGuard>
        <Stack
          screenOptions={{
            headerShown: false,
            contentStyle: { backgroundColor: colors.background },
          }}
        >
          <Stack.Screen name="(auth)" />
          <Stack.Screen name="(tabs)" />
          <Stack.Screen
            name="invoice/preview"
            options={{
              presentation: "modal",
              animation: "slide_from_bottom",
            }}
          />
          <Stack.Screen name="invoice/[id]" />
          <Stack.Screen
            name="stripe/onboarding"
            options={{
              presentation: "modal",
              animation: "slide_from_bottom",
            }}
          />
        </Stack>
      </AuthGuard>
    </>
  );
}

export default function RootLayout() {
  return (
    <SafeAreaProvider>
      <ThemeProvider>
        <AuthProvider>
          <RootLayoutContent />
        </AuthProvider>
      </ThemeProvider>
    </SafeAreaProvider>
  );
}


=================================================================================
FILE: ./app/(auth)/_layout.tsx
=================================================================================

import { Stack } from "expo-router";
import { useTheme } from "@/lib/theme";

export default function AuthLayout() {
  const { colors } = useTheme();

  return (
    <Stack
      screenOptions={{
        headerShown: false,
        contentStyle: { backgroundColor: colors.background },
        animation: "fade",
      }}
    >
      <Stack.Screen name="login" />
      <Stack.Screen name="signup" />
      <Stack.Screen name="forgot-password" />
    </Stack>
  );
}


=================================================================================
FILE: ./app/(auth)/forgot-password.tsx
=================================================================================

import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Pressable,
} from "react-native";
import { router } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { ChevronLeft } from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/lib/theme";
import { useAuth } from "@/contexts/AuthContext";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

export default function ForgotPasswordScreen() {
  const { colors, typography, spacing, radius } = useTheme();
  const { resetPassword } = useAuth();

  const [email, setEmail] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleResetPassword = async () => {
    if (!email) {
      setError("Please enter your email address");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    setIsLoading(true);
    setError(null);

    const { error: resetError } = await resetPassword(email);

    if (resetError) {
      setError(resetError.message);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } else {
      setSuccess(true);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }

    setIsLoading(false);
  };

  if (success) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
        <View style={styles.successContainer}>
          <Text style={[typography.title1, { color: colors.text, textAlign: "center" }]}>
            Check Your Email
          </Text>
          <Text
            style={[
              typography.body,
              { color: colors.textSecondary, textAlign: "center", marginTop: spacing.md },
            ]}
          >
            We've sent a password reset link to {email}
          </Text>
          <View style={{ marginTop: spacing.xl }}>
            <Button
              title="Back to Login"
              onPress={() => router.replace("/(auth)/login")}
            />
          </View>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardView}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
        >
          {/* Back Button */}
          <Pressable
            style={styles.backButton}
            onPress={() => router.back()}
          >
            <ChevronLeft size={24} color={colors.text} />
            <Text style={[typography.body, { color: colors.text }]}>Back</Text>
          </Pressable>

          {/* Header */}
          <View style={styles.header}>
            <Text style={[typography.largeTitle, { color: colors.text }]}>
              Reset Password
            </Text>
            <Text
              style={[
                typography.body,
                { color: colors.textSecondary, marginTop: spacing.sm },
              ]}
            >
              Enter your email and we'll send you a reset link
            </Text>
          </View>

          {/* Form */}
          <View style={styles.form}>
            {error && (
              <View
                style={[
                  styles.errorContainer,
                  { backgroundColor: colors.error + "15", borderRadius: radius.md },
                ]}
              >
                <Text style={[typography.footnote, { color: colors.error }]}>
                  {error}
                </Text>
              </View>
            )}

            <Input
              label="Email"
              value={email}
              onChangeText={setEmail}
              placeholder="you@example.com"
              keyboardType="email-address"
              autoCapitalize="none"
              autoComplete="email"
              editable={!isLoading}
            />

            <Button
              title={isLoading ? "Sending..." : "Send Reset Link"}
              onPress={handleResetPassword}
              disabled={isLoading}
            />
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 24,
  },
  backButton: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 24,
    marginLeft: -8,
  },
  header: {
    marginBottom: 32,
  },
  form: {
    gap: 16,
  },
  errorContainer: {
    padding: 12,
    marginBottom: 8,
  },
  successContainer: {
    flex: 1,
    justifyContent: "center",
    padding: 24,
  },
});


=================================================================================
FILE: ./app/(auth)/login.tsx
=================================================================================

import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Pressable,
  ActivityIndicator,
} from "react-native";
import { Link, router } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/lib/theme";
import { useAuth } from "@/contexts/AuthContext";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

export default function LoginScreen() {
  const { colors, typography, spacing, radius } = useTheme();
  const { signIn } = useAuth();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    if (!email || !password) {
      setError("Please fill in all fields");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    setIsLoading(true);
    setError(null);

    const { error: signInError } = await signIn(email, password);

    if (signInError) {
      setError(signInError.message);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } else {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      router.replace("/(tabs)");
    }

    setIsLoading(false);
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardView}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
        >
          {/* Header */}
          <View style={styles.header}>
            <Text style={[typography.largeTitle, { color: colors.text }]}>
              Welcome Back
            </Text>
            <Text
              style={[
                typography.body,
                { color: colors.textSecondary, marginTop: spacing.sm },
              ]}
            >
              Sign in to manage your invoices
            </Text>
          </View>

          {/* Form */}
          <View style={styles.form}>
            {error && (
              <View
                style={[
                  styles.errorContainer,
                  { backgroundColor: colors.error + "15", borderRadius: radius.md },
                ]}
              >
                <Text style={[typography.footnote, { color: colors.error }]}>
                  {error}
                </Text>
              </View>
            )}

            <Input
              label="Email"
              value={email}
              onChangeText={setEmail}
              placeholder="you@example.com"
              keyboardType="email-address"
              autoCapitalize="none"
              autoComplete="email"
              editable={!isLoading}
            />

            <Input
              label="Password"
              value={password}
              onChangeText={setPassword}
              placeholder="Your password"
              secureTextEntry
              autoCapitalize="none"
              autoComplete="password"
              editable={!isLoading}
            />

            <Link href="/(auth)/forgot-password" asChild>
              <Pressable style={styles.forgotPassword}>
                <Text
                  style={[typography.footnote, { color: colors.primary }]}
                >
                  Forgot password?
                </Text>
              </Pressable>
            </Link>

            <Button
              title={isLoading ? "Signing in..." : "Sign In"}
              onPress={handleLogin}
              disabled={isLoading}
            />
          </View>

          {/* Footer */}
          <View style={styles.footer}>
            <Text style={[typography.footnote, { color: colors.textSecondary }]}>
              Don't have an account?{" "}
            </Text>
            <Link href="/(auth)/signup" asChild>
              <Pressable>
                <Text style={[typography.footnote, { color: colors.primary, fontWeight: "600" }]}>
                  Sign Up
                </Text>
              </Pressable>
            </Link>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 24,
    justifyContent: "center",
  },
  header: {
    marginBottom: 32,
  },
  form: {
    gap: 16,
  },
  errorContainer: {
    padding: 12,
    marginBottom: 8,
  },
  forgotPassword: {
    alignSelf: "flex-end",
    marginTop: -8,
    marginBottom: 8,
  },
  footer: {
    flexDirection: "row",
    justifyContent: "center",
    marginTop: 32,
  },
});


=================================================================================
FILE: ./app/(auth)/signup.tsx
=================================================================================

import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Pressable,
} from "react-native";
import { Link, router } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/lib/theme";
import { useAuth } from "@/contexts/AuthContext";
import { Input } from "@/components/ui/Input";
import { Button } from "@/components/ui/Button";

export default function SignUpScreen() {
  const { colors, typography, spacing, radius } = useTheme();
  const { signUp } = useAuth();

  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleSignUp = async () => {
    // Validation
    if (!fullName || !email || !password || !confirmPassword) {
      setError("Please fill in all fields");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    if (password.length < 6) {
      setError("Password must be at least 6 characters");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    setIsLoading(true);
    setError(null);

    const { error: signUpError } = await signUp(email, password, fullName);

    if (signUpError) {
      setError(signUpError.message);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } else {
      setSuccess(true);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }

    setIsLoading(false);
  };

  if (success) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
        <View style={styles.successContainer}>
          <Text style={[typography.title1, { color: colors.text, textAlign: "center" }]}>
            Check Your Email
          </Text>
          <Text
            style={[
              typography.body,
              { color: colors.textSecondary, textAlign: "center", marginTop: spacing.md },
            ]}
          >
            We've sent a confirmation link to {email}. Please verify your email to continue.
          </Text>
          <View style={{ marginTop: spacing.xl }}>
            <Button
              title="Back to Login"
              onPress={() => router.replace("/(auth)/login")}
            />
          </View>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardView}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
        >
          {/* Header */}
          <View style={styles.header}>
            <Text style={[typography.largeTitle, { color: colors.text }]}>
              Create Account
            </Text>
            <Text
              style={[
                typography.body,
                { color: colors.textSecondary, marginTop: spacing.sm },
              ]}
            >
              Start getting paid faster
            </Text>
          </View>

          {/* Form */}
          <View style={styles.form}>
            {error && (
              <View
                style={[
                  styles.errorContainer,
                  { backgroundColor: colors.error + "15", borderRadius: radius.md },
                ]}
              >
                <Text style={[typography.footnote, { color: colors.error }]}>
                  {error}
                </Text>
              </View>
            )}

            <Input
              label="Full Name"
              value={fullName}
              onChangeText={setFullName}
              placeholder="John Smith"
              autoCapitalize="words"
              autoComplete="name"
              editable={!isLoading}
            />

            <Input
              label="Email"
              value={email}
              onChangeText={setEmail}
              placeholder="you@example.com"
              keyboardType="email-address"
              autoCapitalize="none"
              autoComplete="email"
              editable={!isLoading}
            />

            <Input
              label="Password"
              value={password}
              onChangeText={setPassword}
              placeholder="At least 6 characters"
              secureTextEntry
              autoCapitalize="none"
              autoComplete="new-password"
              editable={!isLoading}
            />

            <Input
              label="Confirm Password"
              value={confirmPassword}
              onChangeText={setConfirmPassword}
              placeholder="Confirm your password"
              secureTextEntry
              autoCapitalize="none"
              autoComplete="new-password"
              editable={!isLoading}
            />

            <Button
              title={isLoading ? "Creating account..." : "Create Account"}
              onPress={handleSignUp}
              disabled={isLoading}
            />
          </View>

          {/* Footer */}
          <View style={styles.footer}>
            <Text style={[typography.footnote, { color: colors.textSecondary }]}>
              Already have an account?{" "}
            </Text>
            <Link href="/(auth)/login" asChild>
              <Pressable>
                <Text style={[typography.footnote, { color: colors.primary, fontWeight: "600" }]}>
                  Sign In
                </Text>
              </Pressable>
            </Link>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  keyboardView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 24,
    justifyContent: "center",
  },
  header: {
    marginBottom: 32,
  },
  form: {
    gap: 16,
  },
  errorContainer: {
    padding: 12,
    marginBottom: 8,
  },
  successContainer: {
    flex: 1,
    justifyContent: "center",
    padding: 24,
  },
  footer: {
    flexDirection: "row",
    justifyContent: "center",
    marginTop: 32,
  },
});


=================================================================================
FILE: ./app/(tabs)/_layout.tsx
=================================================================================

import { Tabs } from "expo-router";
import { Home, FileText, Users, User } from "lucide-react-native";
import { useTheme } from "../../lib/theme";
import { View, StyleSheet } from "react-native";

export default function TabLayout() {
  const { colors, isDark } = useTheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: colors.primary,
        tabBarInactiveTintColor: colors.textTertiary,
        tabBarStyle: {
          backgroundColor: isDark ? colors.backgroundSecondary : "#FFFFFF",
          borderTopWidth: 0,
          elevation: 0,
          shadowColor: colors.shadow,
          shadowOffset: { width: 0, height: -4 },
          shadowOpacity: isDark ? 0.3 : 0.06,
          shadowRadius: 12,
          height: 88,
          paddingBottom: 32,
          paddingTop: 12,
        },
        tabBarLabelStyle: {
          fontSize: 11,
          fontWeight: "500",
          marginTop: 4,
        },
        tabBarIconStyle: {
          marginTop: 4,
        },
        headerShown: false,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Dashboard",
          tabBarIcon: ({ color, focused }) => (
            <View style={focused ? styles.activeIconContainer : undefined}>
              <Home size={24} color={color} strokeWidth={focused ? 2.5 : 2} />
            </View>
          ),
        }}
      />
      <Tabs.Screen
        name="invoices"
        options={{
          title: "Invoices",
          tabBarIcon: ({ color, focused }) => (
            <View style={focused ? styles.activeIconContainer : undefined}>
              <FileText size={24} color={color} strokeWidth={focused ? 2.5 : 2} />
            </View>
          ),
        }}
      />
      <Tabs.Screen
        name="clients"
        options={{
          title: "Clients",
          tabBarIcon: ({ color, focused }) => (
            <View style={focused ? styles.activeIconContainer : undefined}>
              <Users size={24} color={color} strokeWidth={focused ? 2.5 : 2} />
            </View>
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: "Profile",
          tabBarIcon: ({ color, focused }) => (
            <View style={focused ? styles.activeIconContainer : undefined}>
              <User size={24} color={color} strokeWidth={focused ? 2.5 : 2} />
            </View>
          ),
        }}
      />
    </Tabs>
  );
}

const styles = StyleSheet.create({
  activeIconContainer: {
    // Subtle highlight for active tab
  },
});


=================================================================================
FILE: ./app/(tabs)/clients.tsx
=================================================================================

import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  Pressable,
  RefreshControl,
  TextInput,
  Modal,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useRouter } from "expo-router";
import {
  Search,
  Plus,
  Phone,
  Mail,
  ChevronRight,
  X,
} from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { useClientStore } from "@/store/useClientStore";
import { useTheme } from "@/lib/theme";
import { Client } from "@/types/database";
import { EmptyState } from "@/components/EmptyState";
import { SkeletonCard } from "@/components/SkeletonCard";
import { Button } from "@/components/ui/Button";

/**
 * Clients Tab
 * Per design-system.md - Client list with MonogramAvatar
 */

export default function ClientsScreen() {
  const router = useRouter();
  const { colors, typography, spacing, radius, shadows, isDark } = useTheme();
  const {
    clients,
    isLoading,
    isSaving,
    fetchClients,
    createClient,
  } = useClientStore();

  const [searchQuery, setSearchQuery] = useState("");
  const [refreshing, setRefreshing] = useState(false);
  const [showAddModal, setShowAddModal] = useState(false);
  const [newClientName, setNewClientName] = useState("");
  const [newClientEmail, setNewClientEmail] = useState("");
  const [newClientPhone, setNewClientPhone] = useState("");

  useEffect(() => {
    fetchClients();
  }, []);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    await fetchClients();
    setRefreshing(false);
  }, [fetchClients]);

  const filteredClients = clients.filter((client) =>
    client.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    client.email?.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleClientPress = (client: Client) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    // Navigate to client detail/edit screen (to be implemented)
    // router.push(`/client/${client.id}`);
  };

  const handleAddClient = async () => {
    if (!newClientName.trim()) return;

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    try {
      await createClient({
        name: newClientName.trim(),
        email: newClientEmail.trim() || null,
        phone: newClientPhone.trim() || null,
      });
      setShowAddModal(false);
      setNewClientName("");
      setNewClientEmail("");
      setNewClientPhone("");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    }
  };

  const getInitials = (name: string) => {
    const parts = name.trim().split(" ");
    if (parts.length >= 2) {
      return `${parts[0][0]}${parts[1][0]}`.toUpperCase();
    }
    return name.slice(0, 2).toUpperCase();
  };

  const getAvatarColor = (name: string) => {
    const colorPalette = [
      "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4",
      "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F",
      "#BB8FCE", "#85C1E9", "#F8B500", "#00CED1",
    ];
    const index = name.charCodeAt(0) % colorPalette.length;
    return colorPalette[index];
  };

  const renderClientItem = ({ item }: { item: Client }) => (
    <Pressable
      onPress={() => handleClientPress(item)}
      style={({ pressed }) => [
        styles.clientCard,
        {
          backgroundColor: colors.card,
          borderRadius: radius.md,
          ...shadows.default,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
    >
      {/* MonogramAvatar */}
      <View
        style={[
          styles.avatar,
          { backgroundColor: getAvatarColor(item.name) },
        ]}
      >
        <Text style={styles.avatarText}>{getInitials(item.name)}</Text>
      </View>

      {/* Client Info */}
      <View style={styles.clientInfo}>
        <Text
          style={[typography.headline, { color: colors.text }]}
          numberOfLines={1}
        >
          {item.name}
        </Text>
        {(item.email || item.phone) && (
          <View style={styles.contactRow}>
            {item.email && (
              <View style={styles.contactItem}>
                <Mail size={12} color={colors.textTertiary} />
                <Text
                  style={[typography.caption1, { color: colors.textTertiary, marginLeft: 4 }]}
                  numberOfLines={1}
                >
                  {item.email}
                </Text>
              </View>
            )}
            {item.phone && (
              <View style={styles.contactItem}>
                <Phone size={12} color={colors.textTertiary} />
                <Text
                  style={[typography.caption1, { color: colors.textTertiary, marginLeft: 4 }]}
                >
                  {item.phone}
                </Text>
              </View>
            )}
          </View>
        )}
      </View>

      <ChevronRight size={20} color={colors.textTertiary} />
    </Pressable>
  );

  const ListHeader = () => (
    <View style={styles.searchContainer}>
      <View
        style={[
          styles.searchBox,
          {
            backgroundColor: colors.backgroundSecondary,
            borderRadius: radius.md,
          },
        ]}
      >
        <Search size={18} color={colors.textTertiary} />
        <TextInput
          style={[
            styles.searchInput,
            typography.body,
            { color: colors.text },
          ]}
          placeholder="Search clients..."
          placeholderTextColor={colors.textTertiary}
          value={searchQuery}
          onChangeText={setSearchQuery}
        />
        {searchQuery.length > 0 && (
          <Pressable onPress={() => setSearchQuery("")}>
            <X size={18} color={colors.textTertiary} />
          </Pressable>
        )}
      </View>
    </View>
  );

  if (isLoading && clients.length === 0) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={["top"]}>
        <View style={styles.header}>
          <Text style={[typography.largeTitle, { color: colors.text }]}>Clients</Text>
        </View>
        <SkeletonCard count={5} />
      </SafeAreaView>
    );
  }

  if (clients.length === 0) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={["top"]}>
        <View style={styles.header}>
          <Text style={[typography.largeTitle, { color: colors.text }]}>Clients</Text>
          <Pressable
            style={[styles.addButton, { backgroundColor: colors.primary }]}
            onPress={() => {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
              setShowAddModal(true);
            }}
          >
            <Plus size={20} color="#FFFFFF" strokeWidth={2.5} />
          </Pressable>
        </View>
        <EmptyState
          type="noClients"
          onAction={() => setShowAddModal(true)}
          actionLabel="Add First Client"
        />
        {renderAddModal()}
      </SafeAreaView>
    );
  }

  function renderAddModal() {
    return (
      <Modal
        visible={showAddModal}
        animationType="slide"
        presentationStyle="pageSheet"
        onRequestClose={() => setShowAddModal(false)}
      >
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={[styles.modalContainer, { backgroundColor: colors.background }]}
        >
          <SafeAreaView style={styles.modalContent}>
            {/* Modal Header */}
            <View style={styles.modalHeader}>
              <Pressable onPress={() => setShowAddModal(false)}>
                <Text style={[typography.body, { color: colors.primary }]}>Cancel</Text>
              </Pressable>
              <Text style={[typography.headline, { color: colors.text }]}>Add Client</Text>
              <View style={{ width: 50 }} />
            </View>

            {/* Form */}
            <View style={styles.form}>
              <View style={styles.inputGroup}>
                <Text style={[typography.footnote, { color: colors.textSecondary, marginBottom: spacing.xs }]}>
                  Name *
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    typography.body,
                    {
                      backgroundColor: colors.backgroundSecondary,
                      color: colors.text,
                      borderRadius: radius.md,
                    },
                  ]}
                  placeholder="Client name"
                  placeholderTextColor={colors.textTertiary}
                  value={newClientName}
                  onChangeText={setNewClientName}
                  autoFocus
                />
              </View>

              <View style={styles.inputGroup}>
                <Text style={[typography.footnote, { color: colors.textSecondary, marginBottom: spacing.xs }]}>
                  Email
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    typography.body,
                    {
                      backgroundColor: colors.backgroundSecondary,
                      color: colors.text,
                      borderRadius: radius.md,
                    },
                  ]}
                  placeholder="client@email.com"
                  placeholderTextColor={colors.textTertiary}
                  value={newClientEmail}
                  onChangeText={setNewClientEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                />
              </View>

              <View style={styles.inputGroup}>
                <Text style={[typography.footnote, { color: colors.textSecondary, marginBottom: spacing.xs }]}>
                  Phone
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    typography.body,
                    {
                      backgroundColor: colors.backgroundSecondary,
                      color: colors.text,
                      borderRadius: radius.md,
                    },
                  ]}
                  placeholder="(555) 123-4567"
                  placeholderTextColor={colors.textTertiary}
                  value={newClientPhone}
                  onChangeText={setNewClientPhone}
                  keyboardType="phone-pad"
                />
              </View>
            </View>

            {/* Save Button */}
            <View style={styles.modalButtonContainer}>
              <Button
                title={isSaving ? "Saving..." : "Add Client"}
                onPress={handleAddClient}
                disabled={!newClientName.trim() || isSaving}
              />
            </View>
          </SafeAreaView>
        </KeyboardAvoidingView>
      </Modal>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={["top"]}>
      {/* Header */}
      <View style={styles.header}>
        <View>
          <Text style={[typography.largeTitle, { color: colors.text }]}>Clients</Text>
          <Text style={[typography.subhead, { color: colors.textTertiary, marginTop: 2 }]}>
            {clients.length} total
          </Text>
        </View>
        <Pressable
          style={[styles.addButton, { backgroundColor: colors.primary }]}
          onPress={() => {
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
            setShowAddModal(true);
          }}
        >
          <Plus size={20} color="#FFFFFF" strokeWidth={2.5} />
        </Pressable>
      </View>

      <FlatList
        data={filteredClients}
        keyExtractor={(item) => item.id}
        renderItem={renderClientItem}
        ListHeaderComponent={ListHeader}
        contentContainerStyle={styles.listContent}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor={colors.primary}
          />
        }
        ListEmptyComponent={
          searchQuery ? (
            <EmptyState
              type="noResults"
              searchQuery={searchQuery}
              onAction={() => setSearchQuery("")}
              actionLabel="Clear Search"
            />
          ) : null
        }
      />

      {renderAddModal()}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 8,
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: "center",
    justifyContent: "center",
  },
  searchContainer: {
    paddingHorizontal: 24,
    paddingBottom: 16,
  },
  searchBox: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
  },
  searchInput: {
    flex: 1,
    padding: 0,
  },
  listContent: {
    paddingBottom: 120,
  },
  clientCard: {
    flexDirection: "row",
    alignItems: "center",
    padding: 16,
    marginHorizontal: 16,
    marginBottom: 8,
  },
  avatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  avatarText: {
    color: "#FFFFFF",
    fontSize: 16,
    fontWeight: "700",
  },
  clientInfo: {
    flex: 1,
    marginRight: 8,
  },
  contactRow: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
    marginTop: 4,
  },
  contactItem: {
    flexDirection: "row",
    alignItems: "center",
  },
  // Modal Styles
  modalContainer: {
    flex: 1,
  },
  modalContent: {
    flex: 1,
  },
  modalHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 16,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderBottomColor: "rgba(0,0,0,0.1)",
  },
  form: {
    padding: 24,
    gap: 20,
  },
  inputGroup: {},
  input: {
    paddingHorizontal: 16,
    paddingVertical: 14,
  },
  modalButtonContainer: {
    padding: 24,
    marginTop: "auto",
  },
});


=================================================================================
FILE: ./app/(tabs)/index.tsx
=================================================================================

import React, { useState, useEffect, useRef, useCallback } from "react";
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  Animated,
  Pressable,
  RefreshControl,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useRouter } from "expo-router";
import { Moon, Sun, TrendingUp, Clock, AlertCircle, CheckCircle } from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { VoiceButton } from "@/components/VoiceButton";
import { RecordingOverlay } from "@/components/RecordingOverlay";
import { AnimatedCurrency, PulseNumber } from "@/components/AnimatedNumber";
import { useDashboardStore } from "@/store/useDashboardStore";
import { useProfileStore } from "@/store/useProfileStore";
import { useTheme } from "@/lib/theme";
import { startRecording, stopRecording } from "@/services/audio";
import { processVoiceToInvoice } from "@/services/ai";
import { useInvoiceStore } from "@/store/useInvoiceStore";

/**
 * Dashboard Screen
 * Per design-system.md "Pulse UI" with animated numbers
 */

export default function Dashboard() {
  const router = useRouter();
  const { isDark, toggleTheme, colors, typography, spacing, radius } = useTheme();

  const { stats, isLoading, fetchDashboardStats } = useDashboardStore();
  const { profile, fetchProfile } = useProfileStore();
  const { setPendingInvoice } = useInvoiceStore();

  const [isRecording, setIsRecording] = useState(false);
  const [recordingDuration, setRecordingDuration] = useState(0);
  const [refreshing, setRefreshing] = useState(false);

  // Animations
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(30)).current;

  useEffect(() => {
    // Initial data fetch
    fetchDashboardStats();
    fetchProfile();

    // Entry animation
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 600,
        useNativeDriver: true,
      }),
      Animated.spring(slideAnim, {
        toValue: 0,
        friction: 8,
        tension: 40,
        useNativeDriver: true,
      }),
    ]).start();
  }, []);

  // Recording timer
  useEffect(() => {
    let interval: ReturnType<typeof setInterval>;
    if (isRecording) {
      interval = setInterval(() => {
        setRecordingDuration((prev) => prev + 1);
      }, 1000);
    } else {
      setRecordingDuration(0);
    }
    return () => clearInterval(interval);
  }, [isRecording]);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    await Promise.all([fetchDashboardStats(), fetchProfile()]);
    setRefreshing(false);
  }, [fetchDashboardStats, fetchProfile]);

  const handlePressIn = async () => {
    setIsRecording(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
    await startRecording();
  };

  const handlePressOut = async () => {
    setIsRecording(false);
    const audioUri = await stopRecording();

    if (audioUri) {
      try {
        const result = await processVoiceToInvoice(audioUri);
        setPendingInvoice(result.parsedInvoice);
        router.push("/invoice/preview");
      } catch (error) {
        console.error("Error processing voice:", error);
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      }
    }
  };

  const handleThemeToggle = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    toggleTheme();
  };

  // Format currency for display (amounts in cents)
  const formatCurrency = (cents: number) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: profile?.default_currency || "USD",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(cents / 100);
  };

  const styles = createStyles(colors, isDark, spacing, radius, typography);

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            tintColor={colors.primary}
          />
        }
      >
        {/* Header */}
        <Animated.View
          style={[
            styles.header,
            {
              opacity: fadeAnim,
              transform: [{ translateY: slideAnim }],
            },
          ]}
        >
          <View>
            <Text style={styles.greeting}>{getGreeting()}</Text>
            <Text style={styles.businessName}>
              {profile?.business_name || "ContractorPro"}
            </Text>
          </View>
          <Pressable onPress={handleThemeToggle} style={styles.themeButton}>
            {isDark ? (
              <Sun size={22} color={colors.text} />
            ) : (
              <Moon size={22} color={colors.text} />
            )}
          </Pressable>
        </Animated.View>

        {/* Main Revenue Card - Per design-system.md "Pulse UI" */}
        <Animated.View
          style={[
            styles.mainCard,
            {
              opacity: fadeAnim,
              transform: [{ translateY: slideAnim }],
            },
          ]}
        >
          <View style={styles.mainCardHeader}>
            <View style={styles.iconContainer}>
              <TrendingUp size={20} color={colors.primary} />
            </View>
            <Text style={styles.mainCardLabel}>Total Revenue</Text>
          </View>

          {/* Animated Amount - The "Pulse" */}
          <AnimatedCurrency
            cents={stats?.totalRevenue || 0}
            currency={profile?.default_currency || "USD"}
            style={styles.mainCardAmount}
            duration={1000}
          />

          <Text style={styles.mainCardSubtext}>
            <PulseNumber
              value={stats?.paidInvoicesCount || 0}
              style={styles.mainCardSubtext}
            />{" "}
            paid invoices
          </Text>
        </Animated.View>

        {/* Stats Row */}
        <Animated.View
          style={[
            styles.statsRow,
            {
              opacity: fadeAnim,
              transform: [{ translateY: slideAnim }],
            },
          ]}
        >
          {/* Pending Card */}
          <View style={[styles.statCard, styles.statCardPending]}>
            <View style={styles.statIconContainer}>
              <Clock size={18} color={colors.alert} />
            </View>
            <Text style={styles.statLabel}>Pending</Text>
            <AnimatedCurrency
              cents={stats?.pendingAmount || 0}
              currency={profile?.default_currency || "USD"}
              style={[styles.statAmount, { color: colors.alert }]}
              duration={800}
            />
            <Text style={styles.statSubtext}>
              {stats?.pendingInvoicesCount || 0} invoices
            </Text>
          </View>

          {/* Overdue Card */}
          <View style={[styles.statCard, stats?.overdueAmount > 0 && styles.statCardOverdue]}>
            <View style={styles.statIconContainer}>
              {(stats?.overdueAmount || 0) > 0 ? (
                <AlertCircle size={18} color={colors.statusOverdue} />
              ) : (
                <CheckCircle size={18} color={colors.statusPaid} />
              )}
            </View>
            <Text style={styles.statLabel}>
              {(stats?.overdueAmount || 0) > 0 ? "Overdue" : "All Clear"}
            </Text>
            {(stats?.overdueAmount || 0) > 0 ? (
              <>
                <AnimatedCurrency
                  cents={stats?.overdueAmount || 0}
                  currency={profile?.default_currency || "USD"}
                  style={[styles.statAmount, { color: colors.statusOverdue }]}
                  duration={800}
                />
                <Text style={styles.statSubtext}>
                  {stats?.overdueInvoicesCount || 0} invoices
                </Text>
              </>
            ) : (
              <Text style={[styles.statAmount, { color: colors.statusPaid }]}>
                No overdue
              </Text>
            )}
          </View>
        </Animated.View>

        {/* Quick Stats */}
        <Animated.View
          style={[
            styles.quickStats,
            {
              opacity: fadeAnim,
              transform: [{ translateY: slideAnim }],
            },
          ]}
        >
          <View style={styles.quickStatItem}>
            <Text style={styles.quickStatValue}>
              {stats?.totalInvoicesCount || 0}
            </Text>
            <Text style={styles.quickStatLabel}>Total Invoices</Text>
          </View>
          <View style={[styles.quickStatDivider, { backgroundColor: colors.border }]} />
          <View style={styles.quickStatItem}>
            <Text style={styles.quickStatValue}>
              {stats?.totalClientsCount || 0}
            </Text>
            <Text style={styles.quickStatLabel}>Clients</Text>
          </View>
          <View style={[styles.quickStatDivider, { backgroundColor: colors.border }]} />
          <View style={styles.quickStatItem}>
            <Text style={styles.quickStatValue}>
              {stats?.thisMonthInvoicesCount || 0}
            </Text>
            <Text style={styles.quickStatLabel}>This Month</Text>
          </View>
        </Animated.View>

        {/* Voice Hint */}
        <View style={styles.voiceSection}>
          <Text style={styles.voiceHint}>Hold to create invoice</Text>
        </View>
      </ScrollView>

      {/* Voice Button */}
      <View style={styles.voiceButtonContainer}>
        <VoiceButton
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          isRecording={isRecording}
        />
      </View>

      <RecordingOverlay visible={isRecording} duration={recordingDuration} />
    </SafeAreaView>
  );
}

function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return "Good morning";
  if (hour < 17) return "Good afternoon";
  return "Good evening";
}

const createStyles = (
  colors: any,
  isDark: boolean,
  spacing: any,
  radius: any,
  typography: any
) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      paddingHorizontal: spacing.lg,
      paddingBottom: 180,
    },
    header: {
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "flex-start",
      paddingTop: spacing.md,
      marginBottom: spacing.xl,
    },
    greeting: {
      ...typography.subhead,
      color: colors.textTertiary,
      marginBottom: spacing.xs,
    },
    businessName: {
      ...typography.largeTitle,
      color: colors.text,
    },
    themeButton: {
      width: 44,
      height: 44,
      borderRadius: 22,
      backgroundColor: colors.backgroundSecondary,
      alignItems: "center",
      justifyContent: "center",
      shadowColor: colors.shadow,
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: isDark ? 0.3 : 0.08,
      shadowRadius: 8,
      elevation: 3,
    },
    // Main Revenue Card
    mainCard: {
      backgroundColor: colors.card,
      borderRadius: radius.xl,
      padding: spacing.lg,
      marginBottom: spacing.md,
      shadowColor: colors.shadow,
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: isDark ? 0.4 : 0.08,
      shadowRadius: 16,
      elevation: 5,
    },
    mainCardHeader: {
      flexDirection: "row",
      alignItems: "center",
      marginBottom: spacing.md,
    },
    iconContainer: {
      width: 36,
      height: 36,
      borderRadius: 12,
      backgroundColor: isDark ? "rgba(0, 214, 50, 0.15)" : "rgba(0, 214, 50, 0.1)",
      alignItems: "center",
      justifyContent: "center",
      marginRight: spacing.sm,
    },
    mainCardLabel: {
      ...typography.subhead,
      color: colors.textTertiary,
    },
    mainCardAmount: {
      ...typography.amount,
      color: colors.primary,
      marginBottom: spacing.xs,
    },
    mainCardSubtext: {
      ...typography.footnote,
      color: colors.textTertiary,
    },
    // Stats Row
    statsRow: {
      flexDirection: "row",
      gap: spacing.md,
      marginBottom: spacing.lg,
    },
    statCard: {
      flex: 1,
      backgroundColor: colors.card,
      borderRadius: radius.lg,
      padding: spacing.md,
      shadowColor: colors.shadow,
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: isDark ? 0.3 : 0.06,
      shadowRadius: 8,
      elevation: 3,
    },
    statCardPending: {
      borderLeftWidth: 3,
      borderLeftColor: colors.alert,
    },
    statCardOverdue: {
      borderLeftWidth: 3,
      borderLeftColor: colors.statusOverdue,
    },
    statIconContainer: {
      marginBottom: spacing.sm,
    },
    statLabel: {
      ...typography.caption1,
      color: colors.textTertiary,
      marginBottom: spacing.xs,
    },
    statAmount: {
      ...typography.amountSmall,
      color: colors.text,
    },
    statSubtext: {
      ...typography.caption2,
      color: colors.textTertiary,
      marginTop: spacing.xs,
    },
    // Quick Stats
    quickStats: {
      flexDirection: "row",
      backgroundColor: colors.card,
      borderRadius: radius.lg,
      padding: spacing.md,
      marginBottom: spacing.xl,
      shadowColor: colors.shadow,
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: isDark ? 0.3 : 0.06,
      shadowRadius: 8,
      elevation: 3,
    },
    quickStatItem: {
      flex: 1,
      alignItems: "center",
    },
    quickStatDivider: {
      width: 1,
      alignSelf: "stretch",
      marginVertical: 4,
    },
    quickStatValue: {
      ...typography.title2,
      color: colors.text,
      marginBottom: 2,
    },
    quickStatLabel: {
      ...typography.caption2,
      color: colors.textTertiary,
    },
    // Voice Section
    voiceSection: {
      alignItems: "center",
      marginTop: spacing.xl,
    },
    voiceHint: {
      ...typography.footnote,
      color: colors.textTertiary,
    },
    voiceButtonContainer: {
      position: "absolute",
      bottom: 120,
      left: 0,
      right: 0,
      alignItems: "center",
    },
  });


=================================================================================
FILE: ./app/(tabs)/invoices.tsx
=================================================================================

import React, { useState, useCallback, useEffect } from "react";
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  Pressable,
  RefreshControl,
  TextInput,
  Alert,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useRouter } from "expo-router";
import { Search, X } from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { useInvoiceStore } from "@/store/useInvoiceStore";
import { useTheme } from "@/lib/theme";
import { Invoice, InvoiceStatus } from "@/types";
import { InvoiceCard } from "@/components/InvoiceCard";
import { EmptyState } from "@/components/EmptyState";
import { SkeletonCard } from "@/components/SkeletonCard";

type FilterType = "all" | InvoiceStatus;

export default function InvoicesScreen() {
  const router = useRouter();
  const { colors, typography, spacing, radius } = useTheme();
  const { invoices, isLoading, fetchInvoices, updateInvoice } = useInvoiceStore();

  const [activeFilter, setActiveFilter] = useState<FilterType>("all");
  const [searchQuery, setSearchQuery] = useState("");
  const [refreshing, setRefreshing] = useState(false);

  useEffect(() => {
    fetchInvoices();
  }, []);

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    await fetchInvoices();
    setRefreshing(false);
  }, [fetchInvoices]);

  // Filter by status
  const statusFilteredInvoices = invoices.filter((inv) => {
    if (activeFilter === "all") return true;
    return inv.status === activeFilter;
  });

  // Filter by search query
  const filteredInvoices = statusFilteredInvoices.filter((inv) => {
    if (!searchQuery) return true;
    const query = searchQuery.toLowerCase();
    return (
      inv.client_name.toLowerCase().includes(query) ||
      inv.invoice_number.toLowerCase().includes(query)
    );
  });

  // Sort by date (newest first)
  const sortedInvoices = [...filteredInvoices].sort(
    (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  );

  const handleInvoicePress = (invoice: Invoice) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    router.push(`/invoice/${invoice.id}`);
  };

  const handleMarkPaid = async (invoice: Invoice) => {
    try {
      await updateInvoice(invoice.id, { status: "paid", paid_at: new Date().toISOString() });
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error) {
      console.error("Error marking invoice as paid:", error);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    }
  };

  const handleRemind = (invoice: Invoice) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    // Open native SMS/WhatsApp with pre-filled reminder
    Alert.alert(
      "Send Reminder",
      `Send a payment reminder to ${invoice.client_name}?`,
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Send",
          onPress: () => {
            // TODO: Implement native share with reminder template
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          },
        },
      ]
    );
  };

  const handleVoid = (invoice: Invoice) => {
    Alert.alert(
      "Void Invoice",
      `Are you sure you want to void invoice ${invoice.invoice_number}? This action cannot be undone.`,
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Void Invoice",
          style: "destructive",
          onPress: async () => {
            try {
              await updateInvoice(invoice.id, { status: "void" });
              Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
            } catch (error) {
              console.error("Error voiding invoice:", error);
              Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
            }
          },
        },
      ]
    );
  };

  const handleMore = (invoice: Invoice) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    router.push(`/invoice/${invoice.id}`);
  };

  const handleFilterPress = (filter: FilterType) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setActiveFilter(filter);
  };

  const filters: FilterType[] = ["all", "draft", "sent", "paid", "overdue"];

  const getFilterCount = (filter: FilterType): number => {
    if (filter === "all") return invoices.length;
    return invoices.filter((i) => i.status === filter).length;
  };

  const ListHeader = () => (
    <View>
      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <View
          style={[
            styles.searchBox,
            {
              backgroundColor: colors.backgroundSecondary,
              borderRadius: radius.md,
            },
          ]}
        >
          <Search size={18} color={colors.textTertiary} />
          <TextInput
            style={[styles.searchInput, typography.body, { color: colors.text }]}
            placeholder="Search invoices..."
            placeholderTextColor={colors.textTertiary}
            value={searchQuery}
            onChangeText={setSearchQuery}
          />
          {searchQuery.length > 0 && (
            <Pressable onPress={() => setSearchQuery("")}>
              <X size={18} color={colors.textTertiary} />
            </Pressable>
          )}
        </View>
      </View>

      {/* Filter Pills */}
      <View style={styles.filtersContainer}>
        {filters.map((filter) => {
          const isActive = activeFilter === filter;
          const count = getFilterCount(filter);

          // Hide empty status filters (except "all")
          if (filter !== "all" && count === 0) return null;

          return (
            <Pressable
              key={filter}
              onPress={() => handleFilterPress(filter)}
              style={[
                styles.filterPill,
                {
                  backgroundColor: isActive ? colors.text : colors.backgroundSecondary,
                  borderRadius: radius.full,
                },
              ]}
            >
              <Text
                style={[
                  typography.footnote,
                  {
                    color: isActive ? colors.background : colors.textSecondary,
                    fontWeight: "500",
                  },
                ]}
              >
                {filter.charAt(0).toUpperCase() + filter.slice(1)}
                {count > 0 && ` (${count})`}
              </Text>
            </Pressable>
          );
        })}
      </View>
    </View>
  );

  const renderInvoiceItem = ({ item }: { item: Invoice }) => (
    <InvoiceCard
      invoice={item}
      onPress={() => handleInvoicePress(item)}
      onMarkPaid={() => handleMarkPaid(item)}
      onRemind={() => handleRemind(item)}
      onVoid={() => handleVoid(item)}
      onMore={() => handleMore(item)}
    />
  );

  // Loading state
  if (isLoading && invoices.length === 0) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={["top"]}>
        <View style={styles.header}>
          <Text style={[typography.largeTitle, { color: colors.text }]}>Invoices</Text>
        </View>
        <SkeletonCard count={5} />
      </SafeAreaView>
    );
  }

  // Empty state - no invoices at all
  if (invoices.length === 0) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={["top"]}>
        <View style={styles.header}>
          <Text style={[typography.largeTitle, { color: colors.text }]}>Invoices</Text>
        </View>
        <EmptyState
          type="firstRun"
          onAction={() => router.push("/(tabs)")}
          actionLabel="Create First Invoice"
        />
      </SafeAreaView>
    );
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]} edges={["top"]}>
        {/* Header */}
        <View style={styles.header}>
          <Text style={[typography.largeTitle, { color: colors.text }]}>Invoices</Text>
          <Text style={[typography.subhead, { color: colors.textTertiary, marginTop: 2 }]}>
            {invoices.length} total
          </Text>
        </View>

        <FlatList
          data={sortedInvoices}
          keyExtractor={(item) => item.id}
          renderItem={renderInvoiceItem}
          ListHeaderComponent={ListHeader}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={false}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              tintColor={colors.primary}
            />
          }
          ListEmptyComponent={
            searchQuery ? (
              <EmptyState
                type="noResults"
                searchQuery={searchQuery}
                onAction={() => {
                  setSearchQuery("");
                  setActiveFilter("all");
                }}
                actionLabel="Clear Search"
              />
            ) : activeFilter !== "all" ? (
              <EmptyState
                type="allCaughtUp"
              />
            ) : null
          }
        />
      </SafeAreaView>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 8,
  },
  searchContainer: {
    paddingHorizontal: 16,
    paddingBottom: 12,
  },
  searchBox: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
    gap: 8,
  },
  searchInput: {
    flex: 1,
    padding: 0,
  },
  filtersContainer: {
    flexDirection: "row",
    paddingHorizontal: 16,
    paddingBottom: 16,
    gap: 8,
    flexWrap: "wrap",
  },
  filterPill: {
    paddingHorizontal: 14,
    paddingVertical: 8,
  },
  listContent: {
    paddingBottom: 120,
  },
});


=================================================================================
FILE: ./app/(tabs)/profile.tsx
=================================================================================

import React, { useEffect, useRef, useState } from "react";
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TextInput,
  Pressable,
  Animated,
  Alert,
  Switch,
  Modal,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useRouter } from "expo-router";
import {
  Camera,
  Check,
  Building2,
  Bell,
  Mail,
  MessageSquare,
  CreditCard,
  ChevronRight,
  Settings,
  Clock,
  Edit3,
  Download,
  Cloud,
  CloudOff,
  RefreshCw,
} from "lucide-react-native";
import * as Haptics from "expo-haptics";
import * as ImagePicker from "expo-image-picker";
import { Image } from "react-native";
import { useProfileStore } from "@/store/useProfileStore";
import { useReminderStore } from "@/store/useReminderStore";
import { useOfflineStore } from "@/store/useOfflineStore";
import { useTheme } from "@/lib/theme";
import { Button } from "@/components/ui/Button";

/**
 * Profile Screen
 * Per design-system.md - includes Stripe status and reminder settings
 */

export default function Profile() {
  const router = useRouter();
  const { colors, typography, spacing, radius, isDark } = useTheme();
  const { profile, updateProfile, fetchProfile, isSaving } = useProfileStore();
  const {
    settings: reminderSettings,
    fetchSettings: fetchReminderSettings,
    toggleEnabled,
    toggleSMS,
    toggleEmail,
    setDayIntervals,
    setMessageTemplate,
    isSaving: isSavingReminders,
  } = useReminderStore();
  const {
    isOnline,
    isSyncing,
    pendingUploads,
    pendingOperations,
    syncNow,
    initialize: initOffline,
  } = useOfflineStore();

  const [showReminderModal, setShowReminderModal] = useState(false);
  const [editingTemplate, setEditingTemplate] = useState(false);
  const [templateText, setTemplateText] = useState("");

  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(20)).current;

  useEffect(() => {
    fetchProfile();
    fetchReminderSettings();
    initOffline();

    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 500,
        useNativeDriver: true,
      }),
      Animated.spring(slideAnim, {
        toValue: 0,
        friction: 8,
        tension: 40,
        useNativeDriver: true,
      }),
    ]).start();
  }, []);

  useEffect(() => {
    if (reminderSettings?.message_template) {
      setTemplateText(reminderSettings.message_template);
    }
  }, [reminderSettings]);

  const pickImage = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 0.8,
    });

    if (!result.canceled && result.assets[0]) {
      updateProfile({ logo_url: result.assets[0].uri });
    }
  };

  const handleSave = async () => {
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    Alert.alert("Saved", "Your profile has been updated.");
  };

  const handleToggleReminders = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    try {
      await toggleEnabled();
    } catch (error) {
      Alert.alert("Error", "Failed to update reminder settings");
    }
  };

  const handleToggleSMS = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    try {
      await toggleSMS();
    } catch (error) {
      Alert.alert("Error", "Failed to update SMS settings");
    }
  };

  const handleToggleEmail = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    try {
      await toggleEmail();
    } catch (error) {
      Alert.alert("Error", "Failed to update email settings");
    }
  };

  const handleSaveTemplate = async () => {
    try {
      await setMessageTemplate(templateText);
      setEditingTemplate(false);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error) {
      Alert.alert("Error", "Failed to save template");
    }
  };

  const handleDayIntervalToggle = async (day: number) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    const currentIntervals = reminderSettings?.day_intervals || [3, 7, 14];
    let newIntervals: number[];

    if (currentIntervals.includes(day)) {
      newIntervals = currentIntervals.filter((d) => d !== day);
    } else {
      newIntervals = [...currentIntervals, day].sort((a, b) => a - b);
    }

    if (newIntervals.length === 0) {
      Alert.alert("Error", "You must have at least one reminder interval");
      return;
    }

    try {
      await setDayIntervals(newIntervals);
    } catch (error) {
      Alert.alert("Error", "Failed to update intervals");
    }
  };

  const handleSync = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    try {
      const result = await syncNow();
      if (result.uploads > 0 || result.operations > 0) {
        Alert.alert(
          "Sync Complete",
          `Synced ${result.uploads} uploads and ${result.operations} operations`
        );
      } else if (result.errors > 0) {
        Alert.alert("Sync Issue", `${result.errors} items failed to sync`);
      } else {
        Alert.alert("All Synced", "Everything is up to date");
      }
    } catch (error) {
      Alert.alert("Sync Failed", "Failed to sync data");
    }
  };

  const stripeConnected = profile?.charges_enabled && profile?.payouts_enabled;
  const totalPending = pendingUploads + pendingOperations;

  const styles = createStyles(colors, isDark, spacing, radius, typography);

  const InputField = ({
    label,
    value,
    onChangeText,
    placeholder,
    keyboardType = "default",
    multiline = false,
    autoCapitalize = "sentences",
  }: {
    label: string;
    value: string;
    onChangeText: (text: string) => void;
    placeholder: string;
    keyboardType?: "default" | "email-address" | "phone-pad" | "decimal-pad";
    multiline?: boolean;
    autoCapitalize?: "none" | "sentences" | "words" | "characters";
  }) => (
    <View style={styles.inputContainer}>
      <Text style={styles.inputLabel}>{label}</Text>
      <TextInput
        style={[styles.input, multiline && styles.inputMultiline]}
        value={value}
        onChangeText={onChangeText}
        placeholder={placeholder}
        placeholderTextColor={colors.textTertiary}
        keyboardType={keyboardType}
        multiline={multiline}
        autoCapitalize={autoCapitalize}
      />
    </View>
  );

  const SettingRow = ({
    icon,
    title,
    subtitle,
    rightElement,
    onPress,
  }: {
    icon: React.ReactNode;
    title: string;
    subtitle?: string;
    rightElement?: React.ReactNode;
    onPress?: () => void;
  }) => (
    <Pressable
      style={styles.settingRow}
      onPress={onPress}
      disabled={!onPress}
    >
      <View style={[styles.settingIcon, { backgroundColor: colors.primary + "15" }]}>
        {icon}
      </View>
      <View style={styles.settingContent}>
        <Text style={[typography.body, { color: colors.text }]}>{title}</Text>
        {subtitle && (
          <Text style={[typography.caption1, { color: colors.textTertiary }]}>
            {subtitle}
          </Text>
        )}
      </View>
      {rightElement}
    </Pressable>
  );

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        <Animated.View
          style={[
            styles.header,
            { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
          ]}
        >
          <Text style={styles.title}>Profile</Text>
          <Text style={styles.subtitle}>Business information</Text>
        </Animated.View>

        {/* Logo Section */}
        <Animated.View
          style={[
            styles.logoSection,
            { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
          ]}
        >
          <Pressable onPress={pickImage} style={styles.logoContainer}>
            {profile?.logo_url ? (
              <Image source={{ uri: profile.logo_url }} style={styles.logoImage} />
            ) : (
              <View style={styles.logoPlaceholder}>
                <Building2 size={32} color={colors.textTertiary} />
              </View>
            )}
            <View style={styles.cameraButton}>
              <Camera size={16} color="#FFFFFF" />
            </View>
          </Pressable>
          <Text style={styles.logoHint}>Tap to add logo</Text>
        </Animated.View>

        {/* Business Info Form */}
        <Animated.View
          style={[
            styles.formSection,
            { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
          ]}
        >
          <InputField
            label="Business Name"
            value={profile?.business_name || ""}
            onChangeText={(text) => updateProfile({ business_name: text })}
            placeholder="Your Business Name"
            autoCapitalize="words"
          />

          <InputField
            label="Owner Name"
            value={profile?.full_name || ""}
            onChangeText={(text) => updateProfile({ full_name: text })}
            placeholder="Your Full Name"
            autoCapitalize="words"
          />

          <InputField
            label="Tax Rate (%)"
            value={profile?.tax_rate?.toString() || "0"}
            onChangeText={(text) => updateProfile({ tax_rate: parseFloat(text) || 0 })}
            placeholder="0"
            keyboardType="decimal-pad"
          />
        </Animated.View>

        {/* Stripe Connect Section */}
        <Animated.View
          style={[
            styles.section,
            { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
          ]}
        >
          <Text style={styles.sectionTitle}>Payments</Text>
          <View style={styles.settingsCard}>
            <SettingRow
              icon={<CreditCard size={20} color={colors.primary} />}
              title="Stripe Connect"
              subtitle={
                stripeConnected
                  ? "Connected - accepting payments"
                  : "Connect to accept card payments"
              }
              rightElement={
                stripeConnected ? (
                  <View style={[styles.badge, { backgroundColor: colors.statusPaid + "20" }]}>
                    <Text style={[typography.caption2, { color: colors.statusPaid, fontWeight: "600" }]}>
                      Active
                    </Text>
                  </View>
                ) : (
                  <ChevronRight size={20} color={colors.textTertiary} />
                )
              }
              onPress={() => router.push("/stripe/onboarding")}
            />
          </View>
        </Animated.View>

        {/* Auto-Reminders Section ("Bad Cop") */}
        <Animated.View
          style={[
            styles.section,
            { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
          ]}
        >
          <Text style={styles.sectionTitle}>Auto-Reminders</Text>
          <View style={styles.settingsCard}>
            <SettingRow
              icon={<Bell size={20} color={colors.primary} />}
              title="Enable Auto-Reminders"
              subtitle="Automatically remind clients about overdue invoices"
              rightElement={
                <Switch
                  value={reminderSettings?.enabled || false}
                  onValueChange={handleToggleReminders}
                  trackColor={{ false: colors.border, true: colors.primary }}
                  thumbColor="#FFFFFF"
                />
              }
            />

            {reminderSettings?.enabled && (
              <>
                <View style={[styles.divider, { backgroundColor: colors.border }]} />

                <SettingRow
                  icon={<MessageSquare size={20} color={colors.primary} />}
                  title="SMS Reminders"
                  subtitle="Send text message reminders"
                  rightElement={
                    <Switch
                      value={reminderSettings?.sms_enabled || false}
                      onValueChange={handleToggleSMS}
                      trackColor={{ false: colors.border, true: colors.primary }}
                      thumbColor="#FFFFFF"
                    />
                  }
                />

                <View style={[styles.divider, { backgroundColor: colors.border }]} />

                <SettingRow
                  icon={<Mail size={20} color={colors.primary} />}
                  title="Email Reminders"
                  subtitle="Send email reminders"
                  rightElement={
                    <Switch
                      value={reminderSettings?.email_enabled || false}
                      onValueChange={handleToggleEmail}
                      trackColor={{ false: colors.border, true: colors.primary }}
                      thumbColor="#FFFFFF"
                    />
                  }
                />

                <View style={[styles.divider, { backgroundColor: colors.border }]} />

                <SettingRow
                  icon={<Clock size={20} color={colors.primary} />}
                  title="Reminder Schedule"
                  subtitle="Configure when reminders are sent"
                  rightElement={<ChevronRight size={20} color={colors.textTertiary} />}
                  onPress={() => setShowReminderModal(true)}
                />

                <View style={[styles.divider, { backgroundColor: colors.border }]} />

                <SettingRow
                  icon={<Edit3 size={20} color={colors.primary} />}
                  title="Message Template"
                  subtitle="Customize reminder message"
                  rightElement={<ChevronRight size={20} color={colors.textTertiary} />}
                  onPress={() => setEditingTemplate(true)}
                />
              </>
            )}
          </View>
        </Animated.View>

        {/* Data & Sync Section */}
        <Animated.View
          style={[
            styles.section,
            { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
          ]}
        >
          <Text style={styles.sectionTitle}>Data & Sync</Text>
          <View style={styles.settingsCard}>
            <SettingRow
              icon={
                isOnline ? (
                  <Cloud size={20} color={colors.primary} />
                ) : (
                  <CloudOff size={20} color={colors.statusOverdue} />
                )
              }
              title={isOnline ? "Online" : "Offline"}
              subtitle={
                totalPending > 0
                  ? `${totalPending} item${totalPending !== 1 ? "s" : ""} pending sync`
                  : "All data synced"
              }
              rightElement={
                isOnline && totalPending > 0 ? (
                  <Pressable
                    style={[styles.syncButton, { backgroundColor: colors.primary }]}
                    onPress={handleSync}
                    disabled={isSyncing}
                  >
                    <RefreshCw
                      size={14}
                      color="#FFFFFF"
                      style={isSyncing ? { opacity: 0.5 } : undefined}
                    />
                    <Text style={styles.syncButtonText}>
                      {isSyncing ? "Syncing" : "Sync"}
                    </Text>
                  </Pressable>
                ) : (
                  <View
                    style={[
                      styles.badge,
                      {
                        backgroundColor: isOnline
                          ? colors.statusPaid + "20"
                          : colors.statusOverdue + "20",
                      },
                    ]}
                  >
                    <Text
                      style={[
                        typography.caption2,
                        {
                          color: isOnline ? colors.statusPaid : colors.statusOverdue,
                          fontWeight: "600",
                        },
                      ]}
                    >
                      {isOnline ? "Synced" : "Offline"}
                    </Text>
                  </View>
                )
              }
            />

            <View style={[styles.divider, { backgroundColor: colors.border }]} />

            <SettingRow
              icon={<Download size={20} color={colors.primary} />}
              title="Export Data"
              subtitle="Export invoices for QuickBooks"
              rightElement={<ChevronRight size={20} color={colors.textTertiary} />}
              onPress={() => router.push("/export")}
            />
          </View>
        </Animated.View>

        {/* Save Button */}
        <Animated.View style={[styles.saveButtonContainer, { opacity: fadeAnim }]}>
          <Pressable
            style={({ pressed }) => [
              styles.saveButton,
              pressed && styles.saveButtonPressed,
            ]}
            onPress={handleSave}
          >
            <Check size={20} color="#FFFFFF" />
            <Text style={styles.saveButtonText}>
              {isSaving ? "Saving..." : "Save Profile"}
            </Text>
          </Pressable>
        </Animated.View>
      </ScrollView>

      {/* Reminder Schedule Modal */}
      <Modal
        visible={showReminderModal}
        animationType="slide"
        presentationStyle="pageSheet"
        onRequestClose={() => setShowReminderModal(false)}
      >
        <SafeAreaView style={[styles.modalContainer, { backgroundColor: colors.background }]}>
          <View style={styles.modalHeader}>
            <Pressable onPress={() => setShowReminderModal(false)}>
              <Text style={[typography.body, { color: colors.primary }]}>Close</Text>
            </Pressable>
            <Text style={[typography.headline, { color: colors.text }]}>Reminder Schedule</Text>
            <View style={{ width: 50 }} />
          </View>

          <View style={styles.modalContent}>
            <Text style={[typography.footnote, { color: colors.textSecondary, marginBottom: spacing.md }]}>
              Send reminders on these days after the due date:
            </Text>

            {[3, 7, 14, 21, 30].map((day) => (
              <Pressable
                key={day}
                style={[
                  styles.dayOption,
                  {
                    backgroundColor: (reminderSettings?.day_intervals || []).includes(day)
                      ? colors.primary + "15"
                      : colors.backgroundSecondary,
                    borderRadius: radius.md,
                  },
                ]}
                onPress={() => handleDayIntervalToggle(day)}
              >
                <Text style={[typography.body, { color: colors.text }]}>
                  {day} days overdue
                </Text>
                {(reminderSettings?.day_intervals || []).includes(day) && (
                  <Check size={20} color={colors.primary} />
                )}
              </Pressable>
            ))}

            <Text style={[typography.caption1, { color: colors.textTertiary, marginTop: spacing.lg }]}>
              Reminders are sent automatically at 9 AM in your timezone
            </Text>
          </View>
        </SafeAreaView>
      </Modal>

      {/* Message Template Modal */}
      <Modal
        visible={editingTemplate}
        animationType="slide"
        presentationStyle="pageSheet"
        onRequestClose={() => setEditingTemplate(false)}
      >
        <SafeAreaView style={[styles.modalContainer, { backgroundColor: colors.background }]}>
          <View style={styles.modalHeader}>
            <Pressable onPress={() => setEditingTemplate(false)}>
              <Text style={[typography.body, { color: colors.textSecondary }]}>Cancel</Text>
            </Pressable>
            <Text style={[typography.headline, { color: colors.text }]}>Message Template</Text>
            <Pressable onPress={handleSaveTemplate}>
              <Text style={[typography.body, { color: colors.primary, fontWeight: "600" }]}>
                Save
              </Text>
            </Pressable>
          </View>

          <View style={styles.modalContent}>
            <Text style={[typography.footnote, { color: colors.textSecondary, marginBottom: spacing.sm }]}>
              Available variables:
            </Text>
            <Text style={[typography.caption1, { color: colors.textTertiary, marginBottom: spacing.md }]}>
              {"{{invoice_number}}, {{business_name}}, {{total}}, {{days_overdue}}, {{payment_link}}"}
            </Text>

            <TextInput
              style={[
                styles.templateInput,
                {
                  backgroundColor: colors.backgroundSecondary,
                  color: colors.text,
                  borderRadius: radius.md,
                },
              ]}
              value={templateText}
              onChangeText={setTemplateText}
              multiline
              numberOfLines={6}
              placeholder="Enter your reminder message template..."
              placeholderTextColor={colors.textTertiary}
            />

            <View style={[styles.previewCard, { backgroundColor: colors.card, borderRadius: radius.md }]}>
              <Text style={[typography.caption1, { color: colors.textSecondary, marginBottom: spacing.xs }]}>
                Preview:
              </Text>
              <Text style={[typography.footnote, { color: colors.text, lineHeight: 20 }]}>
                {templateText
                  .replace(/\{\{invoice_number\}\}/g, "INV-0042")
                  .replace(/\{\{business_name\}\}/g, profile?.business_name || "Your Business")
                  .replace(/\{\{total\}\}/g, "$1,250")
                  .replace(/\{\{days_overdue\}\}/g, "7")
                  .replace(/\{\{payment_link\}\}/g, "https://pay.stripe.com/...")}
              </Text>
            </View>
          </View>
        </SafeAreaView>
      </Modal>
    </SafeAreaView>
  );
}

const createStyles = (colors: any, isDark: boolean, spacing: any, radius: any, typography: any) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      paddingBottom: 120,
    },
    header: {
      paddingHorizontal: spacing.lg,
      paddingTop: spacing.md,
      paddingBottom: spacing.md,
    },
    title: {
      ...typography.largeTitle,
      color: colors.text,
    },
    subtitle: {
      ...typography.subhead,
      color: colors.textTertiary,
      marginTop: spacing.xs,
    },
    logoSection: {
      alignItems: "center",
      paddingVertical: spacing.lg,
    },
    logoContainer: {
      position: "relative",
    },
    logoImage: {
      width: 100,
      height: 100,
      borderRadius: radius.xl,
    },
    logoPlaceholder: {
      width: 100,
      height: 100,
      borderRadius: radius.xl,
      backgroundColor: colors.backgroundSecondary,
      alignItems: "center",
      justifyContent: "center",
      borderWidth: 2,
      borderColor: colors.border,
      borderStyle: "dashed",
    },
    cameraButton: {
      position: "absolute",
      bottom: -4,
      right: -4,
      width: 32,
      height: 32,
      borderRadius: 16,
      backgroundColor: colors.primary,
      alignItems: "center",
      justifyContent: "center",
      shadowColor: colors.shadow,
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.2,
      shadowRadius: 4,
      elevation: 3,
    },
    logoHint: {
      ...typography.caption1,
      color: colors.textTertiary,
      marginTop: spacing.sm,
    },
    formSection: {
      paddingHorizontal: spacing.lg,
    },
    inputContainer: {
      marginBottom: spacing.md,
    },
    inputLabel: {
      ...typography.caption1,
      color: colors.textTertiary,
      marginBottom: spacing.sm,
      fontWeight: "500",
    },
    input: {
      backgroundColor: colors.backgroundSecondary,
      borderRadius: radius.md,
      paddingHorizontal: spacing.md,
      paddingVertical: spacing.md,
      ...typography.body,
      color: colors.text,
      borderWidth: 1,
      borderColor: colors.border,
    },
    inputMultiline: {
      minHeight: 80,
      textAlignVertical: "top",
    },
    section: {
      paddingHorizontal: spacing.lg,
      marginTop: spacing.lg,
    },
    sectionTitle: {
      ...typography.footnote,
      color: colors.textTertiary,
      fontWeight: "600",
      marginBottom: spacing.sm,
      textTransform: "uppercase",
      letterSpacing: 0.5,
    },
    settingsCard: {
      backgroundColor: colors.card,
      borderRadius: radius.lg,
      overflow: "hidden",
    },
    settingRow: {
      flexDirection: "row",
      alignItems: "center",
      padding: spacing.md,
    },
    settingIcon: {
      width: 36,
      height: 36,
      borderRadius: 10,
      alignItems: "center",
      justifyContent: "center",
      marginRight: spacing.sm,
    },
    settingContent: {
      flex: 1,
    },
    badge: {
      paddingHorizontal: 8,
      paddingVertical: 4,
      borderRadius: 12,
    },
    syncButton: {
      flexDirection: "row",
      alignItems: "center",
      paddingHorizontal: 12,
      paddingVertical: 6,
      borderRadius: 8,
      gap: 4,
    },
    syncButtonText: {
      color: "#FFFFFF",
      fontSize: 13,
      fontWeight: "600",
    },
    divider: {
      height: 1,
      marginLeft: 56,
    },
    saveButtonContainer: {
      paddingHorizontal: spacing.lg,
      paddingTop: spacing.xl,
    },
    saveButton: {
      flexDirection: "row",
      alignItems: "center",
      justifyContent: "center",
      backgroundColor: colors.primary,
      paddingVertical: spacing.md,
      borderRadius: radius.full,
      gap: spacing.sm,
      shadowColor: colors.primary,
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.3,
      shadowRadius: 8,
      elevation: 5,
    },
    saveButtonPressed: {
      opacity: 0.9,
      transform: [{ scale: 0.98 }],
    },
    saveButtonText: {
      ...typography.headline,
      color: "#FFFFFF",
    },
    // Modal Styles
    modalContainer: {
      flex: 1,
    },
    modalHeader: {
      flexDirection: "row",
      alignItems: "center",
      justifyContent: "space-between",
      paddingHorizontal: spacing.md,
      paddingVertical: spacing.md,
      borderBottomWidth: StyleSheet.hairlineWidth,
      borderBottomColor: colors.border,
    },
    modalContent: {
      padding: spacing.lg,
    },
    dayOption: {
      flexDirection: "row",
      alignItems: "center",
      justifyContent: "space-between",
      padding: spacing.md,
      marginBottom: spacing.sm,
    },
    templateInput: {
      padding: spacing.md,
      minHeight: 150,
      textAlignVertical: "top",
      ...typography.body,
    },
    previewCard: {
      padding: spacing.md,
      marginTop: spacing.md,
    },
  });


=================================================================================
FILE: ./app/+not-found.tsx
=================================================================================

import { View, Text } from "react-native";
import { Link } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";

export default function NotFound() {
  return (
    <SafeAreaView className="flex-1 bg-white items-center justify-center px-6">
      <Text className="text-6xl mb-4"></Text>
      <Text className="text-2xl font-bold mb-2">Page Not Found</Text>
      <Text className="text-gray-500 text-center mb-6">
        The page you're looking for doesn't exist.
      </Text>
      <Link href="/" className="text-primary font-semibold text-lg">
        Go to Dashboard
      </Link>
    </SafeAreaView>
  );
}


=================================================================================
FILE: ./app/export.tsx
=================================================================================

import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { Ionicons } from "@expo/vector-icons";
import { router } from "expo-router";
import { useTheme } from "@/lib/theme";
import {
  exportAndShareInvoices,
  getDateRangePresets,
  getStatusOptions,
  ExportFormat,
} from "@/services/export";

export default function ExportScreen() {
  const { colors } = useTheme();
  const [format, setFormat] = useState<ExportFormat>("csv");
  const [dateRange, setDateRange] = useState("all_time");
  const [status, setStatus] = useState("");
  const [includeItems, setIncludeItems] = useState(true);
  const [isExporting, setIsExporting] = useState(false);

  const datePresets = getDateRangePresets();
  const statusOptions = getStatusOptions();

  const handleExport = async () => {
    setIsExporting(true);

    try {
      const preset = datePresets.find((p) => p.value === dateRange);
      const range = preset?.getRange() || { startDate: "", endDate: "" };

      const result = await exportAndShareInvoices({
        format,
        startDate: range.startDate || undefined,
        endDate: range.endDate || undefined,
        status: status as any || undefined,
        includeItems,
      });

      if (result.success) {
        Alert.alert(
          "Export Complete",
          `Your invoices have been exported to ${result.filename}`,
          [{ text: "OK" }]
        );
      } else {
        Alert.alert("Export Failed", result.error || "Failed to export invoices");
      }
    } catch (error: any) {
      Alert.alert("Error", error.message || "An error occurred during export");
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      {/* Header */}
      <View style={[styles.header, { borderBottomColor: colors.border }]}>
        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
          <Ionicons name="chevron-back" size={24} color={colors.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: colors.text }]}>
          Export Data
        </Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Format Selection */}
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>
            Export Format
          </Text>
          <View style={styles.optionRow}>
            <TouchableOpacity
              style={[
                styles.formatOption,
                {
                  backgroundColor: format === "csv" ? colors.primary : colors.surface,
                  borderColor: format === "csv" ? colors.primary : colors.border,
                },
              ]}
              onPress={() => setFormat("csv")}
            >
              <Ionicons
                name="document-text"
                size={24}
                color={format === "csv" ? "white" : colors.text}
              />
              <Text
                style={[
                  styles.formatLabel,
                  { color: format === "csv" ? "white" : colors.text },
                ]}
              >
                CSV
              </Text>
              <Text
                style={[
                  styles.formatDescription,
                  { color: format === "csv" ? "rgba(255,255,255,0.7)" : colors.textSecondary },
                ]}
              >
                Excel, Sheets
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.formatOption,
                {
                  backgroundColor: format === "iif" ? colors.primary : colors.surface,
                  borderColor: format === "iif" ? colors.primary : colors.border,
                },
              ]}
              onPress={() => setFormat("iif")}
            >
              <Ionicons
                name="calculator"
                size={24}
                color={format === "iif" ? "white" : colors.text}
              />
              <Text
                style={[
                  styles.formatLabel,
                  { color: format === "iif" ? "white" : colors.text },
                ]}
              >
                IIF
              </Text>
              <Text
                style={[
                  styles.formatDescription,
                  { color: format === "iif" ? "rgba(255,255,255,0.7)" : colors.textSecondary },
                ]}
              >
                QuickBooks
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Date Range */}
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>
            Date Range
          </Text>
          <View style={[styles.pickerContainer, { backgroundColor: colors.surface, borderColor: colors.border }]}>
            {datePresets.map((preset) => (
              <TouchableOpacity
                key={preset.value}
                style={[
                  styles.pickerOption,
                  {
                    backgroundColor: dateRange === preset.value ? colors.primary + "15" : "transparent",
                    borderColor: dateRange === preset.value ? colors.primary : "transparent",
                  },
                ]}
                onPress={() => setDateRange(preset.value)}
              >
                {dateRange === preset.value && (
                  <Ionicons name="checkmark" size={16} color={colors.primary} />
                )}
                <Text
                  style={[
                    styles.pickerLabel,
                    {
                      color: dateRange === preset.value ? colors.primary : colors.text,
                      fontWeight: dateRange === preset.value ? "600" : "400",
                    },
                  ]}
                >
                  {preset.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* Status Filter */}
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: colors.text }]}>
            Invoice Status
          </Text>
          <View style={[styles.pickerContainer, { backgroundColor: colors.surface, borderColor: colors.border }]}>
            {statusOptions.map((option) => (
              <TouchableOpacity
                key={option.value}
                style={[
                  styles.pickerOption,
                  {
                    backgroundColor: status === option.value ? colors.primary + "15" : "transparent",
                    borderColor: status === option.value ? colors.primary : "transparent",
                  },
                ]}
                onPress={() => setStatus(option.value)}
              >
                {status === option.value && (
                  <Ionicons name="checkmark" size={16} color={colors.primary} />
                )}
                <Text
                  style={[
                    styles.pickerLabel,
                    {
                      color: status === option.value ? colors.primary : colors.text,
                      fontWeight: status === option.value ? "600" : "400",
                    },
                  ]}
                >
                  {option.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        {/* Include Line Items */}
        <View style={styles.section}>
          <TouchableOpacity
            style={[styles.toggleRow, { backgroundColor: colors.surface, borderColor: colors.border }]}
            onPress={() => setIncludeItems(!includeItems)}
          >
            <View style={styles.toggleContent}>
              <Text style={[styles.toggleLabel, { color: colors.text }]}>
                Include Line Items
              </Text>
              <Text style={[styles.toggleDescription, { color: colors.textSecondary }]}>
                Export each invoice item as a separate row
              </Text>
            </View>
            <View
              style={[
                styles.checkbox,
                {
                  backgroundColor: includeItems ? colors.primary : "transparent",
                  borderColor: includeItems ? colors.primary : colors.border,
                },
              ]}
            >
              {includeItems && (
                <Ionicons name="checkmark" size={16} color="white" />
              )}
            </View>
          </TouchableOpacity>
        </View>

        {/* Info Card */}
        <View style={[styles.infoCard, { backgroundColor: colors.surface, borderColor: colors.border }]}>
          <Ionicons name="information-circle" size={20} color={colors.primary} />
          <View style={styles.infoContent}>
            <Text style={[styles.infoTitle, { color: colors.text }]}>
              QuickBooks Import
            </Text>
            <Text style={[styles.infoText, { color: colors.textSecondary }]}>
              To import into QuickBooks Desktop, use the IIF format.{"\n"}
              For QuickBooks Online, use CSV and import via the Banking menu.
            </Text>
          </View>
        </View>

        {/* Spacer for button */}
        <View style={{ height: 100 }} />
      </ScrollView>

      {/* Export Button */}
      <View style={[styles.footer, { backgroundColor: colors.background, borderTopColor: colors.border }]}>
        <TouchableOpacity
          style={[styles.exportButton, { backgroundColor: colors.primary }]}
          onPress={handleExport}
          disabled={isExporting}
        >
          {isExporting ? (
            <ActivityIndicator color="white" />
          ) : (
            <>
              <Ionicons name="download" size={20} color="white" />
              <Text style={styles.exportButtonText}>Export Invoices</Text>
            </>
          )}
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 17,
    fontWeight: "600",
  },
  placeholder: {
    width: 32,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: "600",
    marginBottom: 12,
  },
  optionRow: {
    flexDirection: "row",
    gap: 12,
  },
  formatOption: {
    flex: 1,
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: "center",
    gap: 8,
  },
  formatLabel: {
    fontSize: 16,
    fontWeight: "600",
  },
  formatDescription: {
    fontSize: 13,
  },
  pickerContainer: {
    borderRadius: 12,
    borderWidth: 1,
    overflow: "hidden",
  },
  pickerOption: {
    flexDirection: "row",
    alignItems: "center",
    padding: 14,
    gap: 8,
    borderWidth: 1,
    borderRadius: 0,
    marginHorizontal: -1,
  },
  pickerLabel: {
    fontSize: 15,
  },
  toggleRow: {
    flexDirection: "row",
    alignItems: "center",
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
  },
  toggleContent: {
    flex: 1,
  },
  toggleLabel: {
    fontSize: 15,
    fontWeight: "500",
  },
  toggleDescription: {
    fontSize: 13,
    marginTop: 2,
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: 6,
    borderWidth: 2,
    justifyContent: "center",
    alignItems: "center",
  },
  infoCard: {
    flexDirection: "row",
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    gap: 12,
  },
  infoContent: {
    flex: 1,
  },
  infoTitle: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: 4,
  },
  infoText: {
    fontSize: 13,
    lineHeight: 18,
  },
  footer: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    padding: 16,
    paddingBottom: 32,
    borderTopWidth: 1,
  },
  exportButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    padding: 16,
    borderRadius: 12,
    gap: 8,
  },
  exportButtonText: {
    color: "white",
    fontSize: 16,
    fontWeight: "600",
  },
});


=================================================================================
FILE: ./app/index.tsx
=================================================================================

import { Redirect } from "expo-router";

export default function Index() {
  return <Redirect href="/(tabs)" />;
}


=================================================================================
FILE: ./app/invoice/[id].tsx
=================================================================================

import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  ScrollView,
  Alert,
  Pressable,
  StyleSheet,
  ActivityIndicator,
  ActionSheetIOS,
  Platform,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useRouter, useLocalSearchParams } from "expo-router";
import {
  ArrowLeft,
  Share2,
  FileText,
  MessageSquare,
  Mail,
  CheckCircle,
  Clock,
  AlertCircle,
  CreditCard,
  ExternalLink,
  MoreHorizontal,
} from "lucide-react-native";
import * as Haptics from "expo-haptics";
import * as Linking from "expo-linking";
import { useTheme, getStatusColor } from "@/lib/theme";
import { Button } from "@/components/ui/Button";
import { useInvoiceStore } from "@/store/useInvoiceStore";
import { useProfileStore } from "@/store/useProfileStore";
import { Invoice, formatCurrency, formatRelativeDate } from "@/types";
import { sendInvoice, generateInvoicePDF } from "@/services/invoice";
import { getPaymentLink } from "@/services/stripe";
import * as db from "@/services/database";

/**
 * Invoice Detail Screen
 * Per design-system.md and product-strategy.md
 *
 * Features:
 * - Full invoice view with status
 * - Send invoice flow (PDF + payment link + share)
 * - Multiple share options (SMS, WhatsApp, Email)
 * - Mark as paid
 * - View payment link
 */

export default function InvoiceDetail() {
  const router = useRouter();
  const { id } = useLocalSearchParams<{ id: string }>();
  const { colors, typography, spacing, radius, shadows, isDark } = useTheme();
  const { invoices, fetchInvoice, updateInvoice } = useInvoiceStore();
  const { profile } = useProfileStore();

  const [invoice, setInvoice] = useState<Invoice | null>(null);
  const [invoiceItems, setInvoiceItems] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSending, setIsSending] = useState(false);
  const [isGeneratingPDF, setIsGeneratingPDF] = useState(false);

  useEffect(() => {
    loadInvoice();
  }, [id]);

  const loadInvoice = async () => {
    setIsLoading(true);
    try {
      // Try to get from store first
      let inv = invoices.find((i) => i.id === id);

      if (!inv && id) {
        // Fetch from database
        inv = await db.getInvoice(id);
      }

      if (inv) {
        setInvoice(inv);
        // Fetch invoice items
        const items = await db.getInvoiceItems(inv.id);
        setInvoiceItems(items || []);
      }
    } catch (error) {
      console.error("Error loading invoice:", error);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      </SafeAreaView>
    );
  }

  if (!invoice) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
        <View style={styles.emptyContainer}>
          <Text style={[typography.body, { color: colors.textSecondary }]}>
            Invoice not found
          </Text>
          <Button title="Go Back" variant="secondary" onPress={() => router.back()} />
        </View>
      </SafeAreaView>
    );
  }

  const statusColors = getStatusColor(invoice.status, colors);

  const handleSendInvoice = () => {
    if (Platform.OS === "ios") {
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: ["Cancel", "Send via SMS", "Send via WhatsApp", "Send via Email", "Share..."],
          cancelButtonIndex: 0,
          title: "How would you like to send this invoice?",
        },
        async (buttonIndex) => {
          if (buttonIndex === 0) return;

          const shareMethod = ["", "sms", "whatsapp", "email", "native"][buttonIndex] as any;
          await performSendInvoice(shareMethod);
        }
      );
    } else {
      // Android - show custom modal or direct share
      Alert.alert(
        "Send Invoice",
        "How would you like to send this invoice?",
        [
          { text: "Cancel", style: "cancel" },
          { text: "SMS", onPress: () => performSendInvoice("sms") },
          { text: "WhatsApp", onPress: () => performSendInvoice("whatsapp") },
          { text: "Email", onPress: () => performSendInvoice("email") },
          { text: "Share...", onPress: () => performSendInvoice("native") },
        ]
      );
    }
  };

  const performSendInvoice = async (shareMethod: "sms" | "whatsapp" | "email" | "native") => {
    setIsSending(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

    try {
      const result = await sendInvoice(invoice, {
        includePaymentLink: true,
        shareMethod,
      });

      if (result.success) {
        // Update invoice status to 'sent' if it was draft
        if (invoice.status === "draft") {
          await updateInvoice(invoice.id, { status: "sent" });
          setInvoice({ ...invoice, status: "sent" });
        }

        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      } else {
        Alert.alert("Error", result.error || "Failed to send invoice");
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      }
    } catch (error: any) {
      console.error("Error sending invoice:", error);
      Alert.alert("Error", error.message || "Failed to send invoice");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } finally {
      setIsSending(false);
    }
  };

  const handleMarkAsPaid = () => {
    Alert.alert(
      "Mark as Paid",
      "Are you sure you want to mark this invoice as paid?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Mark Paid",
          onPress: async () => {
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
            await updateInvoice(invoice.id, {
              status: "paid",
              paid_at: new Date().toISOString(),
            });
            setInvoice({ ...invoice, status: "paid", paid_at: new Date().toISOString() });
          },
        },
      ]
    );
  };

  const handleViewPDF = async () => {
    setIsGeneratingPDF(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    try {
      const result = await generateInvoicePDF(invoice.id);
      if (result?.pdfUrl) {
        await Linking.openURL(result.pdfUrl);
      } else {
        Alert.alert("Error", "Failed to generate PDF");
      }
    } catch (error) {
      console.error("Error generating PDF:", error);
      Alert.alert("Error", "Failed to generate PDF");
    } finally {
      setIsGeneratingPDF(false);
    }
  };

  const handleViewPaymentLink = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    try {
      if (invoice.stripe_hosted_invoice_url) {
        await Linking.openURL(invoice.stripe_hosted_invoice_url);
      } else {
        const result = await getPaymentLink(invoice.id);
        if (result?.url) {
          await Linking.openURL(result.url);
        }
      }
    } catch (error) {
      console.error("Error opening payment link:", error);
      Alert.alert("Error", "Failed to open payment link");
    }
  };

  const handleMoreOptions = () => {
    if (Platform.OS === "ios") {
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: ["Cancel", "View PDF", "Copy Payment Link", "Void Invoice"],
          cancelButtonIndex: 0,
          destructiveButtonIndex: 3,
        },
        async (buttonIndex) => {
          switch (buttonIndex) {
            case 1:
              await handleViewPDF();
              break;
            case 2:
              // Copy payment link
              break;
            case 3:
              handleVoidInvoice();
              break;
          }
        }
      );
    }
  };

  const handleVoidInvoice = () => {
    Alert.alert(
      "Void Invoice",
      "Are you sure you want to void this invoice? This action cannot be undone.",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Void Invoice",
          style: "destructive",
          onPress: async () => {
            await updateInvoice(invoice.id, { status: "void" });
            setInvoice({ ...invoice, status: "void" });
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          },
        },
      ]
    );
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  };

  const getStatusIcon = () => {
    switch (invoice.status) {
      case "paid":
        return <CheckCircle size={20} color={statusColors.text} />;
      case "overdue":
        return <AlertCircle size={20} color={statusColors.text} />;
      default:
        return <Clock size={20} color={statusColors.text} />;
    }
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      {/* Header */}
      <View style={[styles.header, { borderBottomColor: colors.border }]}>
        <Pressable onPress={() => router.back()} style={styles.headerButton}>
          <ArrowLeft size={24} color={colors.text} />
        </Pressable>
        <Text style={[typography.headline, { color: colors.text }]}>
          {invoice.invoice_number}
        </Text>
        <Pressable onPress={handleMoreOptions} style={styles.headerButton}>
          <MoreHorizontal size={24} color={colors.text} />
        </Pressable>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {/* Client Info & Status */}
        <View style={styles.clientSection}>
          <View
            style={[
              styles.avatar,
              { backgroundColor: colors.primary + "20" },
            ]}
          >
            <Text style={[typography.title2, { color: colors.primary }]}>
              {invoice.client_name?.charAt(0).toUpperCase() || "?"}
            </Text>
          </View>
          <Text style={[typography.title1, { color: colors.text, marginTop: spacing.md }]}>
            {invoice.client_name}
          </Text>
          <View
            style={[
              styles.statusBadge,
              { backgroundColor: statusColors.background, marginTop: spacing.sm },
            ]}
          >
            {getStatusIcon()}
            <Text
              style={[
                typography.footnote,
                { color: statusColors.text, fontWeight: "600", marginLeft: 6 },
              ]}
            >
              {invoice.status.toUpperCase()}
            </Text>
          </View>
        </View>

        {/* Dates */}
        <View style={styles.datesRow}>
          <View style={styles.dateItem}>
            <Text style={[typography.caption1, { color: colors.textTertiary }]}>
              Created
            </Text>
            <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
              {formatDate(invoice.created_at)}
            </Text>
          </View>
          {invoice.due_date && (
            <View style={[styles.dateItem, { alignItems: "flex-end" }]}>
              <Text style={[typography.caption1, { color: colors.textTertiary }]}>
                Due Date
              </Text>
              <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
                {formatDate(invoice.due_date)}
              </Text>
            </View>
          )}
        </View>

        {/* Line Items */}
        <View
          style={[
            styles.itemsCard,
            { backgroundColor: colors.card, borderRadius: radius.lg, ...shadows.default },
          ]}
        >
          <Text
            style={[
              typography.footnote,
              { color: colors.textTertiary, fontWeight: "500", marginBottom: spacing.md },
            ]}
          >
            Items
          </Text>
          {invoiceItems.map((item, index) => (
            <View
              key={item.id || index}
              style={[
                styles.itemRow,
                index < invoiceItems.length - 1 && {
                  borderBottomWidth: 1,
                  borderBottomColor: colors.border,
                },
              ]}
            >
              <View style={styles.itemContent}>
                <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
                  {item.description}
                </Text>
                <Text style={[typography.caption1, { color: colors.textTertiary }]}>
                  Qty: {item.quantity}  {formatCurrency(item.unit_price, invoice.currency)}
                </Text>
              </View>
              <Text style={[typography.body, { color: colors.text, fontWeight: "600" }]}>
                {formatCurrency(item.total, invoice.currency)}
              </Text>
            </View>
          ))}
        </View>

        {/* Totals */}
        <View
          style={[
            styles.totalsCard,
            { backgroundColor: colors.backgroundSecondary, borderRadius: radius.lg },
          ]}
        >
          <View style={styles.totalRow}>
            <Text style={[typography.body, { color: colors.textSecondary }]}>Subtotal</Text>
            <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
              {formatCurrency(invoice.subtotal, invoice.currency)}
            </Text>
          </View>
          {invoice.tax_amount > 0 && (
            <View style={styles.totalRow}>
              <Text style={[typography.body, { color: colors.textSecondary }]}>
                Tax ({profile?.tax_rate || 0}%)
              </Text>
              <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
                {formatCurrency(invoice.tax_amount, invoice.currency)}
              </Text>
            </View>
          )}
          <View style={[styles.totalRow, styles.grandTotal, { borderTopColor: colors.border }]}>
            <Text style={[typography.headline, { color: colors.text }]}>Total</Text>
            <Text style={[typography.title2, { color: colors.primary }]}>
              {formatCurrency(invoice.total, invoice.currency)}
            </Text>
          </View>
        </View>

        {/* Payment Link Card (if available) */}
        {invoice.stripe_hosted_invoice_url && invoice.status !== "paid" && (
          <Pressable
            onPress={handleViewPaymentLink}
            style={[
              styles.paymentLinkCard,
              { backgroundColor: colors.primary + "10", borderRadius: radius.md },
            ]}
          >
            <CreditCard size={20} color={colors.primary} />
            <View style={{ flex: 1, marginLeft: spacing.sm }}>
              <Text style={[typography.footnote, { color: colors.primary, fontWeight: "600" }]}>
                Payment Link Ready
              </Text>
              <Text style={[typography.caption1, { color: colors.textSecondary }]}>
                Tap to view or share with client
              </Text>
            </View>
            <ExternalLink size={18} color={colors.primary} />
          </Pressable>
        )}

        {/* From (Business Info) */}
        {profile?.business_name && (
          <View style={[styles.fromSection, { borderTopColor: colors.border }]}>
            <Text style={[typography.caption1, { color: colors.textTertiary, marginBottom: 4 }]}>
              From
            </Text>
            <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
              {profile.business_name}
            </Text>
          </View>
        )}
      </ScrollView>

      {/* Bottom Actions */}
      <View style={[styles.bottomActions, { borderTopColor: colors.border }]}>
        {invoice.status === "draft" && (
          <Button
            title={isSending ? "Sending..." : "Send Invoice"}
            onPress={handleSendInvoice}
            disabled={isSending}
          />
        )}

        {invoice.status === "sent" && (
          <View style={styles.actionRow}>
            <Pressable
              onPress={handleSendInvoice}
              style={[styles.secondaryAction, { backgroundColor: colors.backgroundSecondary }]}
            >
              <Share2 size={20} color={colors.text} />
              <Text style={[typography.footnote, { color: colors.text, marginLeft: 6 }]}>
                Resend
              </Text>
            </Pressable>
            <View style={{ flex: 1, marginLeft: spacing.sm }}>
              <Button title="Mark as Paid" onPress={handleMarkAsPaid} />
            </View>
          </View>
        )}

        {invoice.status === "overdue" && (
          <View style={styles.actionRow}>
            <Pressable
              onPress={handleSendInvoice}
              style={[styles.secondaryAction, { backgroundColor: colors.statusOverdue + "20" }]}
            >
              <MessageSquare size={20} color={colors.statusOverdue} />
              <Text style={[typography.footnote, { color: colors.statusOverdue, marginLeft: 6 }]}>
                Remind
              </Text>
            </Pressable>
            <View style={{ flex: 1, marginLeft: spacing.sm }}>
              <Button title="Mark as Paid" onPress={handleMarkAsPaid} />
            </View>
          </View>
        )}

        {invoice.status === "paid" && (
          <View style={[styles.paidBanner, { backgroundColor: colors.statusPaid + "15" }]}>
            <CheckCircle size={20} color={colors.statusPaid} />
            <Text style={[typography.body, { color: colors.statusPaid, marginLeft: spacing.sm }]}>
              Paid on {invoice.paid_at ? formatDate(invoice.paid_at) : "N/A"}
            </Text>
          </View>
        )}

        {invoice.status === "void" && (
          <View style={[styles.paidBanner, { backgroundColor: colors.textTertiary + "15" }]}>
            <Text style={[typography.body, { color: colors.textTertiary }]}>
              This invoice has been voided
            </Text>
          </View>
        )}
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    gap: 16,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerButton: {
    padding: 8,
    marginHorizontal: -8,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 24,
    paddingBottom: 40,
  },
  clientSection: {
    alignItems: "center",
    marginBottom: 24,
  },
  avatar: {
    width: 72,
    height: 72,
    borderRadius: 36,
    alignItems: "center",
    justifyContent: "center",
  },
  statusBadge: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  datesRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 24,
  },
  dateItem: {},
  itemsCard: {
    padding: 16,
    marginBottom: 16,
  },
  itemRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    paddingVertical: 12,
  },
  itemContent: {
    flex: 1,
    marginRight: 12,
  },
  totalsCard: {
    padding: 16,
    marginBottom: 16,
  },
  totalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 8,
  },
  grandTotal: {
    borderTopWidth: 1,
    marginTop: 8,
    paddingTop: 16,
  },
  paymentLinkCard: {
    flexDirection: "row",
    alignItems: "center",
    padding: 16,
    marginBottom: 16,
  },
  fromSection: {
    paddingTop: 24,
    borderTopWidth: 1,
    marginTop: 8,
  },
  bottomActions: {
    padding: 24,
    paddingBottom: 32,
    borderTopWidth: 1,
  },
  actionRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  secondaryAction: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 16,
    paddingVertical: 14,
    borderRadius: 12,
  },
  paidBanner: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    padding: 16,
    borderRadius: 12,
  },
});


=================================================================================
FILE: ./app/invoice/preview.tsx
=================================================================================

import React, { useState } from "react";
import {
  View,
  Text,
  ScrollView,
  Alert,
  Pressable,
  TextInput,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useRouter } from "expo-router";
import {
  X,
  Check,
  AlertTriangle,
  Mic,
  Edit3,
  ChevronDown,
  ChevronUp,
  Sparkles,
} from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { useTheme } from "@/lib/theme";
import { Button } from "@/components/ui/Button";
import { useInvoiceStore } from "@/store/useInvoiceStore";
import { useProfileStore } from "@/store/useProfileStore";
import { formatCurrency, toDollars } from "@/types";
import * as db from "@/services/database";

/**
 * Invoice Preview Screen
 * Per design-system.md Section 3
 *
 * Features:
 * - AI confidence score display
 * - Highlight original transcript segments
 * - Editable fields before confirmation
 * - "Looks Wrong? Re-record" option
 */

export default function InvoicePreview() {
  const router = useRouter();
  const { colors, typography, spacing, radius } = useTheme();
  const { pendingInvoice, clearPendingInvoice } = useInvoiceStore();
  const { profile } = useProfileStore();

  const [isEditing, setIsEditing] = useState(false);
  const [showTranscript, setShowTranscript] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Editable fields
  const [clientName, setClientName] = useState(pendingInvoice?.clientName || "");
  const [items, setItems] = useState(pendingInvoice?.items || []);

  if (!pendingInvoice) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
        <View style={styles.emptyContainer}>
          <Text style={[typography.body, { color: colors.textSecondary }]}>
            No invoice data
          </Text>
          <Button
            title="Go Back"
            variant="secondary"
            onPress={() => router.back()}
          />
        </View>
      </SafeAreaView>
    );
  }

  const confidence = pendingInvoice.confidence || 0.85;
  const confidencePercent = Math.round(confidence * 100);
  const isLowConfidence = confidence < 0.7;

  // Calculate totals (amounts in cents)
  const subtotal = items.reduce(
    (sum, item) => sum + (item.unitPrice || item.price * 100) * (item.quantity || 1),
    0
  );
  const taxRate = profile?.tax_rate || 0;
  const taxAmount = Math.round(subtotal * (taxRate / 100));
  const total = subtotal + taxAmount;

  const handleConfirm = async () => {
    setIsSaving(true);
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);

    try {
      // Create invoice in database
      const invoiceData = {
        client_name: clientName,
        subtotal,
        tax_amount: taxAmount,
        total,
        currency: profile?.default_currency || "USD",
        status: "draft" as const,
        notes: pendingInvoice.notes,
      };

      const newInvoice = await db.createInvoice(invoiceData);

      if (newInvoice) {
        // Create invoice items
        for (const item of items) {
          await db.createInvoiceItem({
            invoice_id: newInvoice.id,
            description: item.description,
            quantity: item.quantity || 1,
            unit_price: item.unitPrice || item.price * 100,
            total: (item.unitPrice || item.price * 100) * (item.quantity || 1),
            original_transcript_segment: item.originalTranscript,
          });
        }

        clearPendingInvoice();

        Alert.alert(
          "Invoice Created",
          `Invoice ${newInvoice.invoice_number} has been created.`,
          [{ text: "OK", onPress: () => router.replace("/(tabs)/invoices") }]
        );
      }
    } catch (error) {
      console.error("Error creating invoice:", error);
      Alert.alert("Error", "Failed to create invoice. Please try again.");
    } finally {
      setIsSaving(false);
    }
  };

  const handleCancel = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    clearPendingInvoice();
    router.back();
  };

  const handleReRecord = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    clearPendingInvoice();
    router.replace("/(tabs)");
  };

  const updateItemQuantity = (index: number, quantity: number) => {
    const newItems = [...items];
    newItems[index] = { ...newItems[index], quantity: Math.max(1, quantity) };
    setItems(newItems);
  };

  const updateItemPrice = (index: number, price: number) => {
    const newItems = [...items];
    newItems[index] = { ...newItems[index], unitPrice: price, price: price / 100 };
    setItems(newItems);
  };

  const updateItemDescription = (index: number, description: string) => {
    const newItems = [...items];
    newItems[index] = { ...newItems[index], description };
    setItems(newItems);
  };

  const getConfidenceColor = () => {
    if (confidence >= 0.9) return colors.statusPaid;
    if (confidence >= 0.7) return colors.alert;
    return colors.statusOverdue;
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={{ flex: 1 }}
      >
        {/* Header */}
        <View style={[styles.header, { borderBottomColor: colors.border }]}>
          <Pressable onPress={handleCancel} style={styles.headerButton}>
            <X size={24} color={colors.text} />
          </Pressable>
          <Text style={[typography.headline, { color: colors.text }]}>
            Invoice Preview
          </Text>
          <Pressable
            onPress={() => setIsEditing(!isEditing)}
            style={styles.headerButton}
          >
            <Edit3 size={22} color={isEditing ? colors.primary : colors.text} />
          </Pressable>
        </View>

        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
        >
          {/* AI Confidence Banner */}
          <View
            style={[
              styles.confidenceBanner,
              {
                backgroundColor: getConfidenceColor() + "15",
                borderRadius: radius.md,
              },
            ]}
          >
            <View style={styles.confidenceHeader}>
              <Sparkles size={18} color={getConfidenceColor()} />
              <Text
                style={[
                  typography.footnote,
                  { color: getConfidenceColor(), fontWeight: "600", marginLeft: spacing.xs },
                ]}
              >
                AI Confidence: {confidencePercent}%
              </Text>
            </View>
            {isLowConfidence && (
              <View style={styles.warningRow}>
                <AlertTriangle size={14} color={colors.statusOverdue} />
                <Text
                  style={[
                    typography.caption1,
                    { color: colors.statusOverdue, marginLeft: spacing.xs },
                  ]}
                >
                  Low confidence - please review carefully
                </Text>
              </View>
            )}
          </View>

          {/* Original Transcript Toggle */}
          {pendingInvoice.originalTranscript && (
            <Pressable
              onPress={() => setShowTranscript(!showTranscript)}
              style={[
                styles.transcriptToggle,
                { backgroundColor: colors.backgroundSecondary, borderRadius: radius.md },
              ]}
            >
              <Mic size={16} color={colors.textTertiary} />
              <Text
                style={[
                  typography.footnote,
                  { color: colors.textSecondary, marginLeft: spacing.xs, flex: 1 },
                ]}
              >
                Original voice recording
              </Text>
              {showTranscript ? (
                <ChevronUp size={18} color={colors.textTertiary} />
              ) : (
                <ChevronDown size={18} color={colors.textTertiary} />
              )}
            </Pressable>
          )}

          {showTranscript && pendingInvoice.originalTranscript && (
            <View
              style={[
                styles.transcriptBox,
                { backgroundColor: colors.backgroundTertiary, borderRadius: radius.md },
              ]}
            >
              <Text
                style={[
                  typography.footnote,
                  { color: colors.textSecondary, fontStyle: "italic", lineHeight: 20 },
                ]}
              >
                "{pendingInvoice.originalTranscript}"
              </Text>
              <Text
                style={[
                  typography.caption2,
                  { color: colors.textTertiary, marginTop: spacing.sm },
                ]}
              >
                Detected: {pendingInvoice.detectedLanguage || "English"}
              </Text>
            </View>
          )}

          {/* Bill To */}
          <View style={styles.section}>
            <Text style={[typography.footnote, { color: colors.textTertiary }]}>
              Bill To
            </Text>
            {isEditing ? (
              <TextInput
                style={[
                  styles.editableInput,
                  typography.title2,
                  {
                    color: colors.text,
                    backgroundColor: colors.backgroundSecondary,
                    borderRadius: radius.sm,
                  },
                ]}
                value={clientName}
                onChangeText={setClientName}
                placeholder="Client name"
                placeholderTextColor={colors.textTertiary}
              />
            ) : (
              <Text style={[typography.title2, { color: colors.text }]}>
                {clientName}
              </Text>
            )}
          </View>

          {/* Line Items */}
          <View
            style={[
              styles.itemsCard,
              { backgroundColor: colors.card, borderRadius: radius.lg },
            ]}
          >
            <Text
              style={[
                typography.footnote,
                { color: colors.textTertiary, fontWeight: "500", marginBottom: spacing.md },
              ]}
            >
              Items
            </Text>
            {items.map((item, index) => (
              <View
                key={index}
                style={[
                  styles.itemRow,
                  index < items.length - 1 && {
                    borderBottomWidth: 1,
                    borderBottomColor: colors.border,
                  },
                ]}
              >
                <View style={styles.itemContent}>
                  {isEditing ? (
                    <TextInput
                      style={[
                        typography.body,
                        { color: colors.text, fontWeight: "500", padding: 0 },
                      ]}
                      value={item.description}
                      onChangeText={(text) => updateItemDescription(index, text)}
                      multiline
                    />
                  ) : (
                    <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
                      {item.description}
                    </Text>
                  )}

                  {/* Original transcript segment highlight */}
                  {item.originalTranscript && (
                    <Text
                      style={[
                        typography.caption2,
                        {
                          color: colors.textTertiary,
                          fontStyle: "italic",
                          marginTop: 2,
                          backgroundColor: colors.primary + "10",
                          paddingHorizontal: 4,
                          borderRadius: 2,
                        },
                      ]}
                    >
                      "{item.originalTranscript}"
                    </Text>
                  )}

                  <View style={styles.itemMeta}>
                    {isEditing ? (
                      <View style={styles.editableRow}>
                        <Text style={[typography.caption1, { color: colors.textTertiary }]}>
                          Qty:{" "}
                        </Text>
                        <TextInput
                          style={[
                            typography.caption1,
                            styles.smallInput,
                            {
                              color: colors.text,
                              backgroundColor: colors.backgroundSecondary,
                              borderRadius: 4,
                            },
                          ]}
                          value={String(item.quantity || 1)}
                          onChangeText={(text) =>
                            updateItemQuantity(index, parseInt(text) || 1)
                          }
                          keyboardType="numeric"
                        />
                        <Text
                          style={[
                            typography.caption1,
                            { color: colors.textTertiary, marginLeft: spacing.sm },
                          ]}
                        >
                          @ $
                        </Text>
                        <TextInput
                          style={[
                            typography.caption1,
                            styles.smallInput,
                            {
                              color: colors.text,
                              backgroundColor: colors.backgroundSecondary,
                              borderRadius: 4,
                            },
                          ]}
                          value={String((item.unitPrice || item.price * 100) / 100)}
                          onChangeText={(text) =>
                            updateItemPrice(index, parseFloat(text) * 100 || 0)
                          }
                          keyboardType="decimal-pad"
                        />
                      </View>
                    ) : (
                      <Text style={[typography.caption1, { color: colors.textTertiary }]}>
                        Qty: {item.quantity || 1}
                      </Text>
                    )}
                  </View>
                </View>
                <Text style={[typography.body, { color: colors.text, fontWeight: "600" }]}>
                  {formatCurrency(
                    (item.unitPrice || item.price * 100) * (item.quantity || 1),
                    profile?.default_currency || "USD"
                  )}
                </Text>
              </View>
            ))}
          </View>

          {/* Totals */}
          <View
            style={[
              styles.totalsCard,
              { backgroundColor: colors.backgroundSecondary, borderRadius: radius.lg },
            ]}
          >
            <View style={styles.totalRow}>
              <Text style={[typography.body, { color: colors.textSecondary }]}>
                Subtotal
              </Text>
              <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
                {formatCurrency(subtotal, profile?.default_currency || "USD")}
              </Text>
            </View>
            {taxRate > 0 && (
              <View style={styles.totalRow}>
                <Text style={[typography.body, { color: colors.textSecondary }]}>
                  Tax ({taxRate}%)
                </Text>
                <Text style={[typography.body, { color: colors.text, fontWeight: "500" }]}>
                  {formatCurrency(taxAmount, profile?.default_currency || "USD")}
                </Text>
              </View>
            )}
            <View
              style={[
                styles.totalRow,
                styles.grandTotal,
                { borderTopColor: colors.border },
              ]}
            >
              <Text style={[typography.headline, { color: colors.text }]}>Total</Text>
              <Text style={[typography.title2, { color: colors.primary }]}>
                {formatCurrency(total, profile?.default_currency || "USD")}
              </Text>
            </View>
          </View>

          {/* Re-record Option */}
          <Pressable onPress={handleReRecord} style={styles.reRecordButton}>
            <AlertTriangle size={16} color={colors.textTertiary} />
            <Text
              style={[
                typography.footnote,
                { color: colors.textTertiary, marginLeft: spacing.xs },
              ]}
            >
              Looks wrong? Re-record
            </Text>
          </Pressable>
        </ScrollView>

        {/* Bottom Action */}
        <View style={[styles.bottomAction, { borderTopColor: colors.border }]}>
          <Button
            title={isSaving ? "Creating..." : "Create Invoice"}
            onPress={handleConfirm}
            disabled={isSaving || !clientName.trim() || items.length === 0}
          />
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    gap: 16,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerButton: {
    padding: 8,
    marginHorizontal: -8,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 24,
    paddingBottom: 40,
  },
  confidenceBanner: {
    padding: 12,
    marginBottom: 16,
  },
  confidenceHeader: {
    flexDirection: "row",
    alignItems: "center",
  },
  warningRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 8,
  },
  transcriptToggle: {
    flexDirection: "row",
    alignItems: "center",
    padding: 12,
    marginBottom: 8,
  },
  transcriptBox: {
    padding: 12,
    marginBottom: 16,
  },
  section: {
    marginBottom: 24,
  },
  editableInput: {
    padding: 8,
    marginTop: 4,
  },
  itemsCard: {
    padding: 16,
    marginBottom: 16,
  },
  itemRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    paddingVertical: 12,
  },
  itemContent: {
    flex: 1,
    marginRight: 12,
  },
  itemMeta: {
    marginTop: 4,
  },
  editableRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  smallInput: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    minWidth: 40,
    textAlign: "center",
  },
  totalsCard: {
    padding: 16,
    marginBottom: 24,
  },
  totalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 8,
  },
  grandTotal: {
    borderTopWidth: 1,
    marginTop: 8,
    paddingTop: 16,
  },
  reRecordButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    padding: 12,
  },
  bottomAction: {
    padding: 24,
    paddingBottom: 32,
    borderTopWidth: 1,
  },
});


=================================================================================
FILE: ./app/stripe/onboarding.tsx
=================================================================================

import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  Pressable,
  Linking,
} from "react-native";
import { router } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { ChevronLeft, ExternalLink, CheckCircle, AlertCircle } from "lucide-react-native";
import * as Haptics from "expo-haptics";
import * as WebBrowser from "expo-web-browser";
import { useTheme } from "@/lib/theme";
import { Button } from "@/components/ui/Button";
import * as stripeService from "@/services/stripe";
import { StripeAccountStatus } from "@/types";

export default function StripeOnboardingScreen() {
  const { colors, typography, spacing, radius } = useTheme();

  const [status, setStatus] = useState<StripeAccountStatus | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    loadStatus();
  }, []);

  const loadStatus = async () => {
    setIsLoading(true);
    try {
      const accountStatus = await stripeService.getStripeAccountStatus();
      setStatus(accountStatus);
    } catch (err) {
      console.error("Error loading status:", err);
    } finally {
      setIsLoading(false);
    }
  };

  const handleConnectStripe = async () => {
    setIsConnecting(true);
    setError(null);

    try {
      const result = await stripeService.getConnectOnboardingUrl();

      if (result?.url) {
        // Open Stripe onboarding in browser
        await WebBrowser.openBrowserAsync(result.url);

        // Refresh status after returning
        await loadStatus();
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      }
    } catch (err: any) {
      setError(err.message || "Failed to start Stripe onboarding");
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } finally {
      setIsConnecting(false);
    }
  };

  const renderStatus = () => {
    if (!status) return null;

    if (status.chargesEnabled && status.payoutsEnabled) {
      return (
        <View
          style={[
            styles.statusCard,
            { backgroundColor: colors.success + "15", borderRadius: radius.lg },
          ]}
        >
          <CheckCircle size={24} color={colors.success} />
          <View style={styles.statusContent}>
            <Text style={[typography.headline, { color: colors.text }]}>
              Payments Enabled
            </Text>
            <Text style={[typography.footnote, { color: colors.textSecondary }]}>
              You can accept payments and receive payouts
            </Text>
          </View>
        </View>
      );
    }

    if (status.isConnected) {
      return (
        <View
          style={[
            styles.statusCard,
            { backgroundColor: colors.alert + "15", borderRadius: radius.lg },
          ]}
        >
          <AlertCircle size={24} color={colors.alert} />
          <View style={styles.statusContent}>
            <Text style={[typography.headline, { color: colors.text }]}>
              Setup Incomplete
            </Text>
            <Text style={[typography.footnote, { color: colors.textSecondary }]}>
              Complete your Stripe setup to accept payments
            </Text>
          </View>
        </View>
      );
    }

    return null;
  };

  if (isLoading) {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      {/* Header */}
      <View style={styles.header}>
        <Pressable style={styles.backButton} onPress={() => router.back()}>
          <ChevronLeft size={24} color={colors.text} />
        </Pressable>
        <Text style={[typography.title2, { color: colors.text }]}>
          Payment Setup
        </Text>
        <View style={{ width: 40 }} />
      </View>

      <View style={styles.content}>
        {/* Status Card */}
        {renderStatus()}

        {/* Info */}
        <View style={styles.infoSection}>
          <Text style={[typography.title3, { color: colors.text, marginBottom: spacing.sm }]}>
            Accept Payments with Stripe
          </Text>
          <Text style={[typography.body, { color: colors.textSecondary, lineHeight: 24 }]}>
            Connect your Stripe account to accept credit card payments directly from your invoices.
            Funds are deposited directly into your bank account.
          </Text>
        </View>

        {/* Features */}
        <View style={styles.features}>
          {[
            "Accept all major credit cards",
            "Funds deposited in 2 business days",
            "Secure payment processing",
            "Automatic tax documentation",
          ].map((feature, index) => (
            <View key={index} style={styles.featureRow}>
              <CheckCircle size={20} color={colors.primary} />
              <Text style={[typography.body, { color: colors.text, marginLeft: spacing.sm }]}>
                {feature}
              </Text>
            </View>
          ))}
        </View>

        {/* Error */}
        {error && (
          <View
            style={[
              styles.errorContainer,
              { backgroundColor: colors.error + "15", borderRadius: radius.md },
            ]}
          >
            <Text style={[typography.footnote, { color: colors.error }]}>
              {error}
            </Text>
          </View>
        )}

        {/* Connect Button */}
        <View style={styles.buttonContainer}>
          {status?.chargesEnabled && status?.payoutsEnabled ? (
            <Button
              title="View Stripe Dashboard"
              onPress={() => Linking.openURL("https://dashboard.stripe.com")}
              variant="secondary"
            />
          ) : (
            <Button
              title={
                isConnecting
                  ? "Opening Stripe..."
                  : status?.isConnected
                  ? "Complete Setup"
                  : "Connect Stripe Account"
              }
              onPress={handleConnectStripe}
              disabled={isConnecting}
            />
          )}
        </View>

        {/* Stripe branding */}
        <View style={styles.stripeInfo}>
          <Text style={[typography.caption1, { color: colors.textTertiary, textAlign: "center" }]}>
            Powered by Stripe. By connecting, you agree to Stripe's Terms of Service.
          </Text>
        </View>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  backButton: {
    width: 40,
    height: 40,
    justifyContent: "center",
    alignItems: "center",
  },
  content: {
    flex: 1,
    padding: 24,
  },
  statusCard: {
    flexDirection: "row",
    alignItems: "center",
    padding: 16,
    marginBottom: 24,
  },
  statusContent: {
    marginLeft: 12,
    flex: 1,
  },
  infoSection: {
    marginBottom: 24,
  },
  features: {
    marginBottom: 24,
    gap: 12,
  },
  featureRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  errorContainer: {
    padding: 12,
    marginBottom: 16,
  },
  buttonContainer: {
    marginTop: "auto",
  },
  stripeInfo: {
    marginTop: 16,
    paddingHorizontal: 24,
  },
});


=================================================================================
FILE: ./babel.config.js
=================================================================================

module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
    plugins: [
      [
        "module-resolver",
        {
          root: ["./"],
          alias: {
            "@": "./",
          },
        },
      ],
    ],
  };
};


=================================================================================
FILE: ./components/AnimatedNumber.tsx
=================================================================================

import React, { useEffect, useRef } from "react";
import { Text, TextStyle, Animated, StyleSheet, View } from "react-native";

/**
 * AnimatedNumber Component
 * Per design-system.md "Pulse UI"
 * Rolling number animation with smooth transitions
 */

interface AnimatedNumberProps {
  value: number;
  prefix?: string;
  suffix?: string;
  style?: TextStyle;
  duration?: number;
  formatOptions?: Intl.NumberFormatOptions;
}

export function AnimatedNumber({
  value,
  prefix = "",
  suffix = "",
  style,
  duration = 800,
  formatOptions = {},
}: AnimatedNumberProps) {
  const animatedValue = useRef(new Animated.Value(0)).current;
  const previousValue = useRef(0);

  useEffect(() => {
    // Animate from previous value to new value
    animatedValue.setValue(previousValue.current);

    Animated.timing(animatedValue, {
      toValue: value,
      duration,
      useNativeDriver: false, // Can't use native driver for text value changes
    }).start();

    previousValue.current = value;
  }, [value, duration]);

  const displayValue = animatedValue.interpolate({
    inputRange: [0, value || 1],
    outputRange: [0, value || 0],
  });

  return (
    <AnimatedText
      animatedValue={displayValue}
      prefix={prefix}
      suffix={suffix}
      style={style}
      formatOptions={formatOptions}
    />
  );
}

// Separate component to handle the animated value rendering
interface AnimatedTextProps {
  animatedValue: Animated.AnimatedInterpolation<number>;
  prefix: string;
  suffix: string;
  style?: TextStyle;
  formatOptions: Intl.NumberFormatOptions;
}

class AnimatedText extends React.Component<AnimatedTextProps> {
  private listener: string | null = null;
  private textRef = React.createRef<Text>();
  private currentValue: number = 0;

  componentDidMount() {
    this.listener = this.props.animatedValue.addListener(({ value }) => {
      this.currentValue = value;
      if (this.textRef.current) {
        const formatted = this.formatNumber(value);
        this.textRef.current.setNativeProps({
          text: `${this.props.prefix}${formatted}${this.props.suffix}`,
        });
      }
    });
  }

  componentWillUnmount() {
    if (this.listener) {
      this.props.animatedValue.removeListener(this.listener);
    }
  }

  formatNumber(value: number): string {
    const { formatOptions } = this.props;

    // Default formatting for currency-like display
    if (formatOptions.style === "currency") {
      return new Intl.NumberFormat("en-US", {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
        ...formatOptions,
      }).format(value);
    }

    return new Intl.NumberFormat("en-US", formatOptions).format(Math.round(value));
  }

  render() {
    const { prefix, suffix, style } = this.props;
    const formatted = this.formatNumber(this.currentValue);

    return (
      <Text ref={this.textRef} style={style}>
        {`${prefix}${formatted}${suffix}`}
      </Text>
    );
  }
}

/**
 * AnimatedCurrency Component
 * Convenience wrapper for currency values (stored in cents)
 */
interface AnimatedCurrencyProps {
  cents: number;
  currency?: string;
  style?: TextStyle;
  duration?: number;
}

export function AnimatedCurrency({
  cents,
  currency = "USD",
  style,
  duration = 800,
}: AnimatedCurrencyProps) {
  const dollars = cents / 100;
  const animatedValue = useRef(new Animated.Value(0)).current;
  const previousValue = useRef(0);
  const [displayText, setDisplayText] = React.useState("");

  useEffect(() => {
    animatedValue.setValue(previousValue.current);

    const listener = animatedValue.addListener(({ value }) => {
      const formatted = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency,
        minimumFractionDigits: 0,
        maximumFractionDigits: 0,
      }).format(value);
      setDisplayText(formatted);
    });

    Animated.timing(animatedValue, {
      toValue: dollars,
      duration,
      useNativeDriver: false,
    }).start();

    previousValue.current = dollars;

    return () => {
      animatedValue.removeListener(listener);
    };
  }, [dollars, duration, currency]);

  // Initial format
  useEffect(() => {
    const formatted = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(previousValue.current);
    setDisplayText(formatted);
  }, []);

  return <Text style={style}>{displayText}</Text>;
}

/**
 * PulseNumber Component
 * Shows a brief pulse/scale animation when value changes
 */
interface PulseNumberProps {
  value: number;
  prefix?: string;
  suffix?: string;
  style?: TextStyle;
  formatOptions?: Intl.NumberFormatOptions;
}

export function PulseNumber({
  value,
  prefix = "",
  suffix = "",
  style,
  formatOptions = {},
}: PulseNumberProps) {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const previousValue = useRef(value);

  useEffect(() => {
    if (previousValue.current !== value) {
      // Pulse animation
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.05,
          duration: 150,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          friction: 4,
          tension: 40,
          useNativeDriver: true,
        }),
      ]).start();

      previousValue.current = value;
    }
  }, [value]);

  const formatted = new Intl.NumberFormat("en-US", formatOptions).format(value);

  return (
    <Animated.Text style={[style, { transform: [{ scale: scaleAnim }] }]}>
      {`${prefix}${formatted}${suffix}`}
    </Animated.Text>
  );
}


=================================================================================
FILE: ./components/EmptyState.tsx
=================================================================================

import React from "react";
import { View, Text, StyleSheet } from "react-native";
import {
  FileText,
  Users,
  Search,
  CheckCircle,
  Mic,
} from "lucide-react-native";
import { useTheme } from "@/lib/theme";
import { Button } from "@/components/ui/Button";

/**
 * EmptyState Component
 * Per design-system.md Section 3 - Empty State Psychology
 *
 * Types:
 * - firstRun: "Let's Get You Paid" with action
 * - allCaughtUp: Celebration for empty filtered list
 * - noResults: Search returned nothing
 * - noClients: No clients yet
 */

type EmptyStateType = "firstRun" | "allCaughtUp" | "noResults" | "noClients";

interface EmptyStateProps {
  type: EmptyStateType;
  searchQuery?: string;
  onAction?: () => void;
  actionLabel?: string;
}

export function EmptyState({
  type,
  searchQuery,
  onAction,
  actionLabel,
}: EmptyStateProps) {
  const { colors, typography, spacing } = useTheme();

  const configs: Record<
    EmptyStateType,
    {
      icon: React.ReactNode;
      title: string;
      message: string;
      showAction: boolean;
      defaultActionLabel: string;
    }
  > = {
    firstRun: {
      icon: <Mic size={64} color={colors.primary} strokeWidth={1.5} />,
      title: "Let's Get You Paid",
      message:
        "Create your first invoice in seconds. Just tap the microphone and describe the work.",
      showAction: true,
      defaultActionLabel: "Create First Invoice",
    },
    allCaughtUp: {
      icon: <CheckCircle size={64} color={colors.statusPaid} strokeWidth={1.5} />,
      title: "All Caught Up!",
      message: "No overdue invoices. Great job staying on top of your billing.",
      showAction: false,
      defaultActionLabel: "",
    },
    noResults: {
      icon: <Search size={64} color={colors.textTertiary} strokeWidth={1.5} />,
      title: "No Results Found",
      message: searchQuery
        ? `No invoices matching "${searchQuery}"`
        : "Try adjusting your search or filters.",
      showAction: !!searchQuery,
      defaultActionLabel: searchQuery ? `Create Invoice for "${searchQuery}"` : "Clear Search",
    },
    noClients: {
      icon: <Users size={64} color={colors.textTertiary} strokeWidth={1.5} />,
      title: "No Clients Yet",
      message:
        "Your clients will appear here once you create invoices for them.",
      showAction: true,
      defaultActionLabel: "Add First Client",
    },
  };

  const config = configs[type];

  return (
    <View style={styles.container}>
      {/* Illustration/Icon */}
      <View style={styles.iconContainer}>{config.icon}</View>

      {/* Title - Per design-system.md "Human" copywriting */}
      <Text
        style={[
          typography.title2,
          { color: colors.text, textAlign: "center", marginTop: spacing.lg },
        ]}
      >
        {config.title}
      </Text>

      {/* Message */}
      <Text
        style={[
          typography.body,
          {
            color: colors.textSecondary,
            textAlign: "center",
            marginTop: spacing.sm,
            paddingHorizontal: spacing.xl,
            lineHeight: 24,
          },
        ]}
      >
        {config.message}
      </Text>

      {/* Action Button */}
      {config.showAction && onAction && (
        <View style={[styles.buttonContainer, { marginTop: spacing.xl }]}>
          <Button
            title={actionLabel || config.defaultActionLabel}
            onPress={onAction}
          />
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 32,
    paddingVertical: 48,
  },
  iconContainer: {
    opacity: 0.9,
  },
  buttonContainer: {
    width: "100%",
    maxWidth: 280,
  },
});


=================================================================================
FILE: ./components/InvoiceCard.tsx
=================================================================================

import React, { useRef } from "react";
import { View, Text, StyleSheet, Animated, Pressable } from "react-native";
import { Swipeable } from "react-native-gesture-handler";
import { Check, Bell, MoreHorizontal, Trash2 } from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { useTheme, getStatusColor } from "@/lib/theme";
import { Invoice, InvoiceStatus, formatCurrency, formatRelativeDate, toDollars } from "@/types";

/**
 * InvoiceCard Component
 * Per design-system.md "Wallet Pass" paradigm
 *
 * Layout:
 * - Top-left: Client Name (Secondary Field)
 * - Top-right: Status Badge (Capsule)
 * - Bottom-left: Invoice ID + Relative Date (Auxiliary)
 * - Bottom-right: Amount (Primary Field)
 */

interface InvoiceCardProps {
  invoice: Invoice;
  onPress: () => void;
  onMarkPaid?: () => void;
  onRemind?: () => void;
  onMore?: () => void;
  onVoid?: () => void;
}

export function InvoiceCard({
  invoice,
  onPress,
  onMarkPaid,
  onRemind,
  onMore,
  onVoid,
}: InvoiceCardProps) {
  const { colors, typography, spacing, radius, shadows } = useTheme();
  const swipeableRef = useRef<Swipeable>(null);

  const statusColors = getStatusColor(invoice.status, colors);

  const handlePress = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    onPress();
  };

  // Right swipe action - Mark as Paid (per design-system.md Section 1.4)
  const renderRightAction = (
    progress: Animated.AnimatedInterpolation<number>,
    dragX: Animated.AnimatedInterpolation<number>
  ) => {
    if (invoice.status === "paid" || !onMarkPaid) return null;

    const scale = dragX.interpolate({
      inputRange: [-100, 0],
      outputRange: [1, 0],
      extrapolate: "clamp",
    });

    return (
      <Pressable
        onPress={() => {
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
          swipeableRef.current?.close();
          onMarkPaid();
        }}
        style={[
          styles.swipeAction,
          styles.swipeActionRight,
          { backgroundColor: colors.statusPaid },
        ]}
      >
        <Animated.View style={{ transform: [{ scale }] }}>
          <Check size={24} color="#FFFFFF" strokeWidth={3} />
        </Animated.View>
        <Text style={styles.swipeActionText}>Paid</Text>
      </Pressable>
    );
  };

  // Left swipe actions - More, Remind, Void (per design-system.md Section 1.4)
  const renderLeftActions = (
    progress: Animated.AnimatedInterpolation<number>,
    dragX: Animated.AnimatedInterpolation<number>
  ) => {
    const scale = dragX.interpolate({
      inputRange: [0, 100],
      outputRange: [0, 1],
      extrapolate: "clamp",
    });

    return (
      <View style={styles.leftActionsContainer}>
        {onMore && (
          <Pressable
            onPress={() => {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
              swipeableRef.current?.close();
              onMore();
            }}
            style={[styles.swipeAction, { backgroundColor: colors.textTertiary }]}
          >
            <Animated.View style={{ transform: [{ scale }] }}>
              <MoreHorizontal size={20} color="#FFFFFF" />
            </Animated.View>
            <Text style={styles.swipeActionText}>More</Text>
          </Pressable>
        )}
        {onRemind && invoice.status !== "paid" && (
          <Pressable
            onPress={() => {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
              swipeableRef.current?.close();
              onRemind();
            }}
            style={[styles.swipeAction, { backgroundColor: colors.statusOverdue }]}
          >
            <Animated.View style={{ transform: [{ scale }] }}>
              <Bell size={20} color="#FFFFFF" />
            </Animated.View>
            <Text style={styles.swipeActionText}>Remind</Text>
          </Pressable>
        )}
        {onVoid && invoice.status !== "paid" && (
          <Pressable
            onPress={() => {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
              swipeableRef.current?.close();
              onVoid();
            }}
            style={[styles.swipeAction, { backgroundColor: colors.error }]}
          >
            <Animated.View style={{ transform: [{ scale }] }}>
              <Trash2 size={20} color="#FFFFFF" />
            </Animated.View>
            <Text style={styles.swipeActionText}>Void</Text>
          </Pressable>
        )}
      </View>
    );
  };

  // Format amount for display
  const formattedAmount = formatCurrency(invoice.total, invoice.currency);

  // Format relative date
  const relativeDate = invoice.due_date
    ? formatRelativeDate(invoice.due_date)
    : formatRelativeDate(invoice.created_at);

  const statusLabels: Record<InvoiceStatus, string> = {
    draft: "DRAFT",
    sent: "SENT",
    paid: "PAID",
    overdue: "OVERDUE",
    void: "VOID",
  };

  return (
    <Swipeable
      ref={swipeableRef}
      renderRightActions={renderRightAction}
      renderLeftActions={renderLeftActions}
      friction={2}
      overshootRight={false}
      overshootLeft={false}
    >
      <Pressable
        onPress={handlePress}
        style={({ pressed }) => [
          styles.card,
          {
            backgroundColor: colors.card,
            borderRadius: radius.md, // 12pt per design-system.md
            ...shadows.default,
            transform: [{ scale: pressed ? 0.98 : 1 }],
          },
        ]}
      >
        {/* Top Row: Client Name + Status Badge */}
        <View style={styles.topRow}>
          {/* Secondary Field: Client Name (top-left) */}
          <Text
            style={[
              typography.headline,
              { color: colors.text, flex: 1 },
            ]}
            numberOfLines={1}
          >
            {invoice.client_name}
          </Text>

          {/* Status Badge (top-right, capsule shape) */}
          <View
            style={[
              styles.statusBadge,
              { backgroundColor: statusColors.background },
            ]}
          >
            <Text
              style={[
                styles.statusText,
                { color: statusColors.text },
              ]}
            >
              {statusLabels[invoice.status]}
            </Text>
          </View>
        </View>

        {/* Bottom Row: Metadata + Amount */}
        <View style={styles.bottomRow}>
          {/* Auxiliary Fields: Invoice ID + Date (bottom-left) */}
          <View style={styles.metadata}>
            <Text style={[typography.footnote, { color: colors.textTertiary }]}>
              {invoice.invoice_number}
            </Text>
            <Text style={[typography.footnote, { color: colors.textTertiary }]}>
              {" "}{" "}
            </Text>
            <Text style={[typography.footnote, { color: colors.textTertiary }]}>
              {relativeDate}
            </Text>
          </View>

          {/* Primary Field: Amount (bottom-right) */}
          <Text
            style={[
              typography.invoiceAmount,
              { color: colors.text },
            ]}
          >
            {formattedAmount}
          </Text>
        </View>
      </Pressable>
    </Swipeable>
  );
}

const styles = StyleSheet.create({
  card: {
    padding: 16,
    marginHorizontal: 16,
    marginVertical: 6,
  },
  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  bottomRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
  },
  metadata: {
    flexDirection: "row",
    alignItems: "center",
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12, // Capsule/Lozenge shape
  },
  statusText: {
    fontSize: 11,
    fontWeight: "700",
    letterSpacing: 0.5,
  },
  leftActionsContainer: {
    flexDirection: "row",
  },
  swipeAction: {
    justifyContent: "center",
    alignItems: "center",
    width: 72,
    paddingVertical: 8,
  },
  swipeActionRight: {
    borderTopRightRadius: 12,
    borderBottomRightRadius: 12,
  },
  swipeActionText: {
    color: "#FFFFFF",
    fontSize: 11,
    fontWeight: "600",
    marginTop: 4,
  },
});


=================================================================================
FILE: ./components/LogoUploader.tsx
=================================================================================

import { View, Text, Image, Pressable } from "react-native";
import { Camera, X } from "lucide-react-native";
import * as ImagePicker from "expo-image-picker";
import * as Haptics from "expo-haptics";
import { COLORS } from "../lib/constants";

interface LogoUploaderProps {
  logoUrl?: string;
  onLogoChange: (uri: string | undefined) => void;
}

export function LogoUploader({ logoUrl, onLogoChange }: LogoUploaderProps) {
  const pickImage = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 0.8,
    });

    if (!result.canceled && result.assets[0]) {
      onLogoChange(result.assets[0].uri);
    }
  };

  const removeLogo = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onLogoChange(undefined);
  };

  if (logoUrl) {
    return (
      <View className="items-center mb-6">
        <View className="relative">
          <Image
            source={{ uri: logoUrl }}
            className="w-24 h-24 rounded-2xl"
          />
          <Pressable
            onPress={removeLogo}
            className="absolute -top-2 -right-2 w-7 h-7 bg-red-500 rounded-full items-center justify-center"
          >
            <X size={16} color="#FFFFFF" />
          </Pressable>
        </View>
        <Text className="text-gray-500 text-sm mt-2">Business Logo</Text>
      </View>
    );
  }

  return (
    <Pressable onPress={pickImage} className="items-center mb-6">
      <View className="w-24 h-24 rounded-2xl bg-gray-100 items-center justify-center border-2 border-dashed border-gray-300">
        <Camera size={32} color={COLORS.text.light} />
      </View>
      <Text className="text-gray-500 text-sm mt-2">Add Logo</Text>
    </Pressable>
  );
}


=================================================================================
FILE: ./components/MonogramAvatar.tsx
=================================================================================

import { View, Text } from "react-native";
import { COLORS } from "../lib/constants";

interface MonogramAvatarProps {
  name: string;
  size?: "sm" | "md" | "lg";
}

export function MonogramAvatar({ name, size = "md" }: MonogramAvatarProps) {
  const getInitials = (fullName: string): string => {
    const words = fullName.trim().split(" ");
    if (words.length === 1) {
      return words[0].substring(0, 2).toUpperCase();
    }
    return (words[0][0] + words[words.length - 1][0]).toUpperCase();
  };

  const sizeClasses = {
    sm: "w-10 h-10",
    md: "w-14 h-14",
    lg: "w-20 h-20",
  };

  const textSizes = {
    sm: "text-sm",
    md: "text-lg",
    lg: "text-2xl",
  };

  return (
    <View
      className={`${sizeClasses[size]} rounded-full items-center justify-center`}
      style={{ backgroundColor: COLORS.primary }}
    >
      <Text className={`text-white font-bold ${textSizes[size]}`}>
        {getInitials(name || "?")}
      </Text>
    </View>
  );
}


=================================================================================
FILE: ./components/OfflineIndicator.tsx
=================================================================================

import React from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import Animated, {
  useAnimatedStyle,
  withSpring,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from "react-native-reanimated";
import { useTheme } from "@/lib/theme";
import { useOfflineStore } from "@/store/useOfflineStore";

interface OfflineIndicatorProps {
  compact?: boolean;
  showSyncButton?: boolean;
}

export function OfflineIndicator({
  compact = false,
  showSyncButton = true,
}: OfflineIndicatorProps) {
  const { colors } = useTheme();
  const {
    isOnline,
    isSyncing,
    pendingUploads,
    pendingOperations,
    syncNow,
  } = useOfflineStore();

  const pulseAnim = useSharedValue(1);

  // Pulse animation when offline
  React.useEffect(() => {
    if (!isOnline) {
      pulseAnim.value = withRepeat(
        withSequence(
          withTiming(1.1, { duration: 500 }),
          withTiming(1, { duration: 500 })
        ),
        -1,
        true
      );
    } else {
      pulseAnim.value = withSpring(1);
    }
  }, [isOnline]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: pulseAnim.value }],
  }));

  const totalPending = pendingUploads + pendingOperations;

  // Don't show if online and nothing pending
  if (isOnline && totalPending === 0) {
    return null;
  }

  if (compact) {
    return (
      <Animated.View style={[styles.compactContainer, animatedStyle]}>
        <View
          style={[
            styles.compactBadge,
            {
              backgroundColor: isOnline
                ? colors.primary
                : colors.statusOverdue,
            },
          ]}
        >
          <Ionicons
            name={isOnline ? "cloud-upload" : "cloud-offline"}
            size={14}
            color="white"
          />
          {totalPending > 0 && (
            <Text style={styles.compactCount}>{totalPending}</Text>
          )}
        </View>
      </Animated.View>
    );
  }

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: isOnline
            ? colors.background
            : colors.statusOverdue + "15",
          borderColor: isOnline ? colors.border : colors.statusOverdue,
        },
        animatedStyle,
      ]}
    >
      <View style={styles.content}>
        <View style={styles.iconContainer}>
          <Ionicons
            name={isOnline ? "cloud-upload" : "cloud-offline"}
            size={20}
            color={isOnline ? colors.primary : colors.statusOverdue}
          />
        </View>

        <View style={styles.textContainer}>
          <Text
            style={[
              styles.title,
              { color: isOnline ? colors.text : colors.statusOverdue },
            ]}
          >
            {isOnline ? "Syncing..." : "You're Offline"}
          </Text>

          {totalPending > 0 && (
            <Text style={[styles.subtitle, { color: colors.textSecondary }]}>
              {totalPending} item{totalPending !== 1 ? "s" : ""} pending
            </Text>
          )}

          {!isOnline && totalPending === 0 && (
            <Text style={[styles.subtitle, { color: colors.textSecondary }]}>
              Changes will sync when online
            </Text>
          )}
        </View>

        {showSyncButton && isOnline && totalPending > 0 && (
          <TouchableOpacity
            style={[styles.syncButton, { backgroundColor: colors.primary }]}
            onPress={syncNow}
            disabled={isSyncing}
          >
            {isSyncing ? (
              <ActivityIndicator size="small" color="white" />
            ) : (
              <Text style={styles.syncButtonText}>Sync</Text>
            )}
          </TouchableOpacity>
        )}
      </View>
    </Animated.View>
  );
}

/**
 * Simple offline banner for top of screen
 */
export function OfflineBanner() {
  const { colors } = useTheme();
  const { isOnline } = useOfflineStore();

  if (isOnline) {
    return null;
  }

  return (
    <View style={[styles.banner, { backgroundColor: colors.statusOverdue }]}>
      <Ionicons name="cloud-offline" size={16} color="white" />
      <Text style={styles.bannerText}>No Internet Connection</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 12,
    marginHorizontal: 16,
    marginVertical: 8,
  },
  content: {
    flexDirection: "row",
    alignItems: "center",
  },
  iconContainer: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: "rgba(0,0,0,0.05)",
    justifyContent: "center",
    alignItems: "center",
    marginRight: 12,
  },
  textContainer: {
    flex: 1,
  },
  title: {
    fontSize: 15,
    fontWeight: "600",
  },
  subtitle: {
    fontSize: 13,
    marginTop: 2,
  },
  syncButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
    minWidth: 60,
    alignItems: "center",
  },
  syncButtonText: {
    color: "white",
    fontSize: 14,
    fontWeight: "600",
  },
  compactContainer: {},
  compactBadge: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    gap: 4,
  },
  compactCount: {
    color: "white",
    fontSize: 12,
    fontWeight: "600",
  },
  banner: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 8,
    gap: 8,
  },
  bannerText: {
    color: "white",
    fontSize: 14,
    fontWeight: "500",
  },
});


=================================================================================
FILE: ./components/RecordingOverlay.tsx
=================================================================================

import { View, Text, Modal, StyleSheet, Animated } from "react-native";
import { Mic } from "lucide-react-native";
import { useEffect, useRef, useState } from "react";
import { useTheme, typography, spacing, radius } from "../lib/theme";

interface RecordingOverlayProps {
  visible: boolean;
  duration: number;
}

export function RecordingOverlay({ visible, duration }: RecordingOverlayProps) {
  const { colors, isDark } = useTheme();
  const [dots, setDots] = useState("");

  const pulseAnim = useRef(new Animated.Value(1)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.9)).current;

  useEffect(() => {
    if (visible) {
      // Fade in
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          friction: 8,
          tension: 40,
          useNativeDriver: true,
        }),
      ]).start();

      // Pulse animation
      const pulse = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.1,
            duration: 600,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 600,
            useNativeDriver: true,
          }),
        ])
      );
      pulse.start();

      // Dots animation
      const interval = setInterval(() => {
        setDots((prev) => (prev.length >= 3 ? "" : prev + "."));
      }, 500);

      return () => {
        pulse.stop();
        clearInterval(interval);
        fadeAnim.setValue(0);
        scaleAnim.setValue(0.9);
        pulseAnim.setValue(1);
      };
    }
  }, [visible]);

  const formatDuration = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${String(secs).padStart(2, "0")}`;
  };

  const styles = createStyles(colors, isDark);

  return (
    <Modal visible={visible} transparent animationType="none">
      <Animated.View style={[styles.overlay, { opacity: fadeAnim }]}>
        <Animated.View
          style={[
            styles.content,
            {
              transform: [{ scale: scaleAnim }],
            },
          ]}
        >
          <Animated.View
            style={[
              styles.iconContainer,
              {
                transform: [{ scale: pulseAnim }],
              },
            ]}
          >
            <View style={styles.iconInner}>
              <Mic size={36} color="#FFFFFF" strokeWidth={2} />
            </View>
          </Animated.View>

          <Text style={styles.duration}>{formatDuration(duration)}</Text>
          <Text style={styles.status}>Recording{dots}</Text>

          <View style={styles.waveContainer}>
            {[...Array(5)].map((_, i) => (
              <WaveBar key={i} delay={i * 100} colors={colors} />
            ))}
          </View>

          <Text style={styles.hint}>Release to finish</Text>
        </Animated.View>
      </Animated.View>
    </Modal>
  );
}

function WaveBar({ delay, colors }: { delay: number; colors: any }) {
  const heightAnim = useRef(new Animated.Value(0.3)).current;

  useEffect(() => {
    const animation = Animated.loop(
      Animated.sequence([
        Animated.timing(heightAnim, {
          toValue: 1,
          duration: 400,
          delay,
          useNativeDriver: true,
        }),
        Animated.timing(heightAnim, {
          toValue: 0.3,
          duration: 400,
          useNativeDriver: true,
        }),
      ])
    );
    animation.start();
    return () => animation.stop();
  }, []);

  return (
    <Animated.View
      style={{
        width: 4,
        height: 24,
        backgroundColor: colors.primary,
        borderRadius: 2,
        marginHorizontal: 3,
        transform: [{ scaleY: heightAnim }],
      }}
    />
  );
}

const createStyles = (colors: any, isDark: boolean) =>
  StyleSheet.create({
    overlay: {
      flex: 1,
      backgroundColor: isDark ? "rgba(0, 0, 0, 0.9)" : "rgba(0, 0, 0, 0.8)",
      alignItems: "center",
      justifyContent: "center",
    },
    content: {
      backgroundColor: colors.card,
      borderRadius: radius.xxl,
      padding: spacing.xl,
      alignItems: "center",
      marginHorizontal: spacing.xl,
      minWidth: 280,
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 20 },
      shadowOpacity: 0.3,
      shadowRadius: 30,
      elevation: 20,
    },
    iconContainer: {
      marginBottom: spacing.lg,
    },
    iconInner: {
      width: 80,
      height: 80,
      borderRadius: 40,
      backgroundColor: "#FF3B30",
      alignItems: "center",
      justifyContent: "center",
      shadowColor: "#FF3B30",
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.4,
      shadowRadius: 12,
      elevation: 8,
    },
    duration: {
      ...typography.amount,
      color: colors.text,
      marginBottom: spacing.xs,
    },
    status: {
      ...typography.headline,
      color: colors.textTertiary,
      marginBottom: spacing.lg,
    },
    waveContainer: {
      flexDirection: "row",
      alignItems: "center",
      height: 32,
      marginBottom: spacing.lg,
    },
    hint: {
      ...typography.footnote,
      color: colors.textTertiary,
    },
  });


=================================================================================
FILE: ./components/SkeletonCard.tsx
=================================================================================

import React, { useEffect, useRef } from "react";
import { View, StyleSheet, Animated } from "react-native";
import { useTheme } from "@/lib/theme";

/**
 * SkeletonCard Component
 * Per design-system.md Section 3.3
 * Shimmering placeholder matching invoice card layout
 */

interface SkeletonCardProps {
  count?: number;
}

function SkeletonItem() {
  const { colors, radius, shadows } = useTheme();
  const shimmerAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    const shimmer = Animated.loop(
      Animated.sequence([
        Animated.timing(shimmerAnim, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        }),
        Animated.timing(shimmerAnim, {
          toValue: 0,
          duration: 1000,
          useNativeDriver: true,
        }),
      ])
    );
    shimmer.start();
    return () => shimmer.stop();
  }, []);

  const opacity = shimmerAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.3, 0.7],
  });

  const skeletonColor = colors.textTertiary + "30";

  return (
    <View
      style={[
        styles.card,
        {
          backgroundColor: colors.card,
          borderRadius: radius.md,
          ...shadows.default,
        },
      ]}
    >
      {/* Top Row: Name + Badge skeleton */}
      <View style={styles.topRow}>
        <Animated.View
          style={[
            styles.skeletonLine,
            styles.nameSkeleton,
            { backgroundColor: skeletonColor, opacity },
          ]}
        />
        <Animated.View
          style={[
            styles.skeletonLine,
            styles.badgeSkeleton,
            { backgroundColor: skeletonColor, opacity },
          ]}
        />
      </View>

      {/* Bottom Row: Metadata + Amount skeleton */}
      <View style={styles.bottomRow}>
        <View style={styles.metadataRow}>
          <Animated.View
            style={[
              styles.skeletonLine,
              styles.idSkeleton,
              { backgroundColor: skeletonColor, opacity },
            ]}
          />
          <Animated.View
            style={[
              styles.skeletonLine,
              styles.dateSkeleton,
              { backgroundColor: skeletonColor, opacity },
            ]}
          />
        </View>
        <Animated.View
          style={[
            styles.skeletonLine,
            styles.amountSkeleton,
            { backgroundColor: skeletonColor, opacity },
          ]}
        />
      </View>
    </View>
  );
}

export function SkeletonCard({ count = 3 }: SkeletonCardProps) {
  return (
    <View>
      {Array.from({ length: count }).map((_, index) => (
        <SkeletonItem key={index} />
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    padding: 16,
    marginHorizontal: 16,
    marginVertical: 6,
  },
  topRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 12,
  },
  bottomRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    justifyContent: "space-between",
  },
  metadataRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  skeletonLine: {
    borderRadius: 4,
  },
  nameSkeleton: {
    width: 140,
    height: 20,
  },
  badgeSkeleton: {
    width: 60,
    height: 24,
    borderRadius: 12,
  },
  idSkeleton: {
    width: 70,
    height: 14,
  },
  dateSkeleton: {
    width: 50,
    height: 14,
  },
  amountSkeleton: {
    width: 80,
    height: 24,
  },
});


=================================================================================
FILE: ./components/ui/Button.tsx
=================================================================================

import { Pressable, Text, ActivityIndicator } from "react-native";
import * as Haptics from "expo-haptics";

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: "primary" | "secondary" | "outline";
  disabled?: boolean;
  loading?: boolean;
}

export function Button({
  title,
  onPress,
  variant = "primary",
  disabled = false,
  loading = false,
}: ButtonProps) {
  const handlePress = () => {
    if (!disabled && !loading) {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      onPress();
    }
  };

  const baseClasses = "py-4 px-6 rounded-full items-center justify-center";
  const variantClasses = {
    primary: "bg-primary",
    secondary: "bg-gray-100",
    outline: "bg-transparent border border-gray-200",
  };
  const textClasses = {
    primary: "text-white font-semibold text-lg",
    secondary: "text-black font-semibold text-lg",
    outline: "text-black font-semibold text-lg",
  };

  return (
    <Pressable
      onPress={handlePress}
      disabled={disabled || loading}
      className={`${baseClasses} ${variantClasses[variant]} ${
        disabled ? "opacity-50" : ""
      }`}
    >
      {loading ? (
        <ActivityIndicator color={variant === "primary" ? "#FFFFFF" : "#000000"} />
      ) : (
        <Text className={textClasses[variant]}>{title}</Text>
      )}
    </Pressable>
  );
}


=================================================================================
FILE: ./components/ui/Card.tsx
=================================================================================

import { View, Pressable, StyleSheet, Animated } from "react-native";
import * as Haptics from "expo-haptics";
import { ReactNode, useRef } from "react";

interface CardProps {
  children: ReactNode;
  onPress?: () => void;
  variant?: "default" | "elevated" | "outlined" | "gradient";
  className?: string;
}

export function Card({ children, onPress, variant = "default", className = "" }: CardProps) {
  const scaleAnim = useRef(new Animated.Value(1)).current;

  const handlePressIn = () => {
    if (onPress) {
      Animated.spring(scaleAnim, {
        toValue: 0.98,
        friction: 8,
        tension: 100,
        useNativeDriver: true,
      }).start();
    }
  };

  const handlePressOut = () => {
    if (onPress) {
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 8,
        tension: 100,
        useNativeDriver: true,
      }).start();
    }
  };

  const handlePress = () => {
    if (onPress) {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      onPress();
    }
  };

  const getVariantStyles = () => {
    switch (variant) {
      case "elevated":
        return styles.elevated;
      case "outlined":
        return styles.outlined;
      case "gradient":
        return styles.gradient;
      default:
        return styles.default;
    }
  };

  const content = (
    <View style={styles.innerHighlight}>
      {children}
    </View>
  );

  if (onPress) {
    return (
      <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
        <Pressable
          onPress={handlePress}
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          style={[styles.base, getVariantStyles()]}
        >
          {content}
        </Pressable>
      </Animated.View>
    );
  }

  return (
    <View style={[styles.base, getVariantStyles()]}>
      {content}
    </View>
  );
}

const styles = StyleSheet.create({
  base: {
    borderRadius: 20,
    padding: 20,
    overflow: "hidden",
  },
  default: {
    backgroundColor: "#FFFFFF",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.06,
    shadowRadius: 8,
    elevation: 3,
  },
  elevated: {
    backgroundColor: "#FFFFFF",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.12,
    shadowRadius: 24,
    elevation: 8,
  },
  outlined: {
    backgroundColor: "#FFFFFF",
    borderWidth: 1,
    borderColor: "rgba(0, 0, 0, 0.06)",
  },
  gradient: {
    backgroundColor: "#F8F9FA",
    borderWidth: 1,
    borderColor: "rgba(0, 0, 0, 0.04)",
  },
  innerHighlight: {
    // This adds subtle depth
  },
});


=================================================================================
FILE: ./components/ui/Input.tsx
=================================================================================

import { View, Text, TextInput, TextInputProps } from "react-native";

interface InputProps extends TextInputProps {
  label?: string;
  error?: string;
}

export function Input({ label, error, ...props }: InputProps) {
  return (
    <View className="mb-4">
      {label && (
        <Text className="text-sm text-gray-500 mb-2 font-medium">{label}</Text>
      )}
      <TextInput
        className={`bg-gray-50 rounded-xl px-4 py-4 text-lg ${
          error ? "border border-red-500" : ""
        }`}
        placeholderTextColor="#999999"
        {...props}
      />
      {error && <Text className="text-red-500 text-sm mt-1">{error}</Text>}
    </View>
  );
}


=================================================================================
FILE: ./components/VoiceButton.tsx
=================================================================================

import { View, Pressable, Animated, StyleSheet } from "react-native";
import { Mic } from "lucide-react-native";
import * as Haptics from "expo-haptics";
import { useRef, useEffect } from "react";
import { COLORS } from "../lib/constants";

interface VoiceButtonProps {
  onPressIn: () => void;
  onPressOut: () => void;
  isRecording: boolean;
}

export function VoiceButton({
  onPressIn,
  onPressOut,
  isRecording,
}: VoiceButtonProps) {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const pulseAnim1 = useRef(new Animated.Value(1)).current;
  const pulseAnim2 = useRef(new Animated.Value(1)).current;
  const pulseOpacity1 = useRef(new Animated.Value(0.6)).current;
  const pulseOpacity2 = useRef(new Animated.Value(0.4)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (isRecording) {
      // Start pulse animations
      const pulse1 = Animated.loop(
        Animated.parallel([
          Animated.timing(pulseAnim1, {
            toValue: 1.8,
            duration: 1500,
            useNativeDriver: true,
          }),
          Animated.timing(pulseOpacity1, {
            toValue: 0,
            duration: 1500,
            useNativeDriver: true,
          }),
        ])
      );

      const pulse2 = Animated.loop(
        Animated.sequence([
          Animated.delay(500),
          Animated.parallel([
            Animated.timing(pulseAnim2, {
              toValue: 1.6,
              duration: 1500,
              useNativeDriver: true,
            }),
            Animated.timing(pulseOpacity2, {
              toValue: 0,
              duration: 1500,
              useNativeDriver: true,
            }),
          ]),
        ])
      );

      const glow = Animated.loop(
        Animated.sequence([
          Animated.timing(glowAnim, {
            toValue: 1,
            duration: 800,
            useNativeDriver: false,
          }),
          Animated.timing(glowAnim, {
            toValue: 0.5,
            duration: 800,
            useNativeDriver: false,
          }),
        ])
      );

      pulse1.start();
      pulse2.start();
      glow.start();

      return () => {
        pulse1.stop();
        pulse2.stop();
        glow.stop();
        pulseAnim1.setValue(1);
        pulseAnim2.setValue(1);
        pulseOpacity1.setValue(0.6);
        pulseOpacity2.setValue(0.4);
        glowAnim.setValue(0);
      };
    }
  }, [isRecording]);

  const handlePressIn = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
    Animated.spring(scaleAnim, {
      toValue: 0.92,
      friction: 3,
      tension: 100,
      useNativeDriver: true,
    }).start();
    onPressIn();
  };

  const handlePressOut = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    Animated.spring(scaleAnim, {
      toValue: 1,
      friction: 3,
      tension: 100,
      useNativeDriver: true,
    }).start();
    onPressOut();
  };

  const buttonColor = isRecording ? "#FF3B30" : COLORS.primary;

  const shadowRadius = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [12, 25],
  });

  const shadowOpacity = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.4, 0.7],
  });

  return (
    <View style={styles.container}>
      {/* Pulse rings when recording */}
      {isRecording && (
        <>
          <Animated.View
            style={[
              styles.pulseRing,
              {
                backgroundColor: "#FF3B30",
                transform: [{ scale: pulseAnim1 }],
                opacity: pulseOpacity1,
              },
            ]}
          />
          <Animated.View
            style={[
              styles.pulseRing,
              {
                backgroundColor: "#FF3B30",
                transform: [{ scale: pulseAnim2 }],
                opacity: pulseOpacity2,
              },
            ]}
          />
        </>
      )}

      <Animated.View
        style={{
          transform: [{ scale: scaleAnim }],
        }}
      >
        {/* Glow layer */}
        <Animated.View
          style={[
            styles.glowLayer,
            {
              backgroundColor: buttonColor,
              shadowColor: buttonColor,
              shadowRadius: isRecording ? shadowRadius : 12,
              shadowOpacity: isRecording ? shadowOpacity : 0.4,
            },
          ]}
        />

        {/* Main button */}
        <Pressable
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          style={[
            styles.button,
            {
              backgroundColor: buttonColor,
            },
          ]}
        >
          {/* Inner gradient overlay */}
          <View style={styles.innerHighlight} />
          <Mic size={32} color="#FFFFFF" strokeWidth={2.5} />
        </Pressable>
      </Animated.View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    width: 88,
    height: 88,
    alignItems: "center",
    justifyContent: "center",
  },
  pulseRing: {
    position: "absolute",
    width: 88,
    height: 88,
    borderRadius: 44,
  },
  glowLayer: {
    position: "absolute",
    width: 88,
    height: 88,
    borderRadius: 44,
    shadowOffset: { width: 0, height: 4 },
    elevation: 15,
  },
  button: {
    width: 88,
    height: 88,
    borderRadius: 44,
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  },
  innerHighlight: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    height: "50%",
    backgroundColor: "rgba(255, 255, 255, 0.15)",
    borderTopLeftRadius: 44,
    borderTopRightRadius: 44,
  },
});


=================================================================================
FILE: ./contexts/AuthContext.tsx
=================================================================================

import React, { createContext, useContext, useEffect, useState } from "react";
import { Session, User } from "@supabase/supabase-js";
import { supabase } from "@/services/supabase";
import { Profile } from "@/types/database";

interface AuthContextType {
  user: User | null;
  session: Session | null;
  profile: Profile | null;
  isLoading: boolean;
  signUp: (
    email: string,
    password: string,
    fullName: string
  ) => Promise<{ error: Error | null }>;
  signIn: (
    email: string,
    password: string
  ) => Promise<{ error: Error | null }>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<{ error: Error | null }>;
  refreshProfile: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [profile, setProfile] = useState<Profile | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch user profile from database
  const fetchProfile = async (userId: string) => {
    const { data, error } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", userId)
      .single();

    if (error) {
      console.error("Error fetching profile:", error);
      return null;
    }

    return data;
  };

  // Refresh profile data
  const refreshProfile = async () => {
    if (user) {
      const profileData = await fetchProfile(user.id);
      setProfile(profileData);
    }
  };

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);

      if (session?.user) {
        fetchProfile(session.user.id).then(setProfile);
      }

      setIsLoading(false);
    });

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      setSession(session);
      setUser(session?.user ?? null);

      if (session?.user) {
        const profileData = await fetchProfile(session.user.id);
        setProfile(profileData);
      } else {
        setProfile(null);
      }

      setIsLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const signUp = async (email: string, password: string, fullName: string) => {
    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            full_name: fullName,
          },
        },
      });

      if (error) throw error;
      return { error: null };
    } catch (error) {
      return { error: error as Error };
    }
  };

  const signIn = async (email: string, password: string) => {
    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;
      return { error: null };
    } catch (error) {
      return { error: error as Error };
    }
  };

  const signOut = async () => {
    await supabase.auth.signOut();
    setProfile(null);
  };

  const resetPassword = async (email: string) => {
    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email);
      if (error) throw error;
      return { error: null };
    } catch (error) {
      return { error: error as Error };
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        session,
        profile,
        isLoading,
        signUp,
        signIn,
        signOut,
        resetPassword,
        refreshProfile,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}


=================================================================================
FILE: ./docs/architecture-spec.md
=================================================================================

Architectural Blueprint: "ContractorPro" AI-Driven Invoicing System
1. Executive Overview and System Philosophy
The construction and contracting industry operates in a unique intersection of physical labor, complex logistics, and chaotic administrative environments. "ContractorPro" is not merely an invoicing application; it is a bridge between the unstructured, high-noise reality of a job site and the rigid, structured requirements of financial accounting. The core architectural mandate for this system is to facilitate the seamless transformation of voice commandsoften delivered in mixed languages such as Spanglish or Portuolinto professional, legally compliant financial documents. This report details the technical architecture of the "Brain" (the AI processing layer), the "Skeleton" (the Database schema), and the "Circulatory System" (the Financial data flow).
The system is designed for a specific persona: the independent contractor who may be a native Spanish or Portuguese speaker but conducts business in an English-dominant market (or vice versa). This user often utilizes "code-switching," a linguistic phenomenon where they alternate between languages within a single sentence to bridge vocabulary gaps.1 Standard dictation tools fail here because they lack the semantic understanding of domain-specific jargon (e.g., "rufa" for roof, "sheetrock" vs. "placa"). Therefore, ContractorPro leverages OpenAIs GPT-4o for its superior multilingual reasoning and context window capabilities 3, integrated with Supabases robust PostgreSQL infrastructure 5 and Stripe Connects decentralized payment architecture.7
This blueprint prioritizes three non-functional requirements:
1. High-Fidelity Semantic Parsing: The ability to distinguish between a "Quote" and an "Invoice" based on verb tense and context.
2. Data Sovereignty and Security: Utilizing Row Level Security (RLS) to ensure strict multi-tenancy.
3. Financial Integrity: Implementing a "Direct Charges" model where the contractor is the merchant of record, minimizing platform liability.8
________________
2. The AI "Brain": Universal Translator and Prompt Architecture
The "Brain" of ContractorPro is an orchestration layer that combines audio signal processing with Large Language Model (LLM) reasoning. Unlike simple transcription services, this layer must perform "Intent Discovery" 9, entity extraction, and cross-lingual normalization simultaneously. The choice of GPT-4o is predicated on its multimodal capabilities and improved performance in non-English languages compared to previous iterations.4
2.1 Audio Ingestion and Pre-Processing
The entry point for data is the contractor's voice. Construction environments are acoustically hostile, characterized by impulse noises (hammers), broadband noise (generators), and reverberation (empty rooms).
2.1.1 Whisper Integration Strategy
We utilize OpenAIs Whisper model for Automatic Speech Recognition (ASR). While GPT-4o has native audio capabilities, separating the ASR step using Whisper allows for intermediate caching and lower latency in low-bandwidth environments common on job sites. The React Native application captures audio in .m4a or .wav formats. To optimize for "Spanglish," the language parameter in the Whisper API call should be set to auto or omitted, allowing the model to detect language switching dynamically. However, distinct prompt engineering at the Whisper level is required to guide the transcription of proper nouns (client names) and industry terms.
Technical Insight: Whisper is a sequence-to-sequence model trained on weak supervision. It excels at "decoding" audio but does not inherently "understand" it. The raw transcript from Whisper often contains phonetic approximations of Spanglish terms (e.g., transcribing "framing" as "freiming"). The burden of semantic correction falls on the subsequent GPT-4o layer.
2.2 The Universal Translator System Prompt
The System Prompt is the most critical software asset in the AI layer. It governs the behavior of GPT-4o, transforming it from a general-purpose chat bot into a specialized financial administrator.
2.2.1 Prompt Engineering Framework
We employ a "Role-Task-Context-Output" framework 11, augmented with Chain-of-Thought (CoT) instructions to handle ambiguity.12 The prompt must enforce a specific JSON schema for the output to ensure compatibility with the PostgreSQL database.3
The Challenge of Code-Switching:
Research indicates that multilingual models like mBERT or XLM-R often struggle with code-switching unless specifically fine-tuned. GPT-4o, however, demonstrates strong zero-shot performance in these scenarios if the prompt explicitly legitimizes the mixed input. The prompt must instruct the model to treat "Spanglish" not as an error, but as a valid dialect.2
Vocabulary Injection:
The prompt includes a dynamic glossary of construction terms. For instance, the term "placa" in standard Spanish means "plate" or "license plate," but in construction slang, it refers to "drywall" or "sheetrock".14 The prompt directs the model to map these colloquialisms to professional invoice line items.
2.2.2 The "ContractorPro" System Prompt Specification
Below is the architected system prompt. It is designed to be static but extensible, allowing for the injection of user-specific context (e.g., the user's trade).
Role
You are "ContractorAI," a senior construction administrator and linguistic expert specialized in the invoicing workflows of independent contractors. You possess deep knowledge of construction terminology in English, Spanish, and Portuguese, including regional dialects, slang, and "Spanglish/Portuol" hybridizations (e.g., "rufa" for roof, "trozas" for trusses, "chirok" for sheetrock).
Objective
Your task is to analyze a raw audio transcript provided by a contractor and extract structured financial data to generate a valid Invoice or Quote. You must normalize all colloquial terms into professional English (or the target language if specified) suitable for a formal business document.
Input Context
* The input is a raw transcript from OpenAI Whisper.
* It may contain background noise artifacts, hesitation markers ("um," "uh"), and non-standard grammar.
* The speaker may switch languages mid-sentence (Code-Switching).
* Current Date: {{CURRENT_DATE}}
* User Trade: {{USER_TRADE}} (e.g., Plumber, Electrician)
Critical Rules & Logic
1. Intent Detection: Determine if the user is describing completed work ("INVOICE") or future work ("QUOTE"). Look for temporal markers (past tense vs. future tense/conditional). If ambiguous, default to "INVOICE" but flag low confidence.9
2. Linguistic Normalization:
   * Identify "Spanglish" terms and translate them to their Standard English professional equivalents.
   * Example: Input "Instalamos la carpeta en el master bedroom" -> Output Description "Carpet Installation - Master Bedroom".
   * Example: Input "Fixeamos la liqueo" -> Output Description "Leak Repair".
3. Entity Extraction:
   * Extract quantity, unit, unit_price, and total.
   * If a total is mentioned that contradicts (quantity * unit_price), trust the unit calculation but add a warning flag.
   * If no price is mentioned, mark unit_price as 0 and requires_review as true.
4. Currency Logic: Default to USD unless specific currency markers (Pesos, Reais) are present.
5. Output Format: You must output ONLY valid JSON adhering to the schema below. Do not output conversational text.
JSON Output Schema
{
"meta": {
"intent": "INVOICE" | "QUOTE",
"confidence": number,
"language_detected": "string",
"currency": "USD" | "BRL" | "MXN" | "EUR"
},
"client": {
"name": "string or null",
"contact_inferred": "string or null"
},
"line_items":,
"notes": "string (Any specialized instructions found in transcript)"
}
2.3 Handling Hallucinations and Ambiguity
Generative models can hallucinate, inventing line items that were not spoken. To mitigate this, the original_transcript_segment field in the JSON schema forces the model to ground its extraction in specific substrings of the input. This allows the UI to highlight the source text corresponding to each generated line item during the user review phase, increasing trust.
Furthermore, we utilize the specific parameter response_format: { type: "json_object" } available in the GPT-4o API to guarantee that the output is syntactically valid JSON.3 This prevents parsing errors in the application backend.
2.4 Token Economy and Cost Optimization
While GPT-4o is efficient, processing lengthy transcripts can be costly. To optimize, we employ a "Hybrid CSV/Prefix" style for the internal representation of line items if the transcript is exceptionally long, as research suggests this format reduces token usage compared to verbose JSON while maintaining structural integrity.3 However, for the final output to the application, JSON remains the standard for type safety.
________________
3. The Data Layer: Supabase (PostgreSQL) Architecture
The database is the system's "Skeleton," providing the rigid structure necessary for financial data. We utilize Supabase, which provides a managed PostgreSQL instance, Realtime subscriptions, and Storage.
3.1 Schema Design Philosophy
The schema must support:
1. Multi-tenancy: Strict isolation of data between contractors.
2. Relational Integrity: Invoices must belong to users; items must belong to invoices.
3. Stripe Connect Mapping: We must store the Stripe Account ID (acct_...) to facilitate payouts.
We adopt a "Declarative Schema" approach, managing the database structure via version-controlled SQL migration files rather than ad-hoc dashboard changes.16
3.2 Core Entity-Relationship Model
The following Markdown table describes the core tables and their primary responsibilities.
Table Name
	Description
	Key Relationships
	Security Policy (RLS)
	profiles
	Extends auth.users. Stores business profile and Stripe IDs.
	1:1 with auth.users
	User can only view/edit own profile.
	clients
	The contractor's customers. Stores CRM data.
	N:1 with profiles
	User can only view own clients.
	invoices
	The header object for a financial document.
	N:1 with clients, N:1 with profiles
	User can only view own invoices.
	invoice_items
	Individual line items (Labor, Materials).
	N:1 with invoices
	Cascade delete on Invoice deletion.
	voice_notes
	Metadata for audio files stored in buckets.
	N:1 with invoices
	User can only access own notes.
	3.3 Detailed Schema Definitions
3.3.1 User Profiles and Stripe Identity
The profiles table is the anchor for the Stripe Connect integration.


SQL




create table public.profiles (
 id uuid references auth.users on delete cascade not null primary key,
 business_name text,
 full_name text,
 stripe_account_id text unique, -- The 'acct_' ID from Stripe
 charges_enabled boolean default false, -- Webhook synced status
 payouts_enabled boolean default false, -- Webhook synced status
 default_currency text default 'USD',
 created_at timestamptz default now(),
 updated_at timestamptz default now()
);

-- RLS: Users can only see their own profile
alter table public.profiles enable row level security;
create policy "Public profiles are viewable by everyone" on public.profiles for select using ( true );
create policy "Users can insert their own profile" on public.profiles for insert with check ( auth.uid() = id );
create policy "Users can update own profile" on public.profiles for update using ( auth.uid() = id );

3.3.2 Invoices and Financial Data
The invoices table requires specific fields to link with Stripe's PaymentIntents.


SQL




create type invoice_status as enum ('draft', 'sent', 'paid', 'void', 'overdue');

create table public.invoices (
 id uuid default gen_random_uuid() primary key,
 user_id uuid references public.profiles(id) not null,
 client_id uuid references public.clients(id),
 stripe_payment_intent_id text, -- Critical for reconciliation
 stripe_hosted_invoice_url text,
 status invoice_status default 'draft',
 subtotal bigint, -- Stored in cents/smallest currency unit
 tax_amount bigint,
 total bigint,
 currency text default 'USD',
 due_date date,
 created_at timestamptz default now()
);

-- Indexing for Performance
create index invoices_user_id_idx on public.invoices(user_id);
create index invoices_stripe_pi_idx on public.invoices(stripe_payment_intent_id); -- Vital for Webhook lookup

3.4 Audio Storage and Security
ContractorPro stores raw voice notes which may contain sensitive PII (Personally Identifiable Information). Therefore, Supabase Storage buckets must be configured as Private.
Bucket Configuration:
* Name: voice-evidence
* Access: Authenticated only.
* Policy: (storage.foldername(name)) = auth.uid()::text
This policy ensures that a user can only upload and retrieve files in a folder named after their User ID, enforcing strict isolation at the storage level.18 To play back audio in the React Native app, the backend generates a Signed URL with a short expiration (e.g., 60 seconds), preventing unauthorized sharing of the underlying asset.19
3.5 Vector Search for Client Deduplication
To enhance the UX, we can implement a pgvector extension on the clients table. When GPT-4o extracts a client name (e.g., "Mr. John Smith"), we embedding-match it against existing clients to prevent duplicate entries (e.g., matching "Jon Smith" to "John Smith"). This uses Supabase's native vector support.21
________________
4. Financial Infrastructure: Stripe Connect Data Flow
The financial layer is the "Circulatory System," managing the flow of funds. For ContractorPro, the Stripe Connect Standard account type is the optimal architectural choice.
4.1 Account Strategy: Standard vs. Express
The decision to use Standard Accounts is strategic:
* Liability: In Standard accounts, the contractor is the merchant of record. They act as the direct seller to the client. This insulates the ContractorPro platform from chargeback liability and complex tax nexus issues.22
* Feature Set: Standard accounts give contractors access to the full Stripe Dashboard. They can manage their own banking details, view tax forms (1099-K), and handle disputes without building these features into the ContractorPro app.24
* Cost: Standard accounts have no monthly platform fees per active account, unlike Express accounts ($2/month), improving unit economics for a SaaS model.25
4.2 Onboarding Workflow (OAuth)
The onboarding process uses OAuth to link the contractor's Stripe account to the ContractorPro platform.
1. Initiation: User clicks "Connect Payouts" in React Native.
2. Edge Function: Calls stripe.accountLinks.create with type: 'account_onboarding'.
3. Redirection: User enters Stripe's hosted flow to provide KYC (Know Your Customer) data (SSN, Bank Info).
4. Completion: Stripe redirects to the app's return_url.
5. Synchronization: The app triggers a check to stripe.accounts.retrieve. We inspect charges_enabled and payouts_enabled and update the public.profiles table accordingly.26
4.3 Direct Charges Architecture
When a contractor sends an invoice, the platform facilitates a Direct Charge.
* Mechanism: The PaymentIntent is created with the Stripe-Account: {CONNECTED_STRIPE_ACCOUNT_ID} header.
* Flow of Funds: Client Credit Card -> Stripe -> Contractor's Balance.
* Monetization: ContractorPro takes a cut via application_fee_amount.
Code Example (Concept):


TypeScript




const paymentIntent = await stripe.paymentIntents.create({
 amount: invoiceTotal,
 currency: 'usd',
 application_fee_amount: platformFee, // e.g., 1%
 transfer_data: {
   destination: contractorStripeAccountId,
 },
 metadata: {
   supabase_invoice_id: invoice.id, // CRITICAL LINK
   supabase_user_id: user.id
 }
}, {
 stripeAccount: contractorStripeAccountId // This makes it a Direct Charge
});

4.4 Webhook Architecture and Reconciliation
Reconciling payments is the most fragile part of any fintech integration. We rely on Stripe Webhooks to update the invoice status in Supabase.
The "Connect Webhook" Nuance:
Because we are using Direct Charges on Standard Accounts, the webhook events originate from the connected account, not the platform account. We must configure the webhook endpoint in Stripe to "Listen to events on Connected Accounts".28
Event Handling: payment_intent.succeeded:
1. Ingestion: The webhook endpoint receives the event.
2. Validation: Verify Stripe-Signature using the signing secret.29
3. Identification: Extract event.data.object.metadata.supabase_invoice_id. This is the link established during the PaymentIntent creation.30
4. Update: Perform a database update on public.invoices setting status = 'paid'.
5. Idempotency: Log the event.id in a webhook_events table. If the same ID arrives again (Stripe retries), ignore it to prevent duplicate processing.28
Metadata Constraints:
Stripe limits metadata to 50 keys, with keys up to 40 characters and values up to 500 characters.31 Our architecture only requires invoice_id and user_id, which is well within limits.
________________
5. Integration Strategy and React Native Client
The mobile client is the interface for these complex backend systems.
5.1 Offline First Considerations
Contractors often work in basements or rural sites with poor connectivity.
* Audio: Recording happens locally. The upload to Supabase Storage is queued and retried upon connection restoration.
* Drafting: The "Brain" processing requires a connection. However, the app should allow "queuing" of voice notes. When connectivity returns, the app batch-processes the pending audio files.
5.2 User Verification Loop
AI is probabilistic. The UI must present the parsed invoice as a "Draft."
1. Visual Confirmation: Display the line items.
2. Audio Overlay: Allow the user to tap a line item and hear the specific snippet of audio that generated it (using timestamps from Whisper).
3. Edit Capability: Allow manual overrides before finalization.
5.3 Security
API Keys for OpenAI and Stripe Secret Keys must never be stored in the React Native bundle. All interactions with these third-party services are proxied through Supabase Edge Functions. The React Native app only holds the Supabase Anonymous Key (public) and the User's JWT (Session Token).
________________
6. Conclusion and Future Outlook
The "ContractorPro" architecture represents a robust synthesis of modern AI capabilities and established financial infrastructure. By utilizing GPT-4o with a specialized System Prompt, the system bridges the "Spanglish Gap," making digital tools accessible to a broader demographic of tradespeople. The Supabase backend provides the necessary relational integrity and security (RLS) for sensitive business data, while Stripe Connect Standard accounts offer a scalable, compliant, and trust-minimized financial model.
This architecture is designed not just for function, but for resiliencehandling the noisy, messy, and multilingual reality of the construction industry with the precision of a digital accountant.
7. Operational Scalability and Edge Cases
7.1 Scalability of the "Brain"
As the user base grows, the load on the OpenAI API will increase.
* Rate Limiting: We must implement a queue system in Supabase (using pg_net or similar) to manage outbound requests to OpenAI, ensuring we do not hit rate limits during peak hours (e.g., 5 PM when contractors finish work).
* Model Distillation: Eventually, the proprietary dataset of "Spanglish Construction Terms" collected by the system can be used to fine-tune a smaller model (like GPT-4o-mini), reducing costs by up to 60% while maintaining accuracy on this specific domain.
7.2 Handling "Ambiguous" Intents
A major edge case is the "Ambiguous Intent."
* User says: "I need 50 sheets of drywall for the Smith job."
* System Dilemma: Is this a purchase order? An invoice for work done? A quote for the client?
* Solution: The prompt logic defaults to "Draft Invoice" but flags the confidence score. The UI interprets this flag and prompts the user: "Is this a new Invoice or a Quote?" This "Human-in-the-Loop" design is essential for trust.
7.3 Data Privacy and Audio Retention
Given the sensitive nature of business dealings:
* Retention Policy: We implement a Supabase Storage lifecycle rule to auto-delete raw audio files after 30 days, keeping only the text transcript and the generated JSON. This reduces storage costs and liability.
* Encryption: All data is encrypted at rest in PostgreSQL and Supabase Storage.
8. Detailed API Specifications
8.1 Edge Function: transcribe-and-parse
* Trigger: HTTPS POST from Client.
* Payload: { audio_file_path: string, user_id: string }
* Process:
   1. Validate JWT.
   2. Fetch Audio Blob from Storage.
   3. POST to api.openai.com/v1/audio/transcriptions (Whisper).
   4. Construct Prompt (See Section 2.2).
   5. POST to api.openai.com/v1/chat/completions (GPT-4o).
   6. Insert into invoices table.
* Response: { success: true, invoice_id: uuid, confidence: number }
8.2 Edge Function: generate-payment-link
* Trigger: HTTPS POST from Client (User clicks "Send").
* Process:
   1. Retrieve invoice and items from DB.
   2. Retrieve stripe_account_id from profiles.
   3. Create Stripe Product and Price objects for each line item (or a single ad-hoc line item).
   4. Create Stripe PaymentLink or Invoice object.
   5. Update invoices table with payment_link_url.
* Response: { url: string }
This detailed architectural breakdown provides the comprehensive roadmap necessary for the engineering team to build "ContractorPro" with confidence, ensuring all requirements from the promptAI intelligence, database rigor, and financial complianceare met with industry-best practices.
9. Advanced Prompt Engineering: The Mechanics of Code-Switching
The success of ContractorPro hinges entirely on the system's ability to normalize "Spanglish." This is not merely translation; it is cultural interpretation.
9.1 The Phenomenology of Spanglish in Construction
Construction Spanglish often involves "loanwords"English words adapted to Spanish phonology/morphology.
* Morphological Adaptation: Verbs are conjugated. "To park" becomes "Parquear." "To check" becomes "Chequear" or "Checar." "To mop" becomes "Mopear."
* Phonetic Adaptation: Nouns are spelled as they sound. "Roof" -> "Rufa." "Truck" -> "Troca." "Gauges" -> "Geiyes."
9.2 The "Glossary Injection" Technique
To handle this, the System Prompt is dynamically assembled. We maintain a glossary table in Supabase.
* Table: glossary_terms (term, standard_english, category)
* Injection: Before calling GPT-4o, the Edge Function queries this table for common terms and injects them into the context.
* Prompt Segment:
Use the following construction glossary for reference:
   * "Rufa" -> Roof
   * "Freiming" -> Framing
   * "Liqueo" -> Leak
   * "Shirok" -> Sheetrock/Drywall
   * "Placa" -> Sheetrock/Drywall
   * "Fila" -> Field/Row
This "Few-Shot Prompting" technique drastically improves the model's ability to map non-standard inputs to professional outputs.4
10. Database Deep Dive: Declarative Schema Management
Managing database changes in a production environment requires discipline. We recommend using Supabase's CLI for Declarative Schema Management.16
10.1 The Migration Workflow
      1. Local Development: Developers run a local instance of Supabase (supabase start).
      2. Schema Changes: Changes are made via SQL in the supabase/migrations folder.
      * Example: 20231027_create_invoices.sql
      3. Diffing: The CLI command supabase db diff compares the local schema to the remote schema and generates a new migration file.
      4. Deployment: In CI/CD (GitHub Actions), the command supabase db push applies pending migrations to the production database.
This workflow ensures that the database schema is versioned alongside the application code, preventing "schema drift" where the production database creates errors because it lacks a column that exists in the development environment.
10.2 Indexing Strategy for High-Volume Reads
The invoices table will grow rapidly. The dashboard requires filtering by date, client, and status.
      * Composite Index: CREATE INDEX idx_invoices_user_status_date ON invoices (user_id, status, created_at DESC);
      * Reasoning: This specific index covers the most common query: "Show me my pending invoices from newest to oldest."
      * GIN Index for JSONB: CREATE INDEX idx_clients_address ON clients USING GIN (address);
      * Reasoning: Since addresses are stored as JSONB to accommodate international formats, a GIN (Generalized Inverted Index) allows for efficient searching within the JSON structure (e.g., "Find all clients in Zip Code 90210").
11. Comprehensive Security Model
11.1 Row Level Security (RLS) Mechanics
RLS is the firewall of the database. It is not an application-level check; it is enforced by the PostgreSQL query planner.
      * The Policy: auth.uid() = user_id
      * The Mechanism: When a query SELECT * FROM invoices is run, Postgres transparently appends WHERE user_id = 'current_user_uuid' to the query.
      * Implication: Even if there is a bug in the API code that forgets to filter by user ID, the database itself will return zero rows for other users' data. This is a "Defense in Depth" strategy critical for a financial SaaS.
11.2 PII Redaction in Logs
The system logs interactions for debugging. However, logs should not contain PII.
      * Data Masking: The Edge Functions must implement a logger that masks client_name, address, and email before writing to Supabase Logs or an external observability platform (e.g., Datadog).
      * Retention: Logs are retained for 7 days for debugging, then hard-deleted.
12. Final Architecture Summary
The "ContractorPro" system is a sophisticated assembly of best-in-class technologies.
      * Brain: OpenAI GPT-4o + Whisper (Multilingual Reasoning).
      * Skeleton: Supabase PostgreSQL (Structured Data & Security).
      * Nerves: Supabase Edge Functions (Logic & Glue).
      * Blood: Stripe Connect Standard (Financial Flow).
      * Skin: React Native (User Interface).
This architecture provides the necessary foundation to solve the "unstructured-to-structured" data problem in the construction industry, unlocking significant value for independent contractors by automating their most hated task: paperwork.
Works cited
      1. Daily Papers - Hugging Face, accessed January 11, 2026, https://huggingface.co/papers?q=Multilingual%20language%20models
      2. Translanguaging Interpretive Power in Formative Assessment Co-Design: A Catalyst for Science Teacher Agentive Shifts - ResearchGate, accessed January 11, 2026, https://www.researchgate.net/publication/361077709_Translanguaging_Interpretive_Power_in_Formative_Assessment_Co-Design_A_Catalyst_for_Science_Teacher_Agentive_Shifts
      3. Enhancing structured data generation with GPT-4o evaluating prompt efficiency across prompt styles - PMC - PubMed Central, accessed January 11, 2026, https://pmc.ncbi.nlm.nih.gov/articles/PMC11979239/
      4. Putting GPT-4o to the Sword: A Comprehensive Evaluation of Language, Vision, Speech, and Multimodal Proficiency - MDPI, accessed January 11, 2026, https://www.mdpi.com/2076-3417/14/17/7782
      5. Visual Schema Designer | Supabase Features, accessed January 11, 2026, https://supabase.com/features/visual-schema-designer
      6. Database | Supabase Docs, accessed January 11, 2026, https://supabase.com/docs/guides/database/overview
      7. Stripe Connect | Platform and Marketplace Payment Solutions, accessed January 11, 2026, https://stripe.com/connect
      8. Create direct charges - Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/connect/direct-charges
      9. IntentGPT: Few-shot Intent Discovery with Large Language Models - arXiv, accessed January 11, 2026, https://arxiv.org/html/2411.10670v1
      10. GPT-4o System Card | OpenAI, accessed January 11, 2026, https://openai.com/index/gpt-4o-system-card/
      11. How to get GPT 4o mini to reply in the same language 100% of the time? - Reddit, accessed January 11, 2026, https://www.reddit.com/r/ChatGPTPromptGenius/comments/1g6ouuj/how_to_get_gpt_4o_mini_to_reply_in_the_same/
      12. GPT-4.1 Prompting Guide - OpenAI Cookbook, accessed January 11, 2026, https://cookbook.openai.com/examples/gpt4-1_prompting_guide
      13. Function calling | OpenAI API, accessed January 11, 2026, https://platform.openai.com/docs/guides/function-calling
      14. Construction Terms in Spanish - Glossary | Bradley Hartmann & Co, accessed January 11, 2026, https://www.bradleyhartmannandco.com/construction-terms-in-spanish-glossary
      15. Jobsite Spanish: 100+ Phrases & Terms for Construction Sites & Warehouses | Jobble, accessed January 11, 2026, https://jobble.com/articles/jobsite-spanish-terms-construction-and-warehouses/
      16. Declarative database schemas | Supabase Docs, accessed January 11, 2026, https://supabase.com/docs/guides/local-development/declarative-database-schemas
      17. Declarative Schemas for Simpler Database Management - Supabase, accessed January 11, 2026, https://supabase.com/blog/declarative-schemas
      18. Storage Buckets | Supabase Docs, accessed January 11, 2026, https://supabase.com/docs/guides/storage/buckets/fundamentals
      19. Serving assets from Storage | Supabase Docs, accessed January 11, 2026, https://supabase.com/docs/guides/storage/serving/downloads
      20. JavaScript: Create a signed URL | Supabase Docs, accessed January 11, 2026, https://supabase.com/docs/reference/javascript/storage-from-createsignedurl
      21. Localize your Supabase database with AI translation right from the dashboard - YouTube, accessed January 11, 2026, https://www.youtube.com/watch?v=loOJxuwgn2g
      22. Connect account types | Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/connect/accounts
      23. Create subscriptions with Stripe Billing - Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/connect/subscriptions
      24. Using Connect with Standard connected accounts - Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/connect/standard-accounts
      25. Getting started with Stripe Connect using Next.js - LogRocket Blog, accessed January 11, 2026, https://blog.logrocket.com/getting-started-stripe-connect-next-js/
      26. Onboarding a user (connecting Stripe account) - Zeroqode Docs, accessed January 11, 2026, https://docs.zeroqode.com/onboarding-a-user-(connecting-stripe-account)-192c669b00ed80c090cadb1f2f4db848
      27. The Account object | Stripe API Reference, accessed January 11, 2026, https://docs.stripe.com/api/accounts/object
      28. Connect webhooks - Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/connect/webhooks
      29. Receive Stripe events in your webhook endpoint, accessed January 11, 2026, https://docs.stripe.com/webhooks
      30. Metadata use cases - Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/metadata/use-cases
      31. Metadata | Stripe Documentation, accessed January 11, 2026, https://docs.stripe.com/metadata
      32. Bilingual Evaluation of Language Models on General Knowledge in University Entrance Exams with Minimal Contamination - arXiv, accessed January 11, 2026, https://arxiv.org/html/2409.12746v1

=================================================================================
FILE: ./docs/design-system.md
=================================================================================

UX Architecture Report: Transforming ContractorPro via Apple Human Interface Guidelines
Executive Summary: The Evolution from Utility to Experience
In the contemporary mobile ecosystem, particularly within the iOS environment, the distinction between a functional utility and a premier user experience has become the primary competitive differentiator. "ContractorPro," currently characterized by a "cluttered, robotic feel," suffers from a common ailment in financial software: the prioritization of raw data exposition over cognitive clarity. Users, specifically independent contractors and freelancers, do not view their invoicing applications merely as databases; they view them as the digital nervous system of their livelihood. The "robotic" quality stems from a lack of anticipationthe app waits for input rather than guiding the userand a visual rigidity that ignores the fluid, organic physics inherent to modern iOS design.
This report serves as a comprehensive UX architecture session, aiming to dismantle the legacy spreadsheet mental model and replace it with an object-oriented, tactile financial experience. By rigorously applying Apples Human Interface Guidelines (HIG) and leveraging the latest capabilities of iOS 17 and 18, we will redefine the core pillars of the application: the Invoice List, the Dashboard/Invoice Tab dichotomy, and the psychology of Empty States. The transformation moves the user from a passive state of data entry to an active state of financial command, utilizing "Pulse UI" animations, "Squircle" geometry, and "Live Activities" to create an interface that feels alive, responsive, and deeply integrated into the professional's daily workflow.
________________
1. The "Invoice List" Re-invention
The invoice list acts as the central nervous system of any billing application. However, the prevailing design patternoften a direct translation of a database table into a mobile list viewfails to account for the emotional and cognitive context of the user. An invoice is not merely a row of strings and integers; it is a claim to capital, a representation of labor performed, and a promise of future revenue. To strip the application of its "robotic" feel, we must fundamentally alter how these digital objects are presented, moving from a text-heavy table to a collection of distinct, tactile assets.
1.1 Visual Hierarchy and the "Wallet Pass" Paradigm
The primary failure of cluttered interfaces is the lack of a distinct visual hierarchy. When every data pointClient Name, Date, ID, Amount, Statusis presented with equal visual weight, the users brain must actively parse the screen to find relevant information. This cognitive load is perceived as "clutter." To resolve this, we look to one of the most successful implementations of complex data density on iOS: the Apple Wallet pass.
Research into Apple Wallets design structure reveals a highly specific hierarchy that prioritizes information based on immediate utility rather than database schema order.1 Wallet passes utilize a strict layout composed of a Primary Field, Secondary Fields, and Auxiliary Fields. Applying this to ContractorPro requires a radical shift in cell design.
The Primary Field must anchor the visual experience. In a Wallet pass, this is often the boarding gate or the balance. For an invoice, the most emotionally resonant data point is the Amount Due. This figure represents the users livelihood. Following the HIGs typographic principles, we should utilize San Francisco (SF) Pro Display, specifically in a "Heavy" or "Black" weight, to render the amount.2 By placing this element in the bottom-trailing position of the card (the bottom-right), we align with the natural terminal point of the users scanning pattern (the Z-pattern), allowing the eye to rest on the value of the asset.
The Secondary Fields provide the necessary context to justify the primary value. This slot belongs to the Client Name. Unlike the robotic list which might truncate long names, the new card design allocates the top-leading quadrant to the client entity, utilizing a Semibold weight to distinguish it from metadata.4 The research indicates that grouping related items through proximity and negative spacerather than explicit lines or bordersreduces visual noise.5 Therefore, the Client Name should sit in clear, unencumbered space, separated from the amount by whitespace rather than grid lines.
Auxiliary Fields handle the metadata: Invoice ID and Dates. A critical insight from HIG research is the recommendation to keep item text succinct.4 A "robotic" app displays "Due Date: October 24, 2025." A "human" app processes this data and displays "Due in 3 days." This shift from absolute data to relative context removes a calculation step for the user, making the app feel smarter and more helpful. These fields should be rendered in smaller, lighter fonts (SF Pro Text, Regular or Medium), utilizing tertiary label colors (system gray) to recede into the background until specifically sought by the user.6
1.2 The Physics of the Card: Geometry and Spacing
The "robotic" feel often stems from harsh geometries. Standard UI frameworks typically render rectangular boxes with sharp 90-degree corners or basic rounded corners. Apples design language, however, relies on the "Squircle"a superellipse that creates a continuous curve, smoothing the transition between the straight edge and the corner.8
To align ContractorPro with the native iOS aesthetic, we must adopt this geometry. Research suggests that a corner radius of approximately 10px to 13px is standard for list items that function as cards.9 However, the radius interacts with the padding. If the card is full-width (touching the screen edges), a smaller radius or no radius is expected. To break the "spreadsheet" look, the Invoice List should utilize an "Inset Grouped" style, where invoices are distinct cards floating on a system background. This introduces margins on the leading and trailing edges, allowing the background color to frame the content.5
This use of negative space is critical. The HIG emphasizes that essential information must be given sufficient space to breathe.5 By increasing the padding within the card (internal margins) and the spacing between cards (inter-item spacing), we reduce the density of the interface without reducing the information content. This "air" allows the user to perceive each invoice as a separate, manageable object, reducing the anxiety associated with a long list of debts.
1.3 Status Indicators: Semiotics over Text
A major contributor to clutter is the reliance on text for status indication. Words like "Pending," "Overdue," "Draft," and "Paid" add character count and cognitive load. The brain processes color and shape pre-attentively, meaning effectively designed indicators are understood before the user consciously reads them.
We must replace text labels with a system of abstract but intuitive glyphs and colors. However, standard system colors (pure Red #FF0000 or Green #00FF00) often feel harsh and antiquatedreminiscent of early computing, hence the "robotic" descriptor. The research points to a trend of using vibrant, "electric" hues that maintain accessibility while feeling modern.
For a "Paid" status, a Neon Green or Bright Green (e.g., #39FF14 or #66FF00) offers a high-energy signal of success.10 To ensure this meets WCAG AA accessibility standards (a contrast ratio of at least 4.5:1), this color should be used as a background element (like a badge or pill shape) with dark text, or as a glyph against a dark surface.12 Conversely, "Overdue" status should leverage an Electric Orange (e.g., #FF3503), which conveys urgency and alertness without the punitive, error-associated connotation of deep crimson.13
The shape of the indicator matters. A "Capsule" or "Lozenge" shape (rounded rectangle) is the standard iOS pattern for status badges.14 This shape mimics the physical tags used in retail or filing, reinforcing the object-oriented mental model. By placing this badge in the top-trailing position of the card, it acts as a secondary anchor, allowing the user to scan down the right side of the list to quickly assess the health of their accounts receivable.
1.4 Gestures: The Tactile Workflow
The "robotic" interface is static; interaction is limited to "Tap to Open." A "human" interface utilizes the full range of physical inputs available on the device, specifically swipe gestures, to allow management without navigation.
The Apple HIG advises offering alternatives to gestures for accessibility, but prioritizes fluid gestures for power users.15 In the context of an invoice list, the "Swipe to Delete" standard is insufficient and potentially dangerous. We must map gestures to the users most frequent needs.
Swipe Right (Leading Swipe): This gesture is ergonomically primary for right-handed users. In many mail applications, this is "Archive" or "Mark Read." For ContractorPro, the emotional equivalent is "Mark as Paid." This action creates a positive loop. When a user swipes right, the reveal should be a vibrant green, and the completion of the gesture should trigger a satisfying haptic feedback (using UIImpactFeedbackGenerator(style:.heavy)). This physical "thud" confirms the transaction, turning a digital update into a tangible accomplishment.16
Swipe Left (Trailing Swipe): This reveals management options.
1. More (...): A gray action that opens a context menu or action sheet (Duplicate, Share, Print).
2. Remind: An orange action that triggers an immediate email or push notification to the client. This "nudge" feature is high-value for contractors and fits perfectly in a quick-access gesture.
3. Delete/Void: A red destructive action, placed furthest from the edge to prevent accidental activation.
These gestures must follow the "rubber band" physics of iOS, where the list resists the pull at the extremities, maintaining the illusion of a continuous physical surface.5
________________
2. The "Dashboard" vs. "Invoice Tab" Conflict
A persistent friction point in financial app design is the redundancy between the "Dashboard" and the "Invoice List." In many "robotic" apps, the Dashboard is simply a truncated version of the list, leading to user confusion: "Where do I go to see my invoices?" To resolve this, we must clearly delineate their purposes: The Invoice Tab is for Management (The Database); The Dashboard is for Insight (The Pulse).
2.1 Navigation Architecture: The "Thumb Zone" Standard
The navigation structure defines the mental map of the application. Research into mobile navigation trends for 2025 emphasizes the dominance of the Bottom Tab Bar over hamburger menus or side drawers.17 As device screens expand (e.g., iPhone 17 Pro Max), the top corners of the screen become "dead zones," unreachable for one-handed users.
ContractorPro must adopt a standard 3-to-5 item Tab Bar to anchor the user.
* Tab 1: Dashboard (The Pulse). Icon: chart.bar.fill.
* Tab 2: Invoices (The List). Icon: list.bullet.rectangle.portrait.fill.
* Tab 3: Clients (The CRM). Icon: person.2.fill.
* Tab 4: Settings (The Config). Icon: gear.
This structure places the two most critical viewsDashboard and Invoicesadjacent to each other, allowing for rapid switching. It eliminates the "hidden" navigation of drawers, ensuring that the users location within the app is always visible and explicit.19
2.2 The Pulse UI: Making Data "Alive"
The Dashboard often feels robotic because it is static. It displays a snapshot of data that feels old the moment it is rendered. To create a "Pulse UI," we must leverage animation to convey currency and activity.
Rolling Number Transitions:
A critical innovation in iOS 17 is the contentTransition(.numericText()) modifier in SwiftUI.20 This allows numeric values to animate when they change, "rolling" into place like a mechanical flip-clock or a gas pump counter.
* Implementation: When the Dashboard loads, the "Total Revenue" figure should not simply appear. It should count up (e.g., from $0 to $12,500) over a short duration (e.g., 0.8 seconds).
* Psychology: This animation does two things. First, it draws the eye, establishing the hierarchy of the page. Second, it simulates calculation. It tells the user, "I am checking your books, counting your money, and here is the result." It makes the app feel like an active agent working for the user rather than a passive screen.21
Visualizing Time:
The Invoice Tab is a vertical list, optimal for scanning rows. To differentiate the Dashboard, we should utilize Horizontal Scroll Views (Card Grids).23 A horizontal carousel of "Recent Activity" or "Monthly Income" charts breaks the vertical monotony. This change in scroll axis signals a change in context: Vertical is for deep diving (Invoices), Horizontal is for browsing (Dashboard).
2.3 Live Activities: The Dashboard Beyond the App
The most profound shift in iOS 17/18 UX is the concept of Live Activities. This feature allows an app to project real-time data onto the Lock Screen and the Dynamic Island.24 For a contractor, the "robotic" workflow involves constantly unlocking the phone, opening the app, and refreshing to see if a payment has arrived.
Live Activities transform this "Pull" model into a "Push" model.
* Scenario: A contractor sends a high-value invoice. They toggle a "Track Payment" switch.
* The Artifact: A Live Activity appears on the Lock Screen.
   * Leading: The Client Name and Invoice ID.
   * Trailing: A pulsing status indicator ("Pending").
   * Dynamic Island: When the contractor is using other apps (e.g., Maps, Phone), the Dynamic Island shows a compact status bubble.
* The Resolution: When the payment webhook is received, the Live Activity expands to show a green checkmark and the text "PAID," then dismisses itself.
* Impact: This keeps the contractor connected to their financial status without the friction of app navigation. It turns the Dashboard into a ubiquitous companion.25
________________
3. The "Empty State" Psychology
The "robotic" feel is perhaps most damaging when the app is devoid of data. A screen that reads "No Invoices Found" or simply displays a blank white space is a UX dead end. It implies a lack of utility. In HIG philosophy, empty states are "teachable moments"opportunities to onboard, educate, and drive action.26
3.1 The Psychology of the Blank Slate
When a user first installs ContractorPro, the Invoice List is empty. This is the "Blank Slate." A robotic app treats this as a null state (Error: 0 items). A human app treats this as potential space. The anxiety of the blank page"How do I start? What goes here?"must be mitigated by design.
The Strategy: Guidance and Empathy
We must move the user from Confusion to Action.
* Illustration: Modern trends for 2025 favor high-quality, possibly 3D or abstract illustrations over generic icons.28 An illustration of a clean, organized workspace, or a metaphor for growth (a planting sprout), sets a positive tone. It visually fills the void, signaling that the space is intentionally empty, not broken.29
* Copywriting: The voice of the app must change.
   * Robotic: "No Invoices."
   * Human: "Let's Get You Paid."
* Subtext: "Create your first invoice in seconds. We'll track the payment for you." This explains the value of the action, not just the function.27
3.2 Types of Empty States
We must distinguish between different types of emptiness, as the users emotional state varies in each.
1. First Run (Onboarding): The user is new. The goal is education.
   * Action: A large, prominent button: "Create First Invoice."
2. User-Cleared (Success): The user has filtered by "Overdue," and the list is empty.
   * Context: This is a victory. The user has no debts to chase.
   * Visual: A celebration. A coffee cup, a "feet up" illustration, or even a subtle confetti animation.
   * Copy: "All caught up!" or "No overdue invoices. Great job.".31
3. No Results (Search/Filter): The user searched for "Acme," and nothing was found.
   * Action: "Clear Search" or "Create Invoice for Acme." The app should anticipate the next stepif I searched for it and its not there, maybe I want to create it.29
3.3 The "Skeleton" Loading State
A subtle but critical aspect of avoiding the "robotic" feel is the transition to the data. When the app launches, fetching data takes milliseconds or seconds. A "robotic" app shows a spinning wheel (a blocker). A "human" app shows a Skeleton Screena shimmering, gray-scale outline of the card layout.33
* Psychology: This tells the user, " The structure is here, the content is pouring in." It reduces the perceived wait time and makes the eventual appearance of data (or the empty state) feel less jarring. It maintains the visual rhythm of the list even before the list exists.
________________
4. Design System Specifications & Accessibility
To ensure the "ContractorPro" redesign is consistent, scalable, and fully native to the Apple ecosystem, a rigorous Design System must be established. This system acts as the source of truth for all UI decisions, ensuring that the "human" feel is mathematically and aesthetically consistent.
4.1 Typography System: San Francisco (SF) Pro
Apples system font, San Francisco, is designed for optimal legibility. However, the standard SF Pro can feel slightly cold or corporate. For ContractorPro, which targets independent workers who likely value a more approachable tool, we will utilize SF Pro Rounded.
Rationale: The rounded terminals of SF Pro Rounded soften the interface, subtly reinforcing the "friendly" and "human" character without sacrificing the legibility and weight hierarchy of the system font.2
UI Element
	Font Style
	Weight
	Size
	Color Token
	Invoice Amount
	SF Pro Rounded (Monospaced)
	Heavy / Black
	22pt
	label (Primary)
	Dashboard Total
	SF Pro Rounded (Monospaced)
	Heavy
	34pt
	label (Primary)
	Client Name
	SF Pro Rounded
	Semibold
	17pt
	label (Primary)
	Invoice ID
	SF Pro Text
	Medium
	13pt
	secondaryLabel
	Relative Date
	SF Pro Text
	Regular
	13pt
	tertiaryLabel
	Status Badge
	SF Pro Text
	Bold (Caps)
	11pt
	White / Contrast
	Note regarding Monospaced Digits: It is imperative to apply the .monospacedDigit() modifier to all prices and dates. This ensures that the numerals align vertically in lists and prevents character jitter during the "Rolling Number" animations.34
4.2 Color System: High Contrast & Dark Mode
The "robotic" feel often comes from using the default palette provided by UI frameworks without adaptation. To achieve the "Fintech Pro" aesthetic, we define a semantic color palette that adapts to Light and Dark modes.
The "Electric" Status Palette:
As identified in the research, we are moving away from standard traffic-light colors to high-energy hues that signal modernity.
Semantic Role
	Light Mode Hex
	Dark Mode Hex
	Usage Context
	Success / Paid
	#248A3D (Forest)
	#39FF14 (Neon Green)
	Status badges, "Paid" animations
	Warning / Overdue
	#D93600 (Burnt Orange)
	#FF3503 (Electric Orange)
	Overdue badges, urgent alerts
	Neutral / Draft
	#8E8E93 (System Gray)
	#98989D (System Gray 2)
	Drafts, secondary icons
	Brand Accent
	#007AFF (System Blue)
	#0A84FF (System Blue)
	Active tab, Primary Buttons
	Background
	#F2F2F7 (System Gray 6)
	#000000 (Pure Black)
	Main view background
	Card Surface
	#FFFFFF (White)
	#1C1C1E (Dark Gray)
	Invoice cards, Dash widgets
	Accessibility Compliance (WCAG AA):
The Neon Green (#39FF14) used in Dark Mode is extremely bright. It works exceptionally well as a background glow or an icon color against a black surface. However, white text on Neon Green fails contrast ratios.
* Correction: When using Neon Green as a badge background, the text inside MUST be black (#000000) or a very dark green. This ensures a contrast ratio > 4.5:1.12
* Light Mode: The Neon Green is too bright against a white background (low contrast). Therefore, in Light Mode, the system must swap to a darker, richer "Forest Green" (#248A3D) or use a tinted background (Light Green surface with Dark Green text).
4.3 Component Library: The "Squircle" Spec
To ensure the "card" aesthetic is consistent, we define the geometry tokens.
* Corner Radius: 12pt.
* Corner Smoothing: "Continuous" (61%).
* Shadows:
   * Light Mode: Y: 2, Blur: 8, Spread: 0, Color: Black (Opacity 8%).
   * Dark Mode: Shadows are often invisible. Instead, we rely on surface lightness. The card background (#1C1C1E) is lighter than the app background (#000000), creating elevation through contrast rather than shadow.36
________________
5. Implementation Strategy & Case Comparative
5.1 Comparative Analysis: Generic vs. ContractorPro
To validate this approach, we compare the proposed "ContractorPro" design against a generic "Robotic" competitor.
Feature
	Generic "Robotic" App
	Redesigned "ContractorPro"
	Impact
	List View
	Dense table rows, 100% width, text-heavy.
	Floating cards, visual grouping, strong typography.
	Reduced cognitive load; enhanced scannability.
	Status
	Text: "Paid", "Overdue".
	Icons: Green Check, Orange Alert. Color-coded badges.
	Pre-attentive processing; faster recognition.
	Navigation
	Hamburger menu + Back buttons.
	Bottom Tab Bar + Horizontal Dash scroll.
	improved "Thumb Zone" access; clearer hierarchy.
	Dashboard
	Static list of recent items.
	Rolling number animations, Live Activities.
	Feeling of "liveness" and system intelligence.
	Empty State
	"No Data Found."
	Illustration + "Let's Get You Paid" + CTA.
	Higher conversion from zero to one.
	5.2 Technical Implementation Roadmap (SwiftUI)
The transition to this new design system requires specific engineering tactics.
Phase 1: The Grid (Layout Refactor)
* Transition from List (which enforces system styling) to ScrollView + LazyVStack. This gives full control over card spacing, padding, and shadows.
* Implement Grid or compositional layouts for the Dashboard to allow for side-scrolling widget rows.23
Phase 2: The Pulse (Animation)
* Identify all Text views displaying financial aggregates.
* Apply .contentTransition(.numericText(value: totalRevenue)).38
* Ensure the backing data source (@State or ObservableObject) updates the value triggers the animation.
Phase 3: The Touch (Interaction)
* Replace standard buttons with ButtonStyles that implement scaleEffect on press. When a user taps a card, it should shrink slightly (to 0.98 scale), mimicking the compression of a physical button.
* Integrate UIImpactFeedbackGenerator into the View Models.
   * Success: impactOccurred(intensity: 1.0) (Mark Paid).
   * Selection: selectionChanged() (Tab switch).
Phase 4: The Reach (Live Activities)
* Develop a Widget Extension for the app.
* Define the ActivityAttributes for an invoice (Client Name, Amount, Due Date).
* Design the Dynamic Island Compact and Expanded views to ensure the status is readable at a glance.25
5.3 Conclusion
The redesign of "ContractorPro" is not merely cosmetic. It is an architectural shift rooted in the psychology of the user. By acknowledging that independent contractors view their invoices as tangible assets, we justify the move to a card-based, "Wallet-style" interface. By understanding the anxiety of financial management, we justify the "friendly" typography and encouraging empty states. By recognizing the need for speed and responsiveness, we justify the use of gestures and Live Activities.
This report provides the blueprint to move "ContractorPro" from a "cluttered, robotic" utility to a "human-centric" financial partner, leveraging the full power of the Apple Human Interface Guidelines to deliver a best-in-class iOS experience. The result is an application that doesn't just record value, but creates a feeling of value in every interaction.
Works cited
1. Blog: Designing Apple Wallet Passes: Text Alignment, Layout, and Behavior - PassNinja, accessed January 11, 2026, https://www.passninja.com/blogs/design-tips/designing-apple-wallet-passes-text-alignment-layout-and-behavior
2. San Francisco (sans-serif typeface) - Wikipedia, accessed January 11, 2026, https://en.wikipedia.org/wiki/San_Francisco_(sans-serif_typeface)
3. yell0wsuit/Apple-Fonts-Documentation - GitHub, accessed January 11, 2026, https://github.com/yell0wsuit/Apple-Fonts-Documentation
4. Lists and tables | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/lists-and-tables
5. Layout | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/layout
6. Color | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/color
7. What is the color code for iOS system labels in both light and dark mode? - Stack Overflow, accessed January 11, 2026, https://stackoverflow.com/questions/64888882/what-is-the-color-code-for-ios-system-labels-in-both-light-and-dark-mode
8. The iOS 17 Design Guidelines: An Illustrated Guide, accessed January 11, 2026, https://www.learnui.design/blog/ios-design-guidelines-templates.html
9. iOS Design | Understanding Corner radius for iOS components. : r/UI_Design - Reddit, accessed January 11, 2026, https://www.reddit.com/r/UI_Design/comments/14lwmwf/ios_design_understanding_corner_radius_for_ios/
10. What Color is Neon Green? HEX Code, Meaning & UI Designs - Mobbin, accessed January 11, 2026, https://mobbin.com/colors/meaning/neon-green
11. Neon Green - HTML Color Codes, accessed January 11, 2026, https://htmlcolorcodes.com/colors/neon-green/
12. Color | Digital Accessibility, accessed January 11, 2026, https://dap.berkeley.edu/web-a11y-basics/color
13. Electric Orange Color Palette, accessed January 11, 2026, https://www.color-hex.com/color-palette/1032994
14. Human Interface Guidelines | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines
15. Accessibility | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/accessibility
16. Handling swipe gestures | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/documentation/uikit/handling-swipe-gestures
17. Mobile Navigation Report: UX Best Practices for Financial Services Firms - Corporate Insight, accessed January 11, 2026, https://corporateinsight.com/mobile-navigation-report-ux-best-practices-for-financial-services-firms/
18. Bottom navigation bar in mobile apps: The complete 2025 guide for UI/UX designers, accessed January 11, 2026, https://blog.appmysite.com/bottom-navigation-bar-in-mobile-apps-heres-all-you-need-to-know/
19. Mobile Navigation Best Practices, Patterns & Examples (2026) - Design Studio UI/UX, accessed January 11, 2026, https://www.designstudiouiux.com/blog/mobile-navigation-ux/
20. Animating views and transitions  SwiftUI Tutorials | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions
21. Number Text Animation in SwiftUI with contentTransition - Holy Swift, accessed January 11, 2026, https://holyswift.app/how-to-animate-text-in-swiftui-using-contenttransition/
22. Animating number changes in SwiftUI - Sarunw, accessed January 11, 2026, https://sarunw.com/posts/animating-number-changes-in-swiftui/
23. Table vs List vs Cards: When to Use Each Data Display Pattern (2025), accessed January 11, 2026, https://uxpatterns.dev/pattern-guide/table-vs-list-vs-cards
24. Displaying live data with Live Activities | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities
25. Live Activities | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/live-activities/
26. Writing | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/writing
27. Empty State UI design: From zero to app engagement - Setproduct, accessed January 11, 2026, https://www.setproduct.com/blog/empty-state-ui-design
28. UI/UX Design Trends in Mobile Apps for 2025 | Chop Dawg, accessed January 11, 2026, https://www.chopdawg.com/ui-ux-design-trends-in-mobile-apps-for-2025/
29. Empty States - HIG, accessed January 11, 2026, https://hig.concur.com/pages/design/web/patterns/empty-states.html
30. Empty State UX Examples & Best Practices - Pencil & Paper, accessed January 11, 2026, https://www.pencilandpaper.io/articles/empty-states
31. Things - To-Do List App for Mac & iOS, accessed January 11, 2026, https://www.culturedcode.com/
32. Empty states - Intuit Content Design System, accessed January 11, 2026, https://contentdesign.intuit.com/product-and-ui/empty-states/
33. Loading | Apple Developer Documentation, accessed January 11, 2026, https://developer.apple.com/design/human-interface-guidelines/loading
34. Fonts - Apple Developer, accessed January 11, 2026, https://developer.apple.com/fonts/
35. Making Color Usage Accessible | Section508.gov, accessed January 11, 2026, https://www.section508.gov/create/making-color-usage-accessible/
36. Dark theme - Material Design, accessed January 11, 2026, https://m2.material.io/design/color/dark-theme.html
37. Edit and organize a list in Reminders on iPhone - Apple Support, accessed January 11, 2026, https://support.apple.com/guide/iphone/edit-and-organize-a-list-iph82596cb20/ios
38. Animating numeric text in SwiftUI with the Content Transition modifier - Create with Swift, accessed January 11, 2026, https://www.createwithswift.com/animating-numeric-text-in-swiftui-with-the-content-transition-modifier/

=================================================================================
FILE: ./docs/product-strategy.md
=================================================================================

Strategic Product Roadmap: ContractorPro  The Solo Contractor Operating System
Executive Summary: Defining the "Missing Middle" in Construction Technology
The market for construction and field service management software is bifurcated into two distinct poles that fail to serve the solo independent contractor. On one end of the spectrum lie the "Enterprise Resource Planning (ERP) Lite" solutions such as Jobber, ServiceTitan, and to a lesser extent, Joist and QuickBooks. These platforms are engineered for scale: they excel at managing crews, dispatching fleets, reconciling complex payrolls, and handling inventory across multiple warehouses.1 For the solo operatorthe "one-man-band" painter, the independent handyman, or the owner-operator landscaperthese tools impose a heavy cognitive tax. The complexity of "10,000 tabs," as one user described QuickBooks, creates friction that turns administrative tasks into unpaid labor performed during late-night hours, contributing to burnout and procrastination.2
On the opposite pole lies the informal economy of peer-to-peer (P2P) payment apps like Venmo, Cash App, and Zelle. These platforms offer the "Flow" that solo contractors crave: instant speed, zero friction, and mobile-first ubiquity. However, they suffer from a fatal flaw in a professional context: the lack of a "Trust Artifact." A Venmo request provides no breakdown of labor versus materials, no professional branding, and no legal record of the transaction, which erodes homeowner trust and limits the contractors ability to command premium rates.4
ContractorPro aims to capture the "Missing Middle"a serviceable addressable market of solo trade contractors who require the transactional speed of Venmo but the professional output of an ERP. The goal of achieving $50,000 in Monthly Recurring Revenue (MRR) at a $20/month price point requires acquiring and retaining approximately 2,500 active users. This report argues that the path to this metric lies not in competing on feature density (e.g., inventory management or scheduling), but in competing on Time to Invoice and Revenue Recovery.
The strategic analysis that follows identifies three critical pillars for success. First, the User Experience (UX) must decouple the input mechanism (Voice/Flow) from the output artifact (PDF/Form), using Progressive Disclosure to mask complexity. Second, the market entry strategy must be fundamentally Tri-Lingual (English, Spanish, Portuguese), treating language support not as a setting but as a core architectural feature to capture the 32%+ Hispanic workforce that is currently underserved by "Anglocentric" software design.7 Third, the retention mechanism must shift from passive tool utility to active value generation, utilizing a "Bad Cop" automated bot to solve the awkward and expensive problem of debt collection, which plagues solo operators who fear damaging client relationships.9
________________
1. The UX Battle: "Form" vs. "Flow"
The central tension in designing for the solo contractor is the conflict between the mental model of accounting (which requires structure, categorization, and detail) and the mental model of fieldwork (which requires speed, mobility, and simplicity). Existing solutions force the contractor to adopt the accounting mindset while on the job site, a context switch that is cognitively expensive and prone to error.
1.1 The Cognitive Load of the Document-First Model
Current market leaders operate on a Document-First Model. In this paradigm, the user's primary interaction is with a digital representation of a paper form. To get paid, a user on Jobber or QuickBooks must essentially instantiate a document object (an invoice), navigate through multiple fields (Customer, Date, Terms, Line Items, Tax Rates, Notes), and populate them via a keyboard interface.1
Research into user sentiment reveals that for the solo contractor, this model is fundamentally misaligned with their workflow. The "Sunday Night Admin" phenomenonwhere contractors save all paperwork for the weekend because the software is too cumbersome to use in the truckis a direct symptom of this UX failure. When a carpenter finishes a job at 4:00 PM, their hands are dirty, the lighting is harsh, and their mental focus is on packing up tools, not navigating a "Create Invoice" wizard with mandatory fields.10
The friction is not just physical; it is psychological. The Document-First model presents the invoice as a chore to be completed. Every empty field on the screen represents a task. For a user base that identifies as tradespeople first and business owners second, this interface feels like "playing office" rather than "getting paid."
1.2 The "Venmo-ification" of B2B: The Person-First Model
In contrast, the Person-First Model (or "Flow" model), typified by Venmo, centers the interaction on the relationship and the transaction. The user selects a person (Who) and an amount (How Much), and the context (For What) is appended as a secondary, unstructured note. This aligns perfectly with the solo contractor's mental model: "I need to collect $500 from Mrs. Johnson for the deck repair."
The "Flow" model reduces the Time to Invoice from minutes to seconds. However, simply cloning Venmo is insufficient for high-ticket B2B transactions (like a $5,000 bathroom remodel). Homeowners require a "Trust Artifact"a professional invoiceto justify the expenditure, validate the work scope against the bid, and serve as a receipt for their own records or insurance.12 A raw payment link sent via text message, without the accompanying artifact, triggers "scam" heuristics in consumers conditioned to be wary of smishing (SMS phishing) attacks.5
1.3 Progressive Disclosure and the "Invisible Invoice"
To reconcile the speed of Flow with the necessity of Form, ContractorPro must utilize Progressive Disclosure to create an "Invisible Invoice." The UX should mimic a chat interface or a simple command prompt, hiding the complexity of the invoice document until it is necessary to show it.
Table 1: The Progressive Disclosure Architecture
UX Stage
	Contractor Action (Input)
	System Action (Processing)
	Client Experience (Output)
	Level 1: The Flow
	Select Contact + Voice Note + Amount ("Bill Sarah $400 for painting the trim")
	NLP parses intent, identifies client, extracts amount, and generates line item description.
	N/A (Internal processing)
	Level 2: The Logic
	User taps "Review"
	System applies default tax rates, net-30 terms, and branding. Generates PDF in background.
	N/A
	Level 3: The Verdict
	User sees a simple card: "Send Invoice #104 to Sarah for $400?"
	System generates a unique, secure payment link (pay.contractorpro.com/invoice_id).
	N/A
	Level 4: The Artifact
	User taps "Send Text"
	App opens native SMS/WhatsApp with pre-filled message + Link.
	Client receives text: "Hi Sarah, here's the invoice..." + Link unfurls to show branded portal.
	This architecture allows the contractor to exist entirely in the "Flow" state while the system handles the "Form" requirements. The risk of looking "too casual" is mitigated because the artifact the client receives is identical to one generated by a desktop accountant sitting in an office. The casualness of the input method (voice/text) is decoupled from the professionalism of the output.15
1.4 Addressing the "Too Casual" Risk: Trust Signals
The primary adoption barrier for a "text-to-pay" solution in the home services market is consumer trust. With 66% of consumers expressing interest in paying by text but also high anxiety around fraud, the UX must over-index on legitimacy signals.5
The "Too Casual" risk manifests when a contractor sends a bare link from a personal number. To combat this, ContractorPro must enforce a Trust Wrapper around the payment link:
1. Domain Consistency: The link must resolve to a subdomain that clearly identifies the business (e.g., mikes-painting.contractorpro.com or pay.mikespainting.com via CNAME). Generic short-links (e.g., bit.ly) are red flags for security-conscious homeowners.5
2. The "Bridge" Message: The pre-filled text message must include context that only the contractor would know, bridging the gap between the physical service and the digital request. A template like "Hi [Name], thanks for letting me fix the today. Here is the invoice..." is far superior to a generic "You have a bill due" message.16
3. PDF Attachment Strategy: While the link is for payment, attaching the generated PDF to the text (or email) serves as the "Proof of Work." It legitimizes the request. The PDF acts as the "suit and tie" of the transaction, even if the payment mechanism is as casual as a text.12
________________
2. The Tri-Lingual Market Strategy
The demographics of the US construction workforce are shifting rapidly, presenting a massive, under-capitalized opportunity. Hispanic workers now comprise 32% of the construction labor force, with participation rates climbing steadily.7 In specific trades like drywall, painting, and concrete, this figure often exceeds 50%. Additionally, the Portuguese-speaking Brazilian contractor community represents a distinct, high-value niche, particularly in the Northeast and Florida markets.
2.1 The "Spanglish" Reality and Competitor Gaps
Current software incumbents treat localization as a binary interface setting: the app is either in English or Spanish. This fails to address the Asymmetric Linguistic Reality of the solo contractor market.
* The Contractor: Often speaks Spanish or Portuguese as a first language and prefers it for complex cognitive tasks like app navigation or support.
* The Client (Homeowner): Typically expects communication and documentation in English.
* The Gap: A contractor using QuickBooks in Spanish mode might inadvertently generate Spanish-language invoices or emails, creating a friction point with English-speaking clients. Conversely, forcing the contractor to use an English interface leads to errors and frustration ("What is 'Accounts Receivable'?").
The "Tri-Lingual" strategy for ContractorPro is not just about translating buttons; it is about building a Bi-Directional Translation Engine. The app must allow the user to input data in their native tongue (Spanish/Portuguese) while outputting professional, localized English documents for the client.20
2.2 Willingness to Pay: Speed vs. Translation vs. Legitimacy
Understanding the "Willingness to Pay" (WTP) for this demographic requires analyzing their specific pain points.
* Legitimacy as a Service: Many immigrant entrepreneurs struggle with the stigma of being perceived as "informal" or "unlicensed" labor. Software that produces high-fidelity, grammatically perfect English invoices acts as a shield of legitimacy. They are willing to pay a premium for tools that make them look like established, "American" businesses.22
* Fear of Miscommunication: Language barriers are a primary source of anxiety, leading to under-bidding (because they cannot articulate value) or scope creep (because they cannot clearly define limits).8 A tool that guarantees their scope of work is communicated accurately in English has a direct ROIit prevents lost revenue.
* Speed: While speed is valuable, confidence is the higher value driver here. A Spanish-speaking contractor will sacrifice speed for the certainty that they aren't making an embarrassing mistake in an English invoice.
2.3 The Portuguese Niche: A Strategic Wedge
While the Hispanic market is larger, the Brazilian contractor market is a tighter, more networked community. Word-of-mouth travels fast in WhatsApp groups, which are the primary digital town squares for these demographics.24 By offering native Portuguese supportsomething often ignored by major players like JobberContractorPro can use this niche as a Market Entry Wedge. Capturing the Brazilian painting or flooring community in a specific hub (e.g., Boston or Framingham, MA) can provide the initial traction needed to validate the product before attacking the broader Hispanic market.
Table 2: Linguistic Value Propositions
Feature
	English Speaker Value Prop
	Spanish/Portuguese Speaker Value Prop
	Voice Input
	"Save time typing."
	"Don't worry about spelling/grammar in English."
	Professional PDF
	"Look organized."
	"Look like a legitimate, established US business."
	Automated Reminders
	"Avoid awkward conversations."
	"Avoid language barrier friction in collections."
	Support
	"Help me fix a bug."
	"Understand my business context in my language."
	________________
3. The "Killer Feature" Analysis
To achieve $50,000 MRR, ContractorPro needs approximately 2,500 paying users at $20/month. To prevent churn and justify this cost against free alternatives (Excel, Notes app), the app must solve a problem that is "expensive" in terms of time, money, or emotion. We analyze three candidates: The Universal Translator, The "Bad Cop" Bot, and The Voice Engine.
3.1 Candidate A: The Universal Translator (The Wedge)
* The Mechanism: An AI layer that takes voice/text input in Spanish/Portuguese and generates English invoice line items.
* The Value: Solves the "Language Barrier" which causes lost bids and scope creep. It unlocks revenue by allowing non-native speakers to bid on complex jobs for English-speaking clients.23
* The Limitation: It is a "feature," not a platform. As the contractor's English improves, or if they hire a bilingual admin, the utility degrades. It is a powerful acquisition tool but potentially weak for long-term retention for all segments (e.g., native English speakers don't need it).
3.2 Candidate B: The Voice Engine (The Enabler)
* The Mechanism: "Siri for Contractors." Utilizing Large Language Models (LLMs) to parse unstructured voice data ("Invoice Mike $500 for the fence") into structured data.
* The Value: Solves the "Fat Finger" problem. Data entry on mobile devices is the #1 friction point for field workers.26 It enables the "Flow" UX.
* The Limitation: Voice interfaces have high failure rates due to background noise (job sites), accents, and connectivity issues. If it fails twice, trust is lost. It is a "Hygiene Factor"necessary for the UX to work, but perhaps not the thing they explicitly pay for.
3.3 Candidate C: The "Bad Cop" Bot (The Revenue Defender)
* The Mechanism: An automated sequence of SMS/Email reminders that chases unpaid invoices on behalf of the contractor. "Hi, this is ContractorPro automated billing. Invoice #102 is 3 days overdue..."
* The Value: Solves the Emotional Cost of Debt Collection. Solo contractors often operate on a "Good Cop" persona to win referrals and avoid conflict. They dread playing "Bad Cop" to collect money, often letting invoices slide for weeks to avoid "ruining the vibe".9
* The ROI: This feature has the clearest Return on Investment. If the bot recovers one $500 invoice that would have otherwise slipped through the cracks, it pays for two years of the subscription.28 The "Bad Cop" bot depersonalizes the conflict"The software sent the reminder, not me"allowing the contractor to maintain their friendly relationship while getting paid.
Design Verdict: The "Bad Cop" Bot is the Killer Feature. It is the feature that directly justifies the subscription model because it puts hard dollars back into the user's bank account. The Voice Engine is the User Interface required to make the app usable in the field, and the Universal Translator is the Market Entry Strategy for the specific demographic, but the "Bad Cop" is the retention anchor.
________________
4. The Execution: "Text-to-Pay" & Trust
Implementing the "Text-to-Pay" flow requires a sophisticated technical strategy to balance cost, trust, and platform limitations.
4.1 Native iMessage vs. Twilio (The Technical Dilemma)
Native SMS (React Native Expo-SMS)
* Mechanism: The app generates the text and opens the user's default SMS app. The user hits "Send."
* Pros: Trust. The message comes from the contractor's personal phone number, which the client already recognizes and trusts. Cost. Free (uses the user's carrier plan). Deliverability. No carrier filtering or A2P 10DLC registration required.30
* Cons: No Automation. The user must physically tap "Send" for every message. This breaks the "Bad Cop" bot functionality, as background SMS sending is restricted on iOS and Android for security reasons.31
Twilio / A2P 10DLC
* Mechanism: The app sends the message via API from a cloud-hosted number.
* Pros: Automation. Enables "Set it and forget it" reminders (The Bad Cop). Scalability. Can send blasts/marketing messages.
* Cons: Trust Gap. Messages come from a random 10-digit number or shortcode, looking like spam. Cost. A2P 10DLC registration fees ($4-$50 one-time) plus monthly campaign fees ($2-$10/mo) and per-segment costs ($0.0083) erode margins on a $20/mo product.32 Regulation. Getting a solo contractor verified for A2P 10DLC is a friction-heavy onboarding process involving EIN verification and "Brand" registration.
The Hybrid Execution Strategy:
To solve this, ContractorPro must adopt a Hybrid Messaging Architecture:
1. Initial Invoice (Native): The first invoice is always sent via Native SMS. This leverages the existing trust relationship ("It's me, Jose") and establishes the digital thread. The contractor taps "Send" manually.
2. Reminders (Twilio/Email): The "Bad Cop" automated follow-ups are sent via Twilio (SMS) or Email. Because the homeowner has already received the initial link from the trusted number, the subsequent automated reminder from the "System" is less likely to be viewed as spam. The reminder text should reference the contractor explicitly: "This is an automated reminder for the invoice sent by [Contractor Name]...".27
4.2 Homeowner Trust in Links
With "smishing" on the rise, homeowners are trained to ignore unsolicited links.
* Link Previews: The application must ensure that the payment link unfurls into a rich "Open Graph" preview card in iMessage/WhatsApp. This card should display the Contractor's Logo, the Invoice Amount, and the Job Title. A rich card is a high-trust signal; a raw bit.ly link is a low-trust signal.16
* The "Double Tap" Verification: For high-value invoices, the system should encourage sending an email parallel to the text. "I just texted you the link, and also emailed the PDF for your records." This triangulation confirms legitimacy.
4.3 WhatsApp Bridge for the Tri-Lingual Market
For the Hispanic and Brazilian market, WhatsApp is the primary communication channel.35 Unlike SMS, WhatsApp Business API allows for verified business profiles (Green Tick), which massively increases trust.
* Architecture: Integration with a provider like Twilio's WhatsApp API or a dedicated bridge (e.g., 360dialog) is essential.
* Cost: WhatsApp moves to a per-conversation pricing model (or per-template message in 2025).37 This is more expensive than SMS.
* Strategy: For the $20/mo tier, simple "Click to Chat" (generating a wa.me link that opens the user's native WhatsApp) is the MVP solution. It mimics the "Native SMS" approach but for WhatsApp, avoiding API costs while retaining the "Flow."
________________
5. The "Churn" Stress Test
The solo contractor market is notorious for high churn. Understanding the specific mechanics of why they leave is crucial for survival.
5.1 The "Graduation" Risk to QuickBooks
The conventional wisdom is that successful businesses "graduate" to QuickBooks. Research indicates this switch is driven by two specific triggers: Payroll and Accountant Pressure.2 When a solo contractor hires their first W-2 employee, they need payroll compliance. When they reach a certain revenue, their CPA demands QuickBooks access.
* The Solo-Only Strategy: ContractorPro must not fight this. Instead, it must position itself as the "Field Operating System" that feeds QuickBooks. QuickBooks is terrible at field operations (clunky mobile app, hard to use for quick estimates).
* The Defense: Build a "One-Click Sync to QuickBooks" feature. The narrative becomes: "Use ContractorPro to run your day, use QuickBooks to run your tax return." This retains the user even as they grow, converting them from a "Solo" user to an "Integrated" user.39
5.2 Seasonality and "Pause" Churn
Landscapers and painters have distinct off-seasons (winter). Users will cancel to save $20/mo during these months.
* The "Parking" Mode: Instead of cancellation, offer a "Parking Mode" for $5/mo. This keeps their data (client list, invoice history) safe and accessible in read-only mode. It reduces the friction of returning in the Spring.
* Lead Reactivation (Off-Season Value): To prevent pausing, the app must provide off-season value. A "Marketing Blast" feature allows the contractor to text all past clients in March: "Booking spring cleanups now." This turns the app from a cost center (billing) into a revenue generator (marketing) right when they need it most.41
5.3 Failure Rate
The highest churn cause is business failure. Solo contractors fail due to cash flow gaps.
* The Counter: The "Bad Cop" bot is the antidote to failure. By automating collections, the app actively prevents the cash flow crunches that kill young businesses. Marketing the app as a "Cash Flow Engine" rather than an "Invoice Maker" aligns the product with the user's survival.
________________
6. Golden Path User Journey
Persona: "Mateo," a solo painter. Native Portuguese speaker, speaks "Trade English" with clients. Hates typing on his phone.
1. The Trigger: Mateo finishes painting a client's living room. He is walking to his truck, hands covered in paint dust.
2. The Input (Flow/Voice): He opens ContractorPro. He taps the large microphone button.
   * Mateo (in Portuguese): "Mandar fatura para a Sarah. Quatrocentos e cinquenta dlares pela pintura da sala e cinquenta de materiais." ("Send invoice to Sarah. $450 for painting the room and $50 for materials.")
3. The Processing (AI/Translation):
   * The app identifies "Sarah" from his contact list.
   * It parses the intent: Invoice.
   * It uses the Universal Translator to convert the Portuguese audio into structured English line items: "Interior Painting Services ($450.00)" and "Materials & Supplies ($50.00)."
4. The Review (Progressive Disclosure):
   * A simple card appears on the screen: Invoice for Sarah. Total: $500.00.
   * Mateo taps "Preview." He sees the English PDF. It looks professional. He taps "Approve."
5. The Delivery (Native Trust):
   * The app opens his native WhatsApp (since Sarah is a WhatsApp contact).
   * It pre-fills a message in English: "Hi Sarah, thanks for the business! Here is the invoice for the living room. You can pay securely via this link." +.
   * Mateo hits "Send."
6. The Payment (Trust Signals):
   * Sarah clicks the link. She lands on mateo-painting.contractorpro.com. She sees Mateo's logo and license number. She pays via Apple Pay.
7. The "Bad Cop" (Automation):
   * Alternative Ending: If Sarah hadn't paid in 3 days, the ContractorPro "Bad Cop" bot would have sent a polite email/SMS reminder automatically, saving Mateo the awkwardness of asking.
________________
7. MVP Feature Cut
To validate the $20/mo price point, the MVP must deliver the "Killer Feature" loop immediately.
P0: The "Must Haves" (Launch)
* Voice-to-Invoice Engine: Support for English, Spanish, and Portuguese input.
* Native Share Sheet Integration: Generate a unique payment link and hand it off to iOS/Android Messages or WhatsApp.
* Professional PDF Generator: One high-quality template that looks "enterprise."
* Stripe/Payment Integration: Instant digital payments (pass-through fees).
* Basic "Bad Cop" Logic: Manual trigger for reminders ("Tap to Remind") if automation is too complex for MVP, or simple email-only automation.
P1: The "Retention" Layer (Month 3)
* Fully Automated "Bad Cop" Bot: Background SMS/Email reminders via Twilio/SendGrid.
* Universal Translator "Pro": Enhanced vocabulary for specific trades (e.g., plumbing parts).
* QuickBooks Export: CSV export or basic API sync to defend against graduation.
P2: The "Growth" Layer (Month 6)
* Marketing Blasts: "Reactivate old clients" feature.
* Expense Scanning: OCR for receipts.
The "Anti-Roadmap" (Do Not Build)
* Scheduling/Dispatch: Too complex, Google Calendar is sufficient for solos.43
* Inventory Management: Solo contractors buy-to-order; they don't manage warehouses.44
* Payroll: Regulatory nightmare. Leave this to QuickBooks/Gusto.
________________
8. Design Verdict
The Strategic Positioning:
ContractorPro should not position itself as "Accounting Software." It is a "Field Operating System." Its job is to capture the chaos of the field (Voice, Multi-lingual) and convert it into the order of the office (PDFs, English, Payments).
The $50k MRR Formula:
* Acquisition: Driven by the Tri-Lingual Wedge in underserved communities (Word of Mouth in WhatsApp groups).
* Conversion: Driven by the Flow UX (it's faster than typing).
* Retention: Driven by the "Bad Cop" Bot (it recovers money).
Final Verdict:
Build the "Flow" interface. Treat the invoice not as a document to be edited, but as a byproduct of a conversation. By solving the emotional friction of collections ("Bad Cop") and the cognitive friction of data entry ("Voice"), ContractorPro can successfully displace the "Venmo/Text" behavior while avoiding the "QuickBooks/Jobber" bloat. The "Tri-Lingual" capability is the secret weapon that protects the app from commoditization, creating a deep moat in the fastest-growing segment of the US economy.
Works cited
1. Software : r/handyman - Reddit, accessed January 11, 2026, https://www.reddit.com/r/handyman/comments/1cdpqmx/software/
2. estimating and accounting software. What are you guys using? : r/Carpentry - Reddit, accessed January 11, 2026, https://www.reddit.com/r/Carpentry/comments/10pyzri/estimating_and_accounting_software_what_are_you/
3. Jobber vs. QuickBooks: How Are They Different?, accessed January 11, 2026, https://www.getjobber.com/comparison/jobber-vs-quickbooks/
4. Invoice Question : r/handyman - Reddit, accessed January 11, 2026, https://www.reddit.com/r/handyman/comments/17aqnz8/invoice_question/
5. Technology and scam tactics are changing fast. - Consumers Energy, accessed January 11, 2026, https://www.consumersenergy.com/-/media/CE/Documents/outages-and-safety/2024-Scams-Brochure-Web-Email_4pgs_4x8-5_R_F4100-10-24.pdf
6. 5 Common Venmo Business Account Scams - Keeper Security, accessed January 11, 2026, https://www.keepersecurity.com/blog/2024/08/05/venmo-business-account-scams/
7. How Diverse Is the Construction Workforce? | NAHB, accessed January 11, 2026, https://www.nahb.org/blog/2025/10/diversity-of-construction-workforce
8. Construction's language disconnect creates safety risk, accessed January 11, 2026, https://www.constructiondive.com/news/spanish-language-safety-construction-communication/758886/
9. I just finished my 2025 "Post-Mortem." I realized I lost over $3k because I'm too socially awkward to chase invoices. : r/smallbusiness - Reddit, accessed January 11, 2026, https://www.reddit.com/r/smallbusiness/comments/1q1w9eq/i_just_finished_my_2025_postmortem_i_realized_i/
10. What software do you use for estimates and accepting payments in 2024? : r/handyman, accessed January 11, 2026, https://www.reddit.com/r/handyman/comments/1b11o5k/what_software_do_you_use_for_estimates_and/
11. Solo and small crew builder takeoff, estimating, and bidding. Are weekends just not a thing anymore? : r/Contractor - Reddit, accessed January 11, 2026, https://www.reddit.com/r/Contractor/comments/1ncqixy/solo_and_small_crew_builder_takeoff_estimating/
12. The True Cost of Delayed Construction Payments Across Your Business, accessed January 11, 2026, https://www.foundationsoft.com/learn/the-true-cost-of-delayed-construction-payments-across-your-business/
13. Cul es el mejor software o app para facturas? : r/smallbusiness - Reddit, accessed January 11, 2026, https://www.reddit.com/r/smallbusiness/comments/1h1gykj/best_invoice_software_or_app/?tl=es-419
14. Phishers send fake invoices | Consumer Advice - Federal Trade Commission, accessed January 11, 2026, https://consumer.ftc.gov/consumer-alerts/2018/02/phishers-send-fake-invoices
15. 15 SMS Invoice Templates to Get You Paid On Time - Textedly, accessed January 11, 2026, https://www.textedly.com/blog/sms-invoice-templates
16. How to Send an Invoice by Text Message - Thryv, accessed January 11, 2026, https://www.thryv.com/blog/benefits-text-message-invoicing/
17. Take Advantage of Fast, Frictionless Text Payments - Paymentus, accessed January 11, 2026, https://www.paymentus.com/industry-insights/taking-advantage-of-fast-frictionless-text-payments/
18. How to Send Invoices Using Text Messages - Falkon SMS, accessed January 11, 2026, https://www.falkonsms.com/post/sms-invoice
19. Hispanics Comprise 31% of the Construction Workforce - Eye On Housing, accessed January 11, 2026, https://eyeonhousing.org/2024/06/hispanics-comprise-31-of-the-construction-workforce/
20. How to Invoice in Spanish - SumUp, accessed January 11, 2026, https://www.sumup.com/en-us/invoices/invoicing-essentials/how-to-invoice-in-spanish/
21. Multi-language invoicing & estimates - FreeAgent, accessed January 11, 2026, https://www.freeagent.com/blog/multi-language-invoicing-and-estimates/
22. 2025 STATE OF HISPANICS IN CONSTRUCTION REPORT, accessed January 11, 2026, https://nhca.pro/downloads/2025-NHCA-State-of-Hispanics-in-Construction-Report.pdf
23. Saving Time and Money by Demolishing Language Barriers in the Construction Industry, accessed January 11, 2026, https://www.languagetesting.com/blog/saving-time-and-money-by-demolishing-language-barriers-in-construction-industry/
24. Why WhatsApp Isn't Built for Construction (And What To Use Instead) - SymTerra, accessed January 11, 2026, https://www.symterra.co.uk/blog/why-whatsapp-isnt-built-for-construction-and-what-to-use-instead
25. Breaking Language Barriers in Construction: The Impact of Lumber Time Tracking App, accessed January 11, 2026, https://www.lumberfi.com/blog/breaking-language-barriers-in-construction-the-impact-of-lumber-time-tracking-app
26. Benetics Launches Voice Assistant for Construction Reporting **Join Our Beta Test!, accessed January 11, 2026, https://www.benetics.ai/en/blog/benetics-launches-voice-assistant-for-construction-site
27. Chasing Down Money: 6 Strategies For Overdue Payments - Mixing Light, accessed January 11, 2026, https://mixinglight.com/color-grading-tutorials/chasing-down-money-6-strategies-for-overdue-payments/
28. Late Invoice Statistics 2025: How Common Are Late Invoice Payments? - Clockify, accessed January 11, 2026, https://clockify.me/late-invoice-statistics
29. The 2022 late payments report - Chaser, accessed January 11, 2026, https://www.chaserhq.com/the-2022-late-payments-report
30. Is there a particular reason why sending message in background is not supported?  Issue #72  tkporter/react-native-sms - GitHub, accessed January 11, 2026, https://github.com/tkporter/react-native-sms/issues/72
31. Sending SMS in the background : r/reactnative - Reddit, accessed January 11, 2026, https://www.reddit.com/r/reactnative/comments/p9zhtv/sending_sms_in_the_background/
32. What pricing and fees are associated with the A2P 10DLC service? - Twilio Help Center, accessed January 11, 2026, https://help.twilio.com/articles/1260803965530-What-pricing-and-fees-are-associated-with-the-A2P-10DLC-service-
33. SMS Pricing in United States for Text Messaging | Twilio, accessed January 11, 2026, https://www.twilio.com/en-us/sms/pricing/us
34. Examples of How to Write a Payment Reminder Email to a Client - Square, accessed January 11, 2026, https://squareup.com/us/en/the-bottom-line/reaching-customers/payment-reminder-message
35. WhatsApp User Statistics 2026: How Many People Use WhatsApp? - Backlinko, accessed January 11, 2026, https://backlinko.com/whatsapp-users
36. WhatsApp in the U.S.: Stats, users & business trends (2025) Sinch -, accessed January 11, 2026, https://sinch.com/blog/whatsapp-in-the-us-potential/
37. Notice: Changes to WhatsApp's Pricing (July 2025) - Twilio Help Center, accessed January 11, 2026, https://help.twilio.com/articles/30304057900699-Notice-Changes-to-WhatsApp-s-Pricing-July-2025
38. WhatsApp Business API Pricing - SleekFlow Help Center, accessed January 11, 2026, https://help.sleekflow.io/whatsapp/pricing
39. Jobber vs Quickbooks - Fondo, accessed January 11, 2026, https://www.fondo.com/blog/jobber-vs-quickbooks
40. How Items Sync Between Jobber and QuickBooks Online, accessed January 11, 2026, https://help.getjobber.com/hc/en-us/articles/115009786748-How-Items-Sync-Between-Jobber-and-QuickBooks-Online
41. Hispanic Marketing Solutions: Language, Search, Content, Social, accessed January 11, 2026, https://www.hispanicmarketadvisors.com/
42. Marketing Digital en Espaol | Spanish Services, accessed January 11, 2026, https://www.empowereddigitalmarketingco.com/marketing-digital-en-espanol
43. Jobber vs. QuickBooks vs. OneCrew in 2026, accessed January 11, 2026, https://www.getonecrew.com/post/jobber-vs-quickbooks
44. Construction Inventory Software | Control Costs & Waste, accessed January 11, 2026, https://www.foundationsoft.com/software/inventory-management/
45. Construction Inventory Management: Contractor's Guide - ServiceTitan, accessed January 11, 2026, https://www.servicetitan.com/blog/construction-inventory-management

=================================================================================
FILE: ./global.css
=================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;


=================================================================================
FILE: ./lib/constants.ts
=================================================================================

export const COLORS = {
  primary: "#00D632", // Electric Green - Action/Money
  alert: "#FF9500", // Orange - Unpaid/Warning
  background: {
    light: "#FFFFFF",
    dark: "#000000",
  },
  text: {
    primary: "#000000",
    secondary: "#666666",
    light: "#999999",
    inverse: "#FFFFFF",
  },
  border: "#E5E5E5",
  success: "#00D632",
  error: "#FF3B30",
};

export const INVOICE_PREFIX = "INV-";

export const DEFAULT_TAX_RATE = 0;

export const CURRENCY = "USD";

export const CURRENCY_SYMBOL = "$";


=================================================================================
FILE: ./lib/supabase.ts
=================================================================================

// Re-export supabase client from services
// This allows imports from both @/lib/supabase and @/services/supabase
export { supabase, type Database } from "@/services/supabase";


=================================================================================
FILE: ./lib/theme.tsx
=================================================================================

import { createContext, useContext, useState, ReactNode } from "react";
import { useColorScheme } from "react-native";

/**
 * Theme Configuration
 * Per design-system.md Section 4.2
 */

export const colors = {
  light: {
    primary: "#00D632",
    primaryDark: "#00B82B",

    // Status colors per design-system.md
    statusPaid: "#248A3D",      // Forest Green (Light Mode)
    statusOverdue: "#D93600",   // Burnt Orange (Light Mode)
    statusSent: "#007AFF",      // System Blue
    statusDraft: "#8E8E93",     // System Gray

    alert: "#FF9500",
    error: "#FF3B30",
    success: "#34C759",

    background: "#F2F2F7",
    backgroundSecondary: "#FFFFFF",
    backgroundTertiary: "#F8F9FA",

    text: "#000000",
    textSecondary: "#3C3C43",
    textTertiary: "#8E8E93",
    textInverse: "#FFFFFF",

    border: "rgba(0, 0, 0, 0.08)",
    borderLight: "rgba(0, 0, 0, 0.04)",

    card: "#FFFFFF",
    cardElevated: "#FFFFFF",

    shadow: "#000000",
    overlay: "rgba(0, 0, 0, 0.5)",
  },
  dark: {
    primary: "#00D632",
    primaryDark: "#00FF41",

    // Status colors per design-system.md (Electric/Neon for Dark Mode)
    statusPaid: "#39FF14",      // Neon Green (Dark Mode)
    statusOverdue: "#FF3503",   // Electric Orange (Dark Mode)
    statusSent: "#0A84FF",      // System Blue
    statusDraft: "#98989D",     // System Gray 2

    alert: "#FF9F0A",
    error: "#FF453A",
    success: "#32D74B",

    background: "#000000",
    backgroundSecondary: "#1C1C1E",
    backgroundTertiary: "#2C2C2E",

    text: "#FFFFFF",
    textSecondary: "#EBEBF5",
    textTertiary: "#8E8E93",
    textInverse: "#000000",

    border: "rgba(255, 255, 255, 0.1)",
    borderLight: "rgba(255, 255, 255, 0.05)",

    card: "#1C1C1E",
    cardElevated: "#2C2C2E",

    shadow: "#000000",
    overlay: "rgba(0, 0, 0, 0.7)",
  },
};

/**
 * Typography per design-system.md Section 4.1
 * SF Pro Rounded styles
 */
export const typography = {
  largeTitle: {
    fontSize: 34,
    fontWeight: "700" as const,
    letterSpacing: 0.37,
    lineHeight: 41,
  },
  title1: {
    fontSize: 28,
    fontWeight: "700" as const,
    letterSpacing: 0.36,
    lineHeight: 34,
  },
  title2: {
    fontSize: 22,
    fontWeight: "700" as const,
    letterSpacing: 0.35,
    lineHeight: 28,
  },
  title3: {
    fontSize: 20,
    fontWeight: "600" as const,
    letterSpacing: 0.38,
    lineHeight: 25,
  },
  headline: {
    fontSize: 17,
    fontWeight: "600" as const,
    letterSpacing: -0.41,
    lineHeight: 22,
  },
  body: {
    fontSize: 17,
    fontWeight: "400" as const,
    letterSpacing: -0.41,
    lineHeight: 22,
  },
  callout: {
    fontSize: 16,
    fontWeight: "400" as const,
    letterSpacing: -0.32,
    lineHeight: 21,
  },
  subhead: {
    fontSize: 15,
    fontWeight: "400" as const,
    letterSpacing: -0.24,
    lineHeight: 20,
  },
  footnote: {
    fontSize: 13,
    fontWeight: "400" as const,
    letterSpacing: -0.08,
    lineHeight: 18,
  },
  caption1: {
    fontSize: 12,
    fontWeight: "400" as const,
    letterSpacing: 0,
    lineHeight: 16,
  },
  caption2: {
    fontSize: 11,
    fontWeight: "400" as const,
    letterSpacing: 0.07,
    lineHeight: 13,
  },
  // Invoice Amount - Primary Field per design-system.md
  invoiceAmount: {
    fontSize: 22,
    fontWeight: "800" as const,
    letterSpacing: -0.5,
    lineHeight: 28,
  },
  // Dashboard Amount
  amount: {
    fontSize: 44,
    fontWeight: "700" as const,
    letterSpacing: -1,
    lineHeight: 52,
  },
  amountSmall: {
    fontSize: 28,
    fontWeight: "700" as const,
    letterSpacing: -0.5,
    lineHeight: 34,
  },
};

export const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
};

/**
 * Border Radius per design-system.md Section 4.3
 * Squircle geometry with 12pt default
 */
export const radius = {
  sm: 8,
  md: 12,   // Default for cards per design-system.md
  lg: 16,
  xl: 20,
  xxl: 28,
  full: 9999,
};

/**
 * Shadows per design-system.md Section 4.3
 */
export const shadows = {
  light: {
    default: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.06,
      shadowRadius: 8,
      elevation: 3,
    },
    elevated: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.12,
      shadowRadius: 24,
      elevation: 8,
    },
  },
  dark: {
    default: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.3,
      shadowRadius: 8,
      elevation: 3,
    },
    elevated: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.4,
      shadowRadius: 24,
      elevation: 8,
    },
  },
};

interface ThemeContextType {
  isDark: boolean;
  toggleTheme: () => void;
  colors: typeof colors.light;
  typography: typeof typography;
  spacing: typeof spacing;
  radius: typeof radius;
  shadows: typeof shadows.light;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const systemColorScheme = useColorScheme();
  const [isDark, setIsDark] = useState(systemColorScheme === "dark");

  const toggleTheme = () => setIsDark((prev) => !prev);

  const themeColors = isDark ? colors.dark : colors.light;
  const themeShadows = isDark ? shadows.dark : shadows.light;

  return (
    <ThemeContext.Provider
      value={{
        isDark,
        toggleTheme,
        colors: themeColors,
        typography,
        spacing,
        radius,
        shadows: themeShadows,
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}

/**
 * Get status color based on invoice status
 * Per design-system.md Section 6.2
 */
export function getStatusColor(
  status: "draft" | "sent" | "paid" | "overdue" | "void",
  themeColors: typeof colors.light
): { background: string; text: string } {
  switch (status) {
    case "paid":
      return {
        background: themeColors.statusPaid + "20",
        text: themeColors.statusPaid,
      };
    case "overdue":
      return {
        background: themeColors.statusOverdue + "20",
        text: themeColors.statusOverdue,
      };
    case "sent":
      return {
        background: themeColors.statusSent + "20",
        text: themeColors.statusSent,
      };
    case "void":
      return {
        background: themeColors.textTertiary + "20",
        text: themeColors.textTertiary,
      };
    case "draft":
    default:
      return {
        background: themeColors.statusDraft + "20",
        text: themeColors.statusDraft,
      };
  }
}


=================================================================================
FILE: ./lib/utils.ts
=================================================================================

import { CURRENCY_SYMBOL } from "./constants";

export function formatCurrency(amount: number): string {
  return `${CURRENCY_SYMBOL}${amount.toLocaleString("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
}

export function generateInvoiceNumber(count: number): string {
  return `INV-${String(count).padStart(4, "0")}`;
}

export function formatDate(date: string | Date): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return d.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

export function generateId(): string {
  return Math.random().toString(36).substring(2, 15);
}


=================================================================================
FILE: ./metro.config.js
=================================================================================

const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require("nativewind/metro");

const config = getDefaultConfig(__dirname);

module.exports = withNativeWind(config, { input: "./global.css" });


=================================================================================
FILE: ./nativewind-env.d.ts
=================================================================================

/// <reference types="nativewind/types" />

// NOTE: This file should not be edited and should be committed with your source code. It is generated by NativeWind.

=================================================================================
FILE: ./package.json
=================================================================================

{
  "name": "contractorpro",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-community/netinfo": "^11.4.1",
    "@supabase/supabase-js": "^2.90.1",
    "babel-preset-expo": "^54.0.9",
    "expo": "~54.0.31",
    "expo-av": "~16.0.8",
    "expo-constants": "~18.0.13",
    "expo-contacts": "~15.0.11",
    "expo-file-system": "^19.0.21",
    "expo-font": "~14.0.10",
    "expo-haptics": "~15.0.8",
    "expo-image-picker": "~17.0.10",
    "expo-linking": "~8.0.11",
    "expo-location": "~19.0.8",
    "expo-print": "~15.0.8",
    "expo-router": "~6.0.21",
    "expo-sharing": "~14.0.8",
    "expo-status-bar": "~3.0.9",
    "expo-web-browser": "^15.0.10",
    "lucide-react-native": "^0.562.0",
    "nativewind": "^4.2.1",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "^4.2.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-svg": "15.12.1",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "0.5.1",
    "tailwindcss": "^3.4.19",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "typescript": "~5.9.2"
  },
  "private": true
}


=================================================================================
FILE: ./PROMPT.md
=================================================================================

# ContractorPro - Voice-First Invoicing App

## OBJECTIVE
Build a complete "Voice-First" invoicing app for contractors (iOS/Android).
Core Philosophy: "Apple-like Simplicity." One thumb interaction. Zero friction.

## COMPLETION CRITERIA
When ALL of these are true, output: <promise>CONTRACTORPRO COMPLETE</promise>
- [ ] App runs with `npx expo start` without errors
- [ ] NativeWind styles render correctly
- [ ] VoiceButton records audio on press-hold
- [ ] AI service mocks return structured invoice JSON
- [ ] Dashboard shows revenue card + VoiceButton
- [ ] Profile screen saves business info
- [ ] Invoice preview screen displays parsed data
- [ ] Tab navigation works (Dashboard, Invoices, Profile)

## CURRENT STATE CHECK
Before each iteration:
1. Run `npx expo start --no-dev` to verify build
2. Check for TypeScript errors
3. Review what files exist vs what's needed
4. Pick the NEXT incomplete task

## STRICT TECH STACK (DO NOT DEVIATE)
- Framework: React Native (Expo SDK 52+) with Expo Router
- Language: TypeScript (strict)
- Styling: NativeWind v4 (TailwindCSS)
- Icons: lucide-react-native
- Backend/Auth: Supabase (PostgreSQL)
- AI Logic: OpenAI API (gpt-4o-mini) - MOCK FOR NOW
- Voice-to-Text: OpenAI Whisper API - MOCK FOR NOW
- State Management: Zustand
- Audio: expo-av

## DESIGN SYSTEM
```
Background: #FFFFFF (Light) / #000000 (Dark OLED)
Primary: #00D632 (Electric Green - Action/Money)
Alert: #FF9500 (Orange - Unpaid/Warning)
Typography: System Default (San Francisco)
Layout: "Invisible UI" - Massive whitespace, no borders
Haptics: expo-haptics on all major interactions
```

## DIRECTORY STRUCTURE (CREATE EXACTLY THIS)
```
ContractorPro/
 app/
    _layout.tsx
    index.tsx
    (tabs)/
       _layout.tsx
       index.tsx          # Dashboard
       invoices.tsx
       profile.tsx
    invoice/
       [id].tsx
       preview.tsx
    +not-found.tsx
 components/
    ui/
       Button.tsx
       Card.tsx
       Input.tsx
    VoiceButton.tsx
    RecordingOverlay.tsx
    InvoiceCard.tsx
    LogoUploader.tsx
    MonogramAvatar.tsx
 services/
    ai.ts
    supabase.ts
    audio.ts
 store/
    useInvoiceStore.ts
    useProfileStore.ts
 lib/
    constants.ts
    utils.ts
 types/
    index.ts
 global.css
 tailwind.config.js
 metro.config.js
 babel.config.js
 .env.example
```

## PHASE EXECUTION ORDER

### PHASE 1: Setup (DO FIRST)
1. Initialize Expo: `npx create-expo-app@latest . --template blank-typescript`
2. Install Expo Router: `npx expo install expo-router expo-linking expo-constants`
3. Update package.json: `"main": "expo-router/entry"`
4. Install NativeWind v4:
   ```bash
   npm install nativewind tailwindcss
   npx tailwindcss init
   ```
5. Configure tailwind.config.js:
   ```js
   module.exports = {
     content: ["./app/**/*.{js,jsx,ts,tsx}", "./components/**/*.{js,jsx,ts,tsx}"],
     presets: [require("nativewind/preset")],
     theme: {
       extend: {
         colors: {
           primary: "#00D632",
           alert: "#FF9500",
         },
       },
     },
     plugins: [],
   };
   ```
6. Configure babel.config.js:
   ```js
   module.exports = function (api) {
     api.cache(true);
     return {
       presets: [
         ["babel-preset-expo", { jsxImportSource: "nativewind" }],
         "nativewind/babel",
       ],
     };
   };
   ```
7. Configure metro.config.js:
   ```js
   const { getDefaultConfig } = require("expo/metro-config");
   const { withNativeWind } = require("nativewind/metro");
   const config = getDefaultConfig(__dirname);
   module.exports = withNativeWind(config, { input: "./global.css" });
   ```
8. Create global.css:
   ```css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ```
9. Install dependencies:
   ```bash
   npx expo install expo-av expo-haptics expo-contacts expo-location expo-image-picker expo-print expo-sharing expo-font react-native-safe-area-context react-native-screens
   npm install zustand lucide-react-native @supabase/supabase-js
   ```
10. Create .env.example with placeholders

### PHASE 2: Core Components
1. Create types/index.ts with Invoice, Profile, Client types
2. Create lib/constants.ts with colors
3. Create lib/utils.ts with formatCurrency
4. Build VoiceButton.tsx:
   - 80x80 circular FAB
   - Electric Green background
   - Mic icon (lucide)
   - onPressIn/onPressOut handlers
   - Haptic feedback
   - Animated scale
5. Build components/ui/*.tsx

### PHASE 3: Screens
1. Create app/_layout.tsx (root with providers, import global.css)
2. Create app/(tabs)/_layout.tsx (tab navigator)
3. Create app/(tabs)/index.tsx (Dashboard with revenue card + VoiceButton)
4. Create app/(tabs)/invoices.tsx (list view)
5. Create app/(tabs)/profile.tsx (business info form)
6. Create app/invoice/preview.tsx

### PHASE 4: Services (MOCK)
1. Create services/ai.ts:
   ```typescript
   export async function transcribeAudio(uri: string): Promise<string> {
     // MOCK: Return dummy transcript
     return "Invoice for John Smith. Lawn mowing service, one hundred fifty dollars.";
   }

   export async function parseInvoice(transcript: string): Promise<ParsedInvoice> {
     // MOCK: Return structured data
     return {
       clientName: "John Smith",
       items: [{ description: "Lawn mowing service", price: 150 }],
       detectedLanguage: "en",
     };
   }
   ```
2. Create services/audio.ts for expo-av recording
3. Create store/useInvoiceStore.ts
4. Create store/useProfileStore.ts

### PHASE 5: Integration
1. Wire VoiceButton to audio recording
2. Connect recording flow to AI service mocks
3. Navigate to preview screen with parsed data
4. Ensure all tabs work

## GOTCHAS TO CHECK
- NativeWind: Must import global.css in root _layout.tsx
- SafeArea: Use SafeAreaView from react-native-safe-area-context
- expo-av: Request permissions before recording
- Haptics: Import from expo-haptics, not native
- Tab icons: Use lucide-react-native

## BUSINESS RULES
- Invoice numbers: Auto-increment INV-0001, INV-0002
- Tax: Optional rate in profile (default 0)
- Currency: USD only, format $1,234.56

## ITERATION STRATEGY
Each loop:
1. Check what exists
2. Find first incomplete item
3. Implement it fully
4. Test with `npx expo start`
5. Fix any errors
6. If all complete  output promise tag


=================================================================================
FILE: ./services/ai.ts
=================================================================================

/**
 * AI Service
 * Handles voice transcription and invoice parsing
 * Per architecture-spec.md - Uses Supabase Edge Functions
 */

import { supabase } from "./supabase";
import { ParsedInvoice } from "@/store/useInvoiceStore";
import { AIParseResult } from "@/types";
import * as db from "./database";

// Environment check for development mode
const isDevelopment = __DEV__;

/**
 * Process voice recording through AI pipeline
 * 1. Upload audio to Supabase Storage
 * 2. Call Edge Function for transcription + parsing
 * 3. Return structured invoice data
 */
export async function processVoiceToInvoice(
  audioUri: string
): Promise<{
  parsedInvoice: ParsedInvoice;
  voiceNoteId: string;
  confidence: number;
}> {
  try {
    // 1. Upload audio file to storage
    const fileName = `recording-${Date.now()}.m4a`;
    const storagePath = await db.uploadVoiceNote(audioUri, fileName);

    if (!storagePath) {
      throw new Error("Failed to upload audio file");
    }

    // 2. Create voice note record
    const voiceNote = await db.createVoiceNote({
      storage_path: storagePath,
      processing_status: "processing",
    });

    if (!voiceNote) {
      throw new Error("Failed to create voice note record");
    }

    // 3. Call Edge Function for AI processing
    const { data, error } = await supabase.functions.invoke<AIParseResult>(
      "transcribe-and-parse",
      {
        body: {
          voice_note_id: voiceNote.id,
          storage_path: storagePath,
        },
      }
    );

    if (error) {
      // Update voice note status to failed
      await db.updateVoiceNote(voiceNote.id, {
        processing_status: "failed",
      });
      throw error;
    }

    if (!data) {
      throw new Error("No data returned from AI processing");
    }

    // 4. Update voice note with results
    await db.updateVoiceNote(voiceNote.id, {
      transcript: data.notes || "",
      detected_language: data.meta.language_detected,
      confidence_score: data.meta.confidence,
      processing_status: "completed",
    });

    // 5. Convert AI result to ParsedInvoice format
    const parsedInvoice: ParsedInvoice = {
      clientName: data.client.name || "Unknown Client",
      clientEmail: undefined,
      clientPhone: data.client.contact_inferred || undefined,
      items: data.line_items.map((item) => ({
        description: item.description,
        price: item.unit_price / 100, // Convert from cents to dollars for display
        quantity: item.quantity,
        originalTranscriptSegment: item.original_transcript_segment,
      })),
      detectedLanguage: data.meta.language_detected,
      confidence: data.meta.confidence,
      notes: data.notes || undefined,
    };

    return {
      parsedInvoice,
      voiceNoteId: voiceNote.id,
      confidence: data.meta.confidence,
    };
  } catch (error) {
    console.error("Error processing voice to invoice:", error);

    // In development, fall back to mock data
    if (isDevelopment) {
      console.warn("Using mock data in development mode");
      return getMockParseResult();
    }

    throw error;
  }
}

/**
 * Transcribe audio only (without parsing)
 * Useful for manual review workflows
 */
export async function transcribeAudio(audioUri: string): Promise<string> {
  if (isDevelopment) {
    // Mock transcription for development
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return "Invoice for John Smith. Lawn mowing service, one hundred fifty dollars.";
  }

  // Upload and get transcription via Edge Function
  const fileName = `recording-${Date.now()}.m4a`;
  const storagePath = await db.uploadVoiceNote(audioUri, fileName);

  if (!storagePath) {
    throw new Error("Failed to upload audio file");
  }

  const { data, error } = await supabase.functions.invoke<{ transcript: string }>(
    "transcribe-only",
    {
      body: { storage_path: storagePath },
    }
  );

  if (error) throw error;
  return data?.transcript || "";
}

/**
 * Parse transcript into invoice (without transcription step)
 * Useful when editing or re-processing text
 */
export async function parseTranscript(
  transcript: string,
  language?: string
): Promise<ParsedInvoice> {
  if (isDevelopment) {
    // Mock parsing for development
    await new Promise((resolve) => setTimeout(resolve, 500));
    return {
      clientName: "John Smith",
      items: [{ description: "Lawn mowing service", price: 150, quantity: 1 }],
      detectedLanguage: language || "en",
    };
  }

  const { data, error } = await supabase.functions.invoke<AIParseResult>(
    "parse-transcript",
    {
      body: { transcript, language },
    }
  );

  if (error) throw error;

  if (!data) {
    throw new Error("No data returned from parsing");
  }

  return {
    clientName: data.client.name || "Unknown Client",
    items: data.line_items.map((item) => ({
      description: item.description,
      price: item.unit_price / 100,
      quantity: item.quantity,
      originalTranscriptSegment: item.original_transcript_segment,
    })),
    detectedLanguage: data.meta.language_detected,
    confidence: data.meta.confidence,
    notes: data.notes || undefined,
  };
}

/**
 * Mock data for development/testing
 */
function getMockParseResult(): {
  parsedInvoice: ParsedInvoice;
  voiceNoteId: string;
  confidence: number;
} {
  return {
    parsedInvoice: {
      clientName: "John Smith",
      clientEmail: "john@example.com",
      items: [
        {
          description: "Lawn mowing service",
          price: 150,
          quantity: 1,
          originalTranscriptSegment: "Lawn mowing service, one hundred fifty dollars",
        },
      ],
      detectedLanguage: "en",
      confidence: 0.95,
    },
    voiceNoteId: "mock-voice-note-id",
    confidence: 0.95,
  };
}

/**
 * Generate invoice PDF via Edge Function
 */
export async function generateInvoicePDF(invoiceId: string): Promise<string> {
  if (isDevelopment) {
    // Mock PDF generation for development
    await new Promise((resolve) => setTimeout(resolve, 500));
    return `https://example.com/invoice-${invoiceId}.pdf`;
  }

  const { data, error } = await supabase.functions.invoke<{ pdf_url: string }>(
    "generate-invoice-pdf",
    {
      body: { invoice_id: invoiceId },
    }
  );

  if (error) throw error;
  return data?.pdf_url || "";
}


=================================================================================
FILE: ./services/audio.ts
=================================================================================

import { Audio } from "expo-av";

let recording: Audio.Recording | null = null;

export async function startRecording(): Promise<void> {
  try {
    // Request permissions
    const { status } = await Audio.requestPermissionsAsync();
    if (status !== "granted") {
      throw new Error("Audio recording permission not granted");
    }

    // Configure audio mode
    await Audio.setAudioModeAsync({
      allowsRecordingIOS: true,
      playsInSilentModeIOS: true,
    });

    // Create and start recording
    const { recording: newRecording } = await Audio.Recording.createAsync(
      Audio.RecordingOptionsPresets.HIGH_QUALITY
    );

    recording = newRecording;
  } catch (error) {
    console.error("Failed to start recording:", error);
    throw error;
  }
}

export async function stopRecording(): Promise<string | null> {
  try {
    if (!recording) {
      return null;
    }

    await recording.stopAndUnloadAsync();

    // Reset audio mode
    await Audio.setAudioModeAsync({
      allowsRecordingIOS: false,
    });

    const uri = recording.getURI();
    recording = null;

    return uri;
  } catch (error) {
    console.error("Failed to stop recording:", error);
    recording = null;
    throw error;
  }
}

export async function playAudio(uri: string): Promise<void> {
  try {
    const { sound } = await Audio.Sound.createAsync({ uri });
    await sound.playAsync();
  } catch (error) {
    console.error("Failed to play audio:", error);
    throw error;
  }
}


=================================================================================
FILE: ./services/database.ts
=================================================================================

/**
 * Database Service
 * CRUD operations for all Supabase tables
 * Per architecture-spec.md - All queries are scoped by RLS
 */

import { supabase } from "./supabase";
import {
  Profile,
  ProfileUpdate,
  Client,
  ClientInsert,
  ClientUpdate,
  Invoice,
  InvoiceInsert,
  InvoiceUpdate,
  InvoiceItem,
  InvoiceItemInsert,
  VoiceNote,
  VoiceNoteInsert,
  ReminderSettings,
  ReminderSettingsInsert,
  ReminderSettingsUpdate,
  GlossaryTerm,
} from "@/types/database";

// ============================================================================
// PROFILES
// ============================================================================

export async function getProfile(): Promise<Profile | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const { data, error } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  if (error) {
    console.error("Error fetching profile:", error);
    return null;
  }

  return data;
}

export async function updateProfile(updates: ProfileUpdate): Promise<Profile | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const { data, error } = await supabase
    .from("profiles")
    .update(updates)
    .eq("id", user.id)
    .select()
    .single();

  if (error) {
    console.error("Error updating profile:", error);
    throw error;
  }

  return data;
}

// ============================================================================
// CLIENTS
// ============================================================================

export async function getClients(): Promise<Client[]> {
  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .order("name", { ascending: true });

  if (error) {
    console.error("Error fetching clients:", error);
    return [];
  }

  return data || [];
}

export async function getClient(id: string): Promise<Client | null> {
  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .eq("id", id)
    .single();

  if (error) {
    console.error("Error fetching client:", error);
    return null;
  }

  return data;
}

export async function createClient(client: Omit<ClientInsert, "user_id">): Promise<Client | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const { data, error } = await supabase
    .from("clients")
    .insert({ ...client, user_id: user.id })
    .select()
    .single();

  if (error) {
    console.error("Error creating client:", error);
    throw error;
  }

  return data;
}

export async function updateClient(id: string, updates: ClientUpdate): Promise<Client | null> {
  const { data, error } = await supabase
    .from("clients")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("Error updating client:", error);
    throw error;
  }

  return data;
}

export async function deleteClient(id: string): Promise<boolean> {
  const { error } = await supabase
    .from("clients")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("Error deleting client:", error);
    return false;
  }

  return true;
}

export async function searchClients(query: string): Promise<Client[]> {
  const { data, error } = await supabase
    .from("clients")
    .select("*")
    .ilike("name", `%${query}%`)
    .order("name", { ascending: true })
    .limit(10);

  if (error) {
    console.error("Error searching clients:", error);
    return [];
  }

  return data || [];
}

// ============================================================================
// INVOICES
// ============================================================================

export async function getInvoices(): Promise<Invoice[]> {
  const { data, error } = await supabase
    .from("invoices")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) {
    console.error("Error fetching invoices:", error);
    return [];
  }

  return data || [];
}

export async function getInvoicesByStatus(status: Invoice["status"]): Promise<Invoice[]> {
  const { data, error } = await supabase
    .from("invoices")
    .select("*")
    .eq("status", status)
    .order("created_at", { ascending: false });

  if (error) {
    console.error("Error fetching invoices by status:", error);
    return [];
  }

  return data || [];
}

export async function getInvoice(id: string): Promise<Invoice | null> {
  const { data, error } = await supabase
    .from("invoices")
    .select("*")
    .eq("id", id)
    .single();

  if (error) {
    console.error("Error fetching invoice:", error);
    return null;
  }

  return data;
}

export async function getInvoiceWithItems(id: string): Promise<{ invoice: Invoice; items: InvoiceItem[] } | null> {
  const { data: invoice, error: invoiceError } = await supabase
    .from("invoices")
    .select("*")
    .eq("id", id)
    .single();

  if (invoiceError || !invoice) {
    console.error("Error fetching invoice:", invoiceError);
    return null;
  }

  const { data: items, error: itemsError } = await supabase
    .from("invoice_items")
    .select("*")
    .eq("invoice_id", id)
    .order("created_at", { ascending: true });

  if (itemsError) {
    console.error("Error fetching invoice items:", itemsError);
    return null;
  }

  return { invoice, items: items || [] };
}

export async function createInvoice(
  invoice: Omit<InvoiceInsert, "user_id">,
  items?: Omit<InvoiceItemInsert, "invoice_id">[]
): Promise<Invoice | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  // Get next invoice number if not provided
  if (!invoice.invoice_number) {
    invoice.invoice_number = await getNextInvoiceNumber();
  }

  // Create invoice
  const { data: newInvoice, error: invoiceError } = await supabase
    .from("invoices")
    .insert({ ...invoice, user_id: user.id })
    .select()
    .single();

  if (invoiceError || !newInvoice) {
    console.error("Error creating invoice:", invoiceError);
    throw invoiceError;
  }

  // Create invoice items if provided
  if (items && items.length > 0) {
    const itemsWithInvoiceId = items.map((item) => ({
      ...item,
      invoice_id: newInvoice.id,
    }));

    const { error: itemsError } = await supabase
      .from("invoice_items")
      .insert(itemsWithInvoiceId);

    if (itemsError) {
      console.error("Error creating invoice items:", itemsError);
      // Rollback invoice creation
      await supabase.from("invoices").delete().eq("id", newInvoice.id);
      throw itemsError;
    }
  }

  return newInvoice;
}

export async function createInvoiceWithItems(
  invoice: Omit<InvoiceInsert, "user_id">,
  items: Omit<InvoiceItemInsert, "invoice_id">[]
): Promise<{ invoice: Invoice; items: InvoiceItem[] } | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  // Get next invoice number if not provided
  if (!invoice.invoice_number) {
    invoice.invoice_number = await getNextInvoiceNumber();
  }

  // Create invoice
  const { data: newInvoice, error: invoiceError } = await supabase
    .from("invoices")
    .insert({ ...invoice, user_id: user.id })
    .select()
    .single();

  if (invoiceError || !newInvoice) {
    console.error("Error creating invoice:", invoiceError);
    throw invoiceError;
  }

  // Create invoice items
  const itemsWithInvoiceId = items.map((item) => ({
    ...item,
    invoice_id: newInvoice.id,
  }));

  const { data: newItems, error: itemsError } = await supabase
    .from("invoice_items")
    .insert(itemsWithInvoiceId)
    .select();

  if (itemsError) {
    console.error("Error creating invoice items:", itemsError);
    // Rollback invoice creation
    await supabase.from("invoices").delete().eq("id", newInvoice.id);
    throw itemsError;
  }

  return { invoice: newInvoice, items: newItems || [] };
}

export async function updateInvoice(id: string, updates: InvoiceUpdate): Promise<Invoice | null> {
  const { data, error } = await supabase
    .from("invoices")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("Error updating invoice:", error);
    throw error;
  }

  return data;
}

export async function updateInvoiceStatus(
  id: string,
  status: Invoice["status"],
  additionalUpdates?: Partial<InvoiceUpdate>
): Promise<Invoice | null> {
  const updates: InvoiceUpdate = { status, ...additionalUpdates };

  if (status === "paid") {
    updates.paid_at = new Date().toISOString();
  } else if (status === "sent") {
    updates.sent_at = new Date().toISOString();
  }

  return updateInvoice(id, updates);
}

export async function deleteInvoice(id: string): Promise<boolean> {
  const { error } = await supabase
    .from("invoices")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("Error deleting invoice:", error);
    return false;
  }

  return true;
}

export async function getNextInvoiceNumber(): Promise<string> {
  const { count, error } = await supabase
    .from("invoices")
    .select("*", { count: "exact", head: true });

  if (error) {
    console.error("Error getting invoice count:", error);
    return "INV-0001";
  }

  const nextNumber = (count || 0) + 1;
  return `INV-${nextNumber.toString().padStart(4, "0")}`;
}

// ============================================================================
// INVOICE ITEMS
// ============================================================================

export async function getInvoiceItems(invoiceId: string): Promise<InvoiceItem[]> {
  const { data, error } = await supabase
    .from("invoice_items")
    .select("*")
    .eq("invoice_id", invoiceId)
    .order("created_at", { ascending: true });

  if (error) {
    console.error("Error fetching invoice items:", error);
    return [];
  }

  return data || [];
}

export async function createInvoiceItem(item: InvoiceItemInsert): Promise<InvoiceItem | null> {
  const { data, error } = await supabase
    .from("invoice_items")
    .insert(item)
    .select()
    .single();

  if (error) {
    console.error("Error creating invoice item:", error);
    throw error;
  }

  return data;
}

export async function addInvoiceItem(item: InvoiceItemInsert): Promise<InvoiceItem | null> {
  // Alias for createInvoiceItem for backwards compatibility
  return createInvoiceItem(item);
}

export async function updateInvoiceItem(
  id: string,
  updates: Partial<InvoiceItem>
): Promise<InvoiceItem | null> {
  const { data, error } = await supabase
    .from("invoice_items")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("Error updating invoice item:", error);
    throw error;
  }

  return data;
}

export async function deleteInvoiceItem(id: string): Promise<boolean> {
  const { error } = await supabase
    .from("invoice_items")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("Error deleting invoice item:", error);
    return false;
  }

  return true;
}

// ============================================================================
// VOICE NOTES
// ============================================================================

export async function createVoiceNote(
  voiceNote: Omit<VoiceNoteInsert, "user_id">
): Promise<VoiceNote | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const { data, error } = await supabase
    .from("voice_notes")
    .insert({ ...voiceNote, user_id: user.id })
    .select()
    .single();

  if (error) {
    console.error("Error creating voice note:", error);
    throw error;
  }

  return data;
}

export async function updateVoiceNote(
  id: string,
  updates: Partial<VoiceNote>
): Promise<VoiceNote | null> {
  const { data, error } = await supabase
    .from("voice_notes")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) {
    console.error("Error updating voice note:", error);
    throw error;
  }

  return data;
}

// ============================================================================
// GLOSSARY (Read-only)
// ============================================================================

export async function getGlossaryTerms(language?: string): Promise<GlossaryTerm[]> {
  let query = supabase.from("glossary_terms").select("*");

  if (language) {
    query = query.eq("language", language);
  }

  const { data, error } = await query.order("term", { ascending: true });

  if (error) {
    console.error("Error fetching glossary terms:", error);
    return [];
  }

  return data || [];
}

// ============================================================================
// REMINDER SETTINGS
// ============================================================================

export async function getReminderSettings(): Promise<ReminderSettings | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const { data, error } = await supabase
    .from("reminder_settings")
    .select("*")
    .eq("user_id", user.id)
    .single();

  if (error && error.code !== "PGRST116") {
    // PGRST116 = no rows returned
    console.error("Error fetching reminder settings:", error);
    return null;
  }

  return data;
}

export async function upsertReminderSettings(
  settings: Omit<ReminderSettingsInsert, "user_id">
): Promise<ReminderSettings | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const { data, error } = await supabase
    .from("reminder_settings")
    .upsert({ ...settings, user_id: user.id })
    .select()
    .single();

  if (error) {
    console.error("Error upserting reminder settings:", error);
    throw error;
  }

  return data;
}

// ============================================================================
// DASHBOARD AGGREGATIONS
// ============================================================================

export async function getDashboardStats(): Promise<{
  totalRevenue: number;
  pendingAmount: number;
  invoiceCount: number;
  paidCount: number;
  overdueCount: number;
}> {
  const { data: invoices, error } = await supabase
    .from("invoices")
    .select("total, status");

  if (error) {
    console.error("Error fetching dashboard stats:", error);
    return {
      totalRevenue: 0,
      pendingAmount: 0,
      invoiceCount: 0,
      paidCount: 0,
      overdueCount: 0,
    };
  }

  const stats = (invoices || []).reduce(
    (acc, invoice) => {
      acc.invoiceCount++;

      if (invoice.status === "paid") {
        acc.totalRevenue += invoice.total;
        acc.paidCount++;
      } else if (invoice.status === "sent" || invoice.status === "overdue") {
        acc.pendingAmount += invoice.total;
        if (invoice.status === "overdue") {
          acc.overdueCount++;
        }
      }

      return acc;
    },
    {
      totalRevenue: 0,
      pendingAmount: 0,
      invoiceCount: 0,
      paidCount: 0,
      overdueCount: 0,
    }
  );

  return stats;
}

// ============================================================================
// FILE STORAGE
// ============================================================================

export async function uploadVoiceNote(
  uri: string,
  fileName: string
): Promise<string | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const filePath = `${user.id}/${fileName}`;

  // Read file as blob
  const response = await fetch(uri);
  const blob = await response.blob();

  const { data, error } = await supabase.storage
    .from("voice-evidence")
    .upload(filePath, blob, {
      contentType: "audio/m4a",
      upsert: false,
    });

  if (error) {
    console.error("Error uploading voice note:", error);
    throw error;
  }

  return data.path;
}

export async function uploadLogo(uri: string, fileName: string): Promise<string | null> {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return null;

  const filePath = `${user.id}/${fileName}`;

  const response = await fetch(uri);
  const blob = await response.blob();

  const { data, error } = await supabase.storage
    .from("logos")
    .upload(filePath, blob, {
      contentType: "image/jpeg",
      upsert: true,
    });

  if (error) {
    console.error("Error uploading logo:", error);
    throw error;
  }

  // Get public URL
  const { data: urlData } = supabase.storage
    .from("logos")
    .getPublicUrl(data.path);

  return urlData.publicUrl;
}

export async function getSignedUrl(
  bucket: string,
  path: string,
  expiresIn: number = 60
): Promise<string | null> {
  const { data, error } = await supabase.storage
    .from(bucket)
    .createSignedUrl(path, expiresIn);

  if (error) {
    console.error("Error getting signed URL:", error);
    return null;
  }

  return data.signedUrl;
}


=================================================================================
FILE: ./services/export.ts
=================================================================================

/**
 * Export Service
 * Client-side service for exporting data (QuickBooks CSV/IIF)
 * Per product-strategy.md Section 3.4
 */

import { supabase } from "@/lib/supabase";
import * as FileSystem from "expo-file-system";
import * as Sharing from "expo-sharing";
import { Platform } from "react-native";

const SUPABASE_URL = process.env.EXPO_PUBLIC_SUPABASE_URL;

export type ExportFormat = "csv" | "iif";

export interface ExportOptions {
  format?: ExportFormat;
  startDate?: string; // ISO date string
  endDate?: string; // ISO date string
  status?: "draft" | "sent" | "paid" | "void" | "overdue";
  includeItems?: boolean;
}

export interface ExportResult {
  success: boolean;
  filename?: string;
  localUri?: string;
  error?: string;
}

/**
 * Export invoices to QuickBooks-compatible format
 */
export async function exportInvoices(options: ExportOptions = {}): Promise<ExportResult> {
  try {
    // Get current session
    const { data: { session }, error: authError } = await supabase.auth.getSession();
    if (authError || !session) {
      return { success: false, error: "Not authenticated" };
    }

    // Call Edge Function
    const response = await fetch(
      `${SUPABASE_URL}/functions/v1/export-quickbooks`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${session.access_token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          format: options.format || "csv",
          startDate: options.startDate,
          endDate: options.endDate,
          status: options.status,
          includeItems: options.includeItems ?? true,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return {
        success: false,
        error: errorData.error || `Export failed: ${response.status}`,
      };
    }

    // Get filename from Content-Disposition header
    const contentDisposition = response.headers.get("Content-Disposition");
    const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
    const filename = filenameMatch?.[1] || `invoices_export.${options.format || "csv"}`;

    // Get the file content
    const content = await response.text();

    // Save to local file
    const localUri = `${FileSystem.documentDirectory}${filename}`;
    await FileSystem.writeAsStringAsync(localUri, content, {
      encoding: FileSystem.EncodingType.UTF8,
    });

    return {
      success: true,
      filename,
      localUri,
    };
  } catch (error: any) {
    console.error("Error exporting invoices:", error);
    return {
      success: false,
      error: error.message || "Failed to export invoices",
    };
  }
}

/**
 * Export and share invoices
 */
export async function exportAndShareInvoices(
  options: ExportOptions = {}
): Promise<ExportResult> {
  // First export to local file
  const result = await exportInvoices(options);

  if (!result.success || !result.localUri) {
    return result;
  }

  // Check if sharing is available
  const isAvailable = await Sharing.isAvailableAsync();
  if (!isAvailable) {
    return {
      ...result,
      error: "Sharing is not available on this device",
    };
  }

  try {
    // Share the file
    await Sharing.shareAsync(result.localUri, {
      mimeType: options.format === "iif" ? "application/x-iif" : "text/csv",
      dialogTitle: "Export Invoices",
      UTI: options.format === "iif" ? "public.data" : "public.comma-separated-values-text",
    });

    return result;
  } catch (error: any) {
    // User may have cancelled sharing - still return success since file was created
    if (error.message?.includes("cancel")) {
      return result;
    }
    return {
      ...result,
      error: error.message,
    };
  }
}

/**
 * Get date range presets for export
 */
export function getDateRangePresets(): {
  label: string;
  value: string;
  getRange: () => { startDate: string; endDate: string };
}[] {
  return [
    {
      label: "This Month",
      value: "this_month",
      getRange: () => {
        const now = new Date();
        const start = new Date(now.getFullYear(), now.getMonth(), 1);
        const end = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        return {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
        };
      },
    },
    {
      label: "Last Month",
      value: "last_month",
      getRange: () => {
        const now = new Date();
        const start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const end = new Date(now.getFullYear(), now.getMonth(), 0);
        return {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
        };
      },
    },
    {
      label: "This Quarter",
      value: "this_quarter",
      getRange: () => {
        const now = new Date();
        const quarter = Math.floor(now.getMonth() / 3);
        const start = new Date(now.getFullYear(), quarter * 3, 1);
        const end = new Date(now.getFullYear(), quarter * 3 + 3, 0);
        return {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
        };
      },
    },
    {
      label: "Last Quarter",
      value: "last_quarter",
      getRange: () => {
        const now = new Date();
        const quarter = Math.floor(now.getMonth() / 3) - 1;
        const year = quarter < 0 ? now.getFullYear() - 1 : now.getFullYear();
        const adjustedQuarter = quarter < 0 ? 3 : quarter;
        const start = new Date(year, adjustedQuarter * 3, 1);
        const end = new Date(year, adjustedQuarter * 3 + 3, 0);
        return {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
        };
      },
    },
    {
      label: "This Year",
      value: "this_year",
      getRange: () => {
        const now = new Date();
        const start = new Date(now.getFullYear(), 0, 1);
        const end = new Date(now.getFullYear(), 11, 31);
        return {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
        };
      },
    },
    {
      label: "Last Year",
      value: "last_year",
      getRange: () => {
        const now = new Date();
        const start = new Date(now.getFullYear() - 1, 0, 1);
        const end = new Date(now.getFullYear() - 1, 11, 31);
        return {
          startDate: start.toISOString(),
          endDate: end.toISOString(),
        };
      },
    },
    {
      label: "All Time",
      value: "all_time",
      getRange: () => ({
        startDate: "",
        endDate: "",
      }),
    },
  ];
}

/**
 * Format export status for display
 */
export function getStatusOptions(): { label: string; value: string }[] {
  return [
    { label: "All Statuses", value: "" },
    { label: "Draft", value: "draft" },
    { label: "Sent", value: "sent" },
    { label: "Paid", value: "paid" },
    { label: "Overdue", value: "overdue" },
    { label: "Void", value: "void" },
  ];
}


=================================================================================
FILE: ./services/invoice.ts
=================================================================================

import { Share, Linking, Platform } from "react-native";
import * as FileSystem from "expo-file-system";
import * as Sharing from "expo-sharing";
import { supabase } from "./supabase";
import { Invoice } from "@/types";
import { getPaymentLink } from "./stripe";

/**
 * Invoice Service
 * Handles PDF generation, sharing, and sending flows
 */

interface SendInvoiceResult {
  success: boolean;
  pdfUrl?: string;
  paymentUrl?: string;
  error?: string;
}

/**
 * Generate PDF for an invoice
 */
export async function generateInvoicePDF(invoiceId: string): Promise<{ pdfUrl: string } | null> {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) throw new Error("Not authenticated");

    const response = await supabase.functions.invoke("generate-invoice-pdf", {
      body: { invoice_id: invoiceId },
    });

    if (response.error) {
      console.error("PDF generation error:", response.error);
      return null;
    }

    return { pdfUrl: response.data.pdf_url };
  } catch (error) {
    console.error("Error generating PDF:", error);
    return null;
  }
}

/**
 * Complete send invoice flow:
 * 1. Generate PDF
 * 2. Generate payment link (if Stripe connected)
 * 3. Open native share sheet
 */
export async function sendInvoice(
  invoice: Invoice,
  options: {
    includePaymentLink?: boolean;
    shareMethod?: "native" | "sms" | "whatsapp" | "email";
  } = {}
): Promise<SendInvoiceResult> {
  const { includePaymentLink = true, shareMethod = "native" } = options;

  try {
    // 1. Generate PDF
    const pdfResult = await generateInvoicePDF(invoice.id);

    // 2. Generate payment link if requested
    let paymentUrl: string | undefined;
    if (includePaymentLink && invoice.status !== "paid") {
      const paymentResult = await getPaymentLink(invoice.id);
      paymentUrl = paymentResult?.url;
    }

    // 3. Construct message
    const message = constructInvoiceMessage(invoice, paymentUrl);

    // 4. Share via selected method
    switch (shareMethod) {
      case "sms":
        await shareViaSMS(invoice, message);
        break;
      case "whatsapp":
        await shareViaWhatsApp(invoice, message);
        break;
      case "email":
        await shareViaEmail(invoice, message, pdfResult?.pdfUrl);
        break;
      default:
        await shareNative(invoice, message, pdfResult?.pdfUrl);
    }

    return {
      success: true,
      pdfUrl: pdfResult?.pdfUrl,
      paymentUrl,
    };
  } catch (error: any) {
    console.error("Error sending invoice:", error);
    return {
      success: false,
      error: error.message || "Failed to send invoice",
    };
  }
}

/**
 * Construct the invoice message for sharing
 * Per product-strategy.md "Hybrid Messaging"
 */
function constructInvoiceMessage(invoice: Invoice, paymentUrl?: string): string {
  const amount = formatCurrency(invoice.total, invoice.currency);
  const dueDate = invoice.due_date
    ? new Date(invoice.due_date).toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
      })
    : null;

  let message = `Hi ${invoice.client_name.split(" ")[0]},\n\n`;
  message += `Here's your invoice for ${amount}.\n`;
  message += `Invoice #: ${invoice.invoice_number}\n`;

  if (dueDate) {
    message += `Due: ${dueDate}\n`;
  }

  if (paymentUrl) {
    message += `\nPay securely here:\n${paymentUrl}\n`;
  }

  message += `\nThank you for your business!`;

  return message;
}

/**
 * Share via native share sheet
 */
async function shareNative(
  invoice: Invoice,
  message: string,
  pdfUrl?: string
): Promise<void> {
  const shareOptions: { message: string; url?: string; title?: string } = {
    message,
    title: `Invoice ${invoice.invoice_number}`,
  };

  // Add PDF URL if available
  if (pdfUrl) {
    shareOptions.url = pdfUrl;
  }

  await Share.share(shareOptions);
}

/**
 * Share via SMS (Native)
 * Per product-strategy.md - "trust from known number"
 */
async function shareViaSMS(invoice: Invoice, message: string): Promise<void> {
  const phoneNumber = invoice.client_phone || "";
  const encodedMessage = encodeURIComponent(message);

  // Different URL schemes for iOS and Android
  const smsUrl = Platform.select({
    ios: `sms:${phoneNumber}&body=${encodedMessage}`,
    android: `sms:${phoneNumber}?body=${encodedMessage}`,
  });

  if (smsUrl && (await Linking.canOpenURL(smsUrl))) {
    await Linking.openURL(smsUrl);
  } else {
    // Fallback to native share
    await Share.share({ message });
  }
}

/**
 * Share via WhatsApp
 */
async function shareViaWhatsApp(invoice: Invoice, message: string): Promise<void> {
  const phoneNumber = invoice.client_phone?.replace(/\D/g, "") || "";
  const encodedMessage = encodeURIComponent(message);

  // WhatsApp URL scheme
  const whatsappUrl = phoneNumber
    ? `whatsapp://send?phone=${phoneNumber}&text=${encodedMessage}`
    : `whatsapp://send?text=${encodedMessage}`;

  if (await Linking.canOpenURL(whatsappUrl)) {
    await Linking.openURL(whatsappUrl);
  } else {
    // WhatsApp not installed, try web version
    const webUrl = `https://wa.me/${phoneNumber}?text=${encodedMessage}`;
    await Linking.openURL(webUrl);
  }
}

/**
 * Share via Email
 */
async function shareViaEmail(
  invoice: Invoice,
  message: string,
  pdfUrl?: string
): Promise<void> {
  const email = invoice.client_email || "";
  const subject = encodeURIComponent(`Invoice ${invoice.invoice_number}`);
  const body = encodeURIComponent(message);

  const mailtoUrl = `mailto:${email}?subject=${subject}&body=${body}`;

  if (await Linking.canOpenURL(mailtoUrl)) {
    await Linking.openURL(mailtoUrl);
  } else {
    // Fallback to native share
    await Share.share({ message, title: `Invoice ${invoice.invoice_number}` });
  }
}

/**
 * Format currency for display
 */
function formatCurrency(cents: number, currency: string = "USD"): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(cents / 100);
}

/**
 * Download PDF to device
 */
export async function downloadInvoicePDF(
  invoiceId: string,
  invoiceNumber: string
): Promise<string | null> {
  try {
    const pdfResult = await generateInvoicePDF(invoiceId);
    if (!pdfResult?.pdfUrl) return null;

    const fileName = `Invoice_${invoiceNumber.replace(/\s/g, "_")}.html`;
    const fileUri = `${FileSystem.documentDirectory}${fileName}`;

    const downloadResult = await FileSystem.downloadAsync(
      pdfResult.pdfUrl,
      fileUri
    );

    if (downloadResult.status === 200) {
      return downloadResult.uri;
    }

    return null;
  } catch (error) {
    console.error("Error downloading PDF:", error);
    return null;
  }
}

/**
 * Share downloaded file
 */
export async function shareFile(fileUri: string): Promise<void> {
  if (await Sharing.isAvailableAsync()) {
    await Sharing.shareAsync(fileUri);
  }
}

/**
 * Generate reminder message for overdue invoices
 * Per product-strategy.md "Bad Cop" system
 */
export function generateReminderMessage(
  invoice: Invoice,
  reminderNumber: number = 1,
  paymentUrl?: string
): string {
  const amount = formatCurrency(invoice.total, invoice.currency);
  const daysPastDue = invoice.due_date
    ? Math.floor(
        (Date.now() - new Date(invoice.due_date).getTime()) / (1000 * 60 * 60 * 24)
      )
    : 0;

  let message = "";

  if (reminderNumber === 1) {
    // Friendly first reminder
    message = `Hi ${invoice.client_name.split(" ")[0]},\n\n`;
    message += `This is a friendly reminder about invoice ${invoice.invoice_number} for ${amount}.\n`;
    if (daysPastDue > 0) {
      message += `The payment was due ${daysPastDue} day${daysPastDue > 1 ? "s" : ""} ago.\n`;
    }
  } else if (reminderNumber === 2) {
    // Second reminder - more direct
    message = `Hi ${invoice.client_name.split(" ")[0]},\n\n`;
    message += `We haven't received payment for invoice ${invoice.invoice_number} (${amount}).\n`;
    message += `This invoice is now ${daysPastDue} days overdue.\n`;
    message += `Please arrange payment at your earliest convenience.\n`;
  } else {
    // Final notice
    message = `PAYMENT REMINDER\n\n`;
    message += `Invoice: ${invoice.invoice_number}\n`;
    message += `Amount: ${amount}\n`;
    message += `Days Overdue: ${daysPastDue}\n\n`;
    message += `Please make payment immediately to avoid further action.\n`;
  }

  if (paymentUrl) {
    message += `\nPay now: ${paymentUrl}\n`;
  }

  return message;
}

/**
 * Check if sharing is available
 */
export async function canShare(): Promise<boolean> {
  return Sharing.isAvailableAsync();
}


=================================================================================
FILE: ./services/offline.ts
=================================================================================

/**
 * Offline Service
 * Handles offline data sync, queued uploads, and local draft storage
 * Per product-strategy.md - contractors often work in areas with poor connectivity
 */

import AsyncStorage from "@react-native-async-storage/async-storage";
import NetInfo, { NetInfoState } from "@react-native-community/netinfo";
import * as FileSystem from "expo-file-system";
import { supabase } from "@/lib/supabase";
import { Invoice, InvoiceItem } from "@/types";

// Storage keys
const STORAGE_KEYS = {
  PENDING_UPLOADS: "offline:pending_uploads",
  DRAFT_INVOICES: "offline:draft_invoices",
  PENDING_VOICE_NOTES: "offline:pending_voice_notes",
  SYNC_QUEUE: "offline:sync_queue",
  LAST_SYNC: "offline:last_sync",
};

// Types
interface PendingUpload {
  id: string;
  type: "voice_note" | "logo" | "invoice_pdf";
  localUri: string;
  storagePath: string;
  metadata?: Record<string, any>;
  createdAt: string;
  retryCount: number;
}

interface DraftInvoice {
  id: string;
  clientName?: string;
  clientId?: string;
  items: Partial<InvoiceItem>[];
  notes?: string;
  transcript?: string;
  voiceNoteUri?: string;
  createdAt: string;
  updatedAt: string;
}

interface SyncQueueItem {
  id: string;
  action: "create" | "update" | "delete";
  table: string;
  data: Record<string, any>;
  createdAt: string;
  retryCount: number;
}

// Connection state
let isOnline = true;
let connectionListeners: ((online: boolean) => void)[] = [];

/**
 * Initialize offline service and start monitoring connectivity
 */
export async function initOfflineService(): Promise<void> {
  // Get initial connection state
  const state = await NetInfo.fetch();
  isOnline = state.isConnected ?? true;

  // Subscribe to connection changes
  NetInfo.addEventListener(handleConnectionChange);

  // If online, try to sync any pending items
  if (isOnline) {
    syncPendingItems();
  }
}

/**
 * Handle connection state changes
 */
function handleConnectionChange(state: NetInfoState): void {
  const wasOnline = isOnline;
  isOnline = state.isConnected ?? true;

  // Notify listeners
  connectionListeners.forEach((listener) => listener(isOnline));

  // If we just came online, sync pending items
  if (!wasOnline && isOnline) {
    console.log("Connection restored, syncing pending items...");
    syncPendingItems();
  }
}

/**
 * Subscribe to connection changes
 */
export function subscribeToConnectionChanges(
  callback: (online: boolean) => void
): () => void {
  connectionListeners.push(callback);
  return () => {
    connectionListeners = connectionListeners.filter((cb) => cb !== callback);
  };
}

/**
 * Check if currently online
 */
export function checkIsOnline(): boolean {
  return isOnline;
}

// =============================================================================
// PENDING UPLOADS (Voice Notes, Logos, PDFs)
// =============================================================================

/**
 * Queue a file for upload when online
 */
export async function queueUpload(upload: Omit<PendingUpload, "id" | "createdAt" | "retryCount">): Promise<string> {
  const pending = await getPendingUploads();

  const newUpload: PendingUpload = {
    ...upload,
    id: `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    createdAt: new Date().toISOString(),
    retryCount: 0,
  };

  pending.push(newUpload);
  await AsyncStorage.setItem(STORAGE_KEYS.PENDING_UPLOADS, JSON.stringify(pending));

  // Try to upload immediately if online
  if (isOnline) {
    processUploadQueue();
  }

  return newUpload.id;
}

/**
 * Get all pending uploads
 */
export async function getPendingUploads(): Promise<PendingUpload[]> {
  const data = await AsyncStorage.getItem(STORAGE_KEYS.PENDING_UPLOADS);
  return data ? JSON.parse(data) : [];
}

/**
 * Process the upload queue
 */
async function processUploadQueue(): Promise<void> {
  const pending = await getPendingUploads();
  if (pending.length === 0) return;

  const remaining: PendingUpload[] = [];

  for (const upload of pending) {
    try {
      // Check if file still exists
      const fileInfo = await FileSystem.getInfoAsync(upload.localUri);
      if (!fileInfo.exists) {
        console.log(`File no longer exists: ${upload.localUri}`);
        continue;
      }

      // Read file as base64
      const base64 = await FileSystem.readAsStringAsync(upload.localUri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      // Determine content type
      const contentType = getContentType(upload.localUri);

      // Upload to Supabase Storage
      const { error } = await supabase.storage
        .from(getBucketName(upload.type))
        .upload(upload.storagePath, decode(base64), {
          contentType,
          upsert: true,
        });

      if (error) {
        throw error;
      }

      console.log(`Successfully uploaded: ${upload.storagePath}`);

      // Delete local file after successful upload
      await FileSystem.deleteAsync(upload.localUri, { idempotent: true });
    } catch (error) {
      console.error(`Failed to upload ${upload.id}:`, error);

      // Increment retry count
      upload.retryCount++;

      // Keep in queue if under max retries
      if (upload.retryCount < 5) {
        remaining.push(upload);
      } else {
        console.error(`Max retries exceeded for upload: ${upload.id}`);
      }
    }
  }

  await AsyncStorage.setItem(STORAGE_KEYS.PENDING_UPLOADS, JSON.stringify(remaining));
}

// =============================================================================
// DRAFT INVOICES
// =============================================================================

/**
 * Save a draft invoice locally
 */
export async function saveDraftInvoice(draft: Omit<DraftInvoice, "id" | "createdAt" | "updatedAt">): Promise<string> {
  const drafts = await getDraftInvoices();

  const newDraft: DraftInvoice = {
    ...draft,
    id: `draft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  drafts.push(newDraft);
  await AsyncStorage.setItem(STORAGE_KEYS.DRAFT_INVOICES, JSON.stringify(drafts));

  return newDraft.id;
}

/**
 * Update an existing draft invoice
 */
export async function updateDraftInvoice(id: string, updates: Partial<DraftInvoice>): Promise<void> {
  const drafts = await getDraftInvoices();
  const index = drafts.findIndex((d) => d.id === id);

  if (index !== -1) {
    drafts[index] = {
      ...drafts[index],
      ...updates,
      updatedAt: new Date().toISOString(),
    };
    await AsyncStorage.setItem(STORAGE_KEYS.DRAFT_INVOICES, JSON.stringify(drafts));
  }
}

/**
 * Get all draft invoices
 */
export async function getDraftInvoices(): Promise<DraftInvoice[]> {
  const data = await AsyncStorage.getItem(STORAGE_KEYS.DRAFT_INVOICES);
  return data ? JSON.parse(data) : [];
}

/**
 * Get a specific draft invoice
 */
export async function getDraftInvoice(id: string): Promise<DraftInvoice | null> {
  const drafts = await getDraftInvoices();
  return drafts.find((d) => d.id === id) || null;
}

/**
 * Delete a draft invoice
 */
export async function deleteDraftInvoice(id: string): Promise<void> {
  const drafts = await getDraftInvoices();
  const filtered = drafts.filter((d) => d.id !== id);
  await AsyncStorage.setItem(STORAGE_KEYS.DRAFT_INVOICES, JSON.stringify(filtered));
}

// =============================================================================
// SYNC QUEUE (Database Operations)
// =============================================================================

/**
 * Queue a database operation for when online
 */
export async function queueDatabaseOperation(
  action: "create" | "update" | "delete",
  table: string,
  data: Record<string, any>
): Promise<string> {
  const queue = await getSyncQueue();

  const item: SyncQueueItem = {
    id: `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    action,
    table,
    data,
    createdAt: new Date().toISOString(),
    retryCount: 0,
  };

  queue.push(item);
  await AsyncStorage.setItem(STORAGE_KEYS.SYNC_QUEUE, JSON.stringify(queue));

  // Try to sync immediately if online
  if (isOnline) {
    processSyncQueue();
  }

  return item.id;
}

/**
 * Get all items in sync queue
 */
export async function getSyncQueue(): Promise<SyncQueueItem[]> {
  const data = await AsyncStorage.getItem(STORAGE_KEYS.SYNC_QUEUE);
  return data ? JSON.parse(data) : [];
}

/**
 * Process the sync queue
 */
async function processSyncQueue(): Promise<void> {
  const queue = await getSyncQueue();
  if (queue.length === 0) return;

  const remaining: SyncQueueItem[] = [];

  for (const item of queue) {
    try {
      let error;

      switch (item.action) {
        case "create":
          ({ error } = await supabase.from(item.table).insert(item.data));
          break;
        case "update":
          const { id, ...updateData } = item.data;
          ({ error } = await supabase.from(item.table).update(updateData).eq("id", id));
          break;
        case "delete":
          ({ error } = await supabase.from(item.table).delete().eq("id", item.data.id));
          break;
      }

      if (error) {
        throw error;
      }

      console.log(`Successfully synced: ${item.action} on ${item.table}`);
    } catch (error) {
      console.error(`Failed to sync ${item.id}:`, error);

      item.retryCount++;

      if (item.retryCount < 5) {
        remaining.push(item);
      } else {
        console.error(`Max retries exceeded for sync: ${item.id}`);
      }
    }
  }

  await AsyncStorage.setItem(STORAGE_KEYS.SYNC_QUEUE, JSON.stringify(remaining));
}

// =============================================================================
// MAIN SYNC FUNCTION
// =============================================================================

/**
 * Sync all pending items (uploads + database operations)
 */
export async function syncPendingItems(): Promise<{
  uploads: number;
  operations: number;
  errors: number;
}> {
  if (!isOnline) {
    return { uploads: 0, operations: 0, errors: 0 };
  }

  const uploadsBefore = (await getPendingUploads()).length;
  const queueBefore = (await getSyncQueue()).length;

  await Promise.all([processUploadQueue(), processSyncQueue()]);

  const uploadsAfter = (await getPendingUploads()).length;
  const queueAfter = (await getSyncQueue()).length;

  const result = {
    uploads: uploadsBefore - uploadsAfter,
    operations: queueBefore - queueAfter,
    errors: uploadsAfter + queueAfter,
  };

  // Update last sync time
  await AsyncStorage.setItem(STORAGE_KEYS.LAST_SYNC, new Date().toISOString());

  return result;
}

/**
 * Get last sync timestamp
 */
export async function getLastSyncTime(): Promise<string | null> {
  return AsyncStorage.getItem(STORAGE_KEYS.LAST_SYNC);
}

/**
 * Get pending item counts
 */
export async function getPendingCounts(): Promise<{
  uploads: number;
  operations: number;
  drafts: number;
}> {
  const [uploads, operations, drafts] = await Promise.all([
    getPendingUploads(),
    getSyncQueue(),
    getDraftInvoices(),
  ]);

  return {
    uploads: uploads.length,
    operations: operations.length,
    drafts: drafts.length,
  };
}

/**
 * Clear all offline data (use with caution)
 */
export async function clearOfflineData(): Promise<void> {
  await Promise.all([
    AsyncStorage.removeItem(STORAGE_KEYS.PENDING_UPLOADS),
    AsyncStorage.removeItem(STORAGE_KEYS.DRAFT_INVOICES),
    AsyncStorage.removeItem(STORAGE_KEYS.SYNC_QUEUE),
    AsyncStorage.removeItem(STORAGE_KEYS.LAST_SYNC),
  ]);
}

// =============================================================================
// HELPERS
// =============================================================================

function getBucketName(type: PendingUpload["type"]): string {
  switch (type) {
    case "voice_note":
      return "voice-evidence";
    case "logo":
      return "logos";
    case "invoice_pdf":
      return "invoice-pdfs";
    default:
      return "voice-evidence";
  }
}

function getContentType(uri: string): string {
  const extension = uri.split(".").pop()?.toLowerCase();
  switch (extension) {
    case "m4a":
      return "audio/mp4";
    case "mp3":
      return "audio/mpeg";
    case "wav":
      return "audio/wav";
    case "png":
      return "image/png";
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "pdf":
      return "application/pdf";
    default:
      return "application/octet-stream";
  }
}

// Base64 decode helper
function decode(base64: string): Uint8Array {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}


=================================================================================
FILE: ./services/stripe.ts
=================================================================================

/**
 * Stripe Service
 * Handles Stripe Connect operations
 * Per architecture-spec.md Section 4
 */

import { supabase } from "./supabase";
import { StripeAccountStatus } from "@/types";

/**
 * Get Stripe Connect onboarding URL
 */
export async function getConnectOnboardingUrl(): Promise<{
  url: string;
  accountId: string;
} | null> {
  try {
    const { data, error } = await supabase.functions.invoke<{
      url: string;
      account_id: string;
    }>("create-connect-account", {
      body: {
        return_url: "contractorpro://stripe/return",
        refresh_url: "contractorpro://stripe/refresh",
      },
    });

    if (error) throw error;

    return data
      ? { url: data.url, accountId: data.account_id }
      : null;
  } catch (error) {
    console.error("Error getting onboarding URL:", error);
    throw error;
  }
}

/**
 * Check Stripe account status
 */
export async function getStripeAccountStatus(): Promise<StripeAccountStatus> {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return {
        isConnected: false,
        chargesEnabled: false,
        payoutsEnabled: false,
        accountId: null,
      };
    }

    const { data: profile, error } = await supabase
      .from("profiles")
      .select("stripe_account_id, charges_enabled, payouts_enabled")
      .eq("id", user.id)
      .single();

    if (error || !profile) {
      return {
        isConnected: false,
        chargesEnabled: false,
        payoutsEnabled: false,
        accountId: null,
      };
    }

    return {
      isConnected: !!profile.stripe_account_id,
      chargesEnabled: profile.charges_enabled || false,
      payoutsEnabled: profile.payouts_enabled || false,
      accountId: profile.stripe_account_id,
    };
  } catch (error) {
    console.error("Error getting Stripe status:", error);
    return {
      isConnected: false,
      chargesEnabled: false,
      payoutsEnabled: false,
      accountId: null,
    };
  }
}

/**
 * Generate payment link for an invoice
 */
export async function generatePaymentLink(invoiceId: string): Promise<{
  paymentLinkUrl: string;
  paymentIntentId: string;
} | null> {
  try {
    const { data, error } = await supabase.functions.invoke<{
      payment_link_url: string;
      payment_intent_id: string;
    }>("generate-payment-link", {
      body: { invoice_id: invoiceId },
    });

    if (error) throw error;

    return data
      ? {
          paymentLinkUrl: data.payment_link_url,
          paymentIntentId: data.payment_intent_id,
        }
      : null;
  } catch (error) {
    console.error("Error generating payment link:", error);
    throw error;
  }
}

/**
 * Refresh Stripe account status from API
 */
export async function refreshAccountStatus(): Promise<void> {
  try {
    const { data, error } = await supabase.functions.invoke(
      "refresh-stripe-status",
      {}
    );

    if (error) {
      console.error("Error refreshing status:", error);
    }
  } catch (error) {
    console.error("Error refreshing Stripe status:", error);
  }
}


=================================================================================
FILE: ./services/supabase.ts
=================================================================================

import { createClient } from "@supabase/supabase-js";
import { Database } from "@/types/database";

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || "";
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || "";

// Typed Supabase client per architecture-spec.md
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: false,
  },
});

// Re-export types for convenience
export type { Database } from "@/types/database";


=================================================================================
FILE: ./services/twilio.ts
=================================================================================

/**
 * Twilio Service
 * SMS sending for automated reminders ("Bad Cop" system)
 * Per product-strategy.md Section 3.3
 */

const TWILIO_ACCOUNT_SID = process.env.EXPO_PUBLIC_TWILIO_ACCOUNT_SID;
const TWILIO_AUTH_TOKEN = process.env.EXPO_PUBLIC_TWILIO_AUTH_TOKEN;
const TWILIO_PHONE_NUMBER = process.env.EXPO_PUBLIC_TWILIO_PHONE_NUMBER;

interface SendSMSParams {
  to: string;
  body: string;
}

interface SMSResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

/**
 * Send SMS via Twilio
 * Note: In production, this should be called from an Edge Function
 * to keep credentials secure
 */
export async function sendSMS(params: SendSMSParams): Promise<SMSResult> {
  const { to, body } = params;

  if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN || !TWILIO_PHONE_NUMBER) {
    console.warn("Twilio credentials not configured");
    return { success: false, error: "Twilio not configured" };
  }

  try {
    const url = `https://api.twilio.com/2010-04-01/Accounts/${TWILIO_ACCOUNT_SID}/Messages.json`;
    const auth = btoa(`${TWILIO_ACCOUNT_SID}:${TWILIO_AUTH_TOKEN}`);

    const response = await fetch(url, {
      method: "POST",
      headers: {
        Authorization: `Basic ${auth}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: new URLSearchParams({
        To: formatPhoneNumber(to),
        From: TWILIO_PHONE_NUMBER,
        Body: body,
      }).toString(),
    });

    const data = await response.json();

    if (response.ok) {
      return { success: true, messageId: data.sid };
    } else {
      return { success: false, error: data.message || "Failed to send SMS" };
    }
  } catch (error: any) {
    console.error("Error sending SMS:", error);
    return { success: false, error: error.message };
  }
}

/**
 * Format phone number to E.164 format
 */
function formatPhoneNumber(phone: string): string {
  // Remove all non-numeric characters
  const cleaned = phone.replace(/\D/g, "");

  // If it doesn't start with country code, assume US (+1)
  if (cleaned.length === 10) {
    return `+1${cleaned}`;
  }

  // If it already has country code
  if (cleaned.length > 10) {
    return `+${cleaned}`;
  }

  return phone;
}

/**
 * Generate reminder message from template
 */
export function generateReminderMessage(
  template: string,
  variables: {
    invoice_number: string;
    business_name: string;
    total: string;
    due_date?: string;
    days_overdue?: number;
    payment_link?: string;
  }
): string {
  let message = template;

  // Replace template variables
  message = message.replace(/\{\{invoice_number\}\}/g, variables.invoice_number);
  message = message.replace(/\{\{business_name\}\}/g, variables.business_name);
  message = message.replace(/\{\{total\}\}/g, variables.total);

  if (variables.due_date) {
    message = message.replace(/\{\{due_date\}\}/g, variables.due_date);
  }

  if (variables.days_overdue !== undefined) {
    message = message.replace(/\{\{days_overdue\}\}/g, String(variables.days_overdue));
  }

  if (variables.payment_link) {
    message = message.replace(/\{\{payment_link\}\}/g, variables.payment_link);
  }

  return message;
}

/**
 * Default reminder message templates
 */
export const DEFAULT_REMINDER_TEMPLATES = {
  friendly: `Hi! This is a friendly reminder about invoice {{invoice_number}} from {{business_name}}. Amount due: {{total}}. Thank you for your business!`,

  standard: `Reminder: Invoice {{invoice_number}} from {{business_name}} for {{total}} is now {{days_overdue}} days overdue. Please arrange payment at your earliest convenience.`,

  urgent: `URGENT: Invoice {{invoice_number}} from {{business_name}} for {{total}} is {{days_overdue}} days past due. Immediate payment is required. Pay now: {{payment_link}}`,

  final: `FINAL NOTICE: Invoice {{invoice_number}} ({{total}}) is seriously overdue. Please contact {{business_name}} immediately to arrange payment and avoid further action.`,
};

/**
 * Get appropriate template based on days overdue
 */
export function getTemplateForDaysOverdue(daysOverdue: number): string {
  if (daysOverdue <= 3) {
    return DEFAULT_REMINDER_TEMPLATES.friendly;
  } else if (daysOverdue <= 7) {
    return DEFAULT_REMINDER_TEMPLATES.standard;
  } else if (daysOverdue <= 14) {
    return DEFAULT_REMINDER_TEMPLATES.urgent;
  } else {
    return DEFAULT_REMINDER_TEMPLATES.final;
  }
}


=================================================================================
FILE: ./store/useClientStore.ts
=================================================================================

import { create } from "zustand";
import { Client, ClientInsert, ClientUpdate } from "@/types/database";
import * as db from "@/services/database";

interface ClientState {
  // Data
  clients: Client[];
  currentClient: Client | null;
  searchResults: Client[];

  // Loading states
  isLoading: boolean;
  isSearching: boolean;
  isSaving: boolean;

  // Actions
  fetchClients: () => Promise<void>;
  fetchClient: (id: string) => Promise<void>;
  createClient: (client: Omit<ClientInsert, "user_id">) => Promise<Client | null>;
  updateClient: (id: string, updates: ClientUpdate) => Promise<void>;
  deleteClient: (id: string) => Promise<void>;
  searchClients: (query: string) => Promise<void>;
  clearSearch: () => void;

  // Reset
  reset: () => void;
}

export const useClientStore = create<ClientState>((set, get) => ({
  clients: [],
  currentClient: null,
  searchResults: [],
  isLoading: false,
  isSearching: false,
  isSaving: false,

  fetchClients: async () => {
    set({ isLoading: true });
    try {
      const clients = await db.getClients();
      set({ clients, isLoading: false });
    } catch (error) {
      console.error("Error fetching clients:", error);
      set({ isLoading: false });
    }
  },

  fetchClient: async (id: string) => {
    set({ isLoading: true });
    try {
      const client = await db.getClient(id);
      set({ currentClient: client, isLoading: false });
    } catch (error) {
      console.error("Error fetching client:", error);
      set({ isLoading: false });
    }
  },

  createClient: async (client) => {
    set({ isSaving: true });
    try {
      const newClient = await db.createClient(client);
      if (newClient) {
        set((state) => ({
          clients: [...state.clients, newClient].sort((a, b) =>
            a.name.localeCompare(b.name)
          ),
          isSaving: false,
        }));
        return newClient;
      }
      set({ isSaving: false });
      return null;
    } catch (error) {
      console.error("Error creating client:", error);
      set({ isSaving: false });
      throw error;
    }
  },

  updateClient: async (id: string, updates: ClientUpdate) => {
    set({ isSaving: true });
    try {
      const updated = await db.updateClient(id, updates);
      if (updated) {
        set((state) => ({
          clients: state.clients
            .map((c) => (c.id === id ? updated : c))
            .sort((a, b) => a.name.localeCompare(b.name)),
          currentClient:
            state.currentClient?.id === id ? updated : state.currentClient,
          isSaving: false,
        }));
      } else {
        set({ isSaving: false });
      }
    } catch (error) {
      console.error("Error updating client:", error);
      set({ isSaving: false });
      throw error;
    }
  },

  deleteClient: async (id: string) => {
    try {
      const success = await db.deleteClient(id);
      if (success) {
        set((state) => ({
          clients: state.clients.filter((c) => c.id !== id),
          currentClient:
            state.currentClient?.id === id ? null : state.currentClient,
        }));
      }
    } catch (error) {
      console.error("Error deleting client:", error);
      throw error;
    }
  },

  searchClients: async (query: string) => {
    if (!query.trim()) {
      set({ searchResults: [] });
      return;
    }

    set({ isSearching: true });
    try {
      const results = await db.searchClients(query);
      set({ searchResults: results, isSearching: false });
    } catch (error) {
      console.error("Error searching clients:", error);
      set({ isSearching: false });
    }
  },

  clearSearch: () => set({ searchResults: [] }),

  reset: () =>
    set({
      clients: [],
      currentClient: null,
      searchResults: [],
      isLoading: false,
      isSearching: false,
      isSaving: false,
    }),
}));


=================================================================================
FILE: ./store/useDashboardStore.ts
=================================================================================

import { create } from "zustand";
import { DashboardStats } from "@/types";
import * as db from "@/services/database";

interface DashboardState {
  // Data
  stats: DashboardStats;

  // Loading state
  isLoading: boolean;

  // Actions
  fetchDashboardStats: () => Promise<void>;

  // Reset
  reset: () => void;
}

const defaultStats: DashboardStats = {
  totalRevenue: 0,
  pendingAmount: 0,
  invoiceCount: 0,
  paidCount: 0,
  overdueCount: 0,
};

export const useDashboardStore = create<DashboardState>((set) => ({
  stats: defaultStats,
  isLoading: false,

  fetchDashboardStats: async () => {
    set({ isLoading: true });
    try {
      const stats = await db.getDashboardStats();
      set({ stats, isLoading: false });
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      set({ isLoading: false });
    }
  },

  reset: () =>
    set({
      stats: defaultStats,
      isLoading: false,
    }),
}));


=================================================================================
FILE: ./store/useInvoiceStore.ts
=================================================================================

import { create } from "zustand";
import { Invoice, InvoiceItem } from "@/types/database";
import * as db from "@/services/database";

// Parsed invoice from AI (before saving to database)
export interface ParsedInvoice {
  clientName: string;
  clientEmail?: string;
  clientPhone?: string;
  items: {
    description: string;
    price: number;
    quantity?: number;
    originalTranscriptSegment?: string;
  }[];
  detectedLanguage: string;
  confidence?: number;
  notes?: string;
}

interface InvoiceState {
  // Data
  invoices: Invoice[];
  currentInvoice: { invoice: Invoice; items: InvoiceItem[] } | null;
  pendingInvoice: ParsedInvoice | null;

  // Loading states
  isLoading: boolean;
  isCreating: boolean;

  // Actions
  fetchInvoices: () => Promise<void>;
  fetchInvoice: (id: string) => Promise<void>;
  createInvoice: (
    invoice: Omit<Parameters<typeof db.createInvoice>[0], "user_id">,
    items: Parameters<typeof db.createInvoice>[1]
  ) => Promise<Invoice | null>;
  updateInvoice: (id: string, updates: Partial<Invoice>) => Promise<void>;
  updateInvoiceStatus: (id: string, status: Invoice["status"]) => Promise<void>;
  deleteInvoice: (id: string) => Promise<void>;

  // Pending invoice (from AI parsing)
  setPendingInvoice: (invoice: ParsedInvoice | null) => void;
  clearPendingInvoice: () => void;

  // Reset
  reset: () => void;
}

export const useInvoiceStore = create<InvoiceState>((set, get) => ({
  invoices: [],
  currentInvoice: null,
  pendingInvoice: null,
  isLoading: false,
  isCreating: false,

  fetchInvoices: async () => {
    set({ isLoading: true });
    try {
      const invoices = await db.getInvoices();
      set({ invoices, isLoading: false });
    } catch (error) {
      console.error("Error fetching invoices:", error);
      set({ isLoading: false });
    }
  },

  fetchInvoice: async (id: string) => {
    set({ isLoading: true });
    try {
      const result = await db.getInvoiceWithItems(id);
      set({ currentInvoice: result, isLoading: false });
    } catch (error) {
      console.error("Error fetching invoice:", error);
      set({ isLoading: false });
    }
  },

  createInvoice: async (invoice, items) => {
    set({ isCreating: true });
    try {
      const result = await db.createInvoice(invoice, items);
      if (result) {
        set((state) => ({
          invoices: [result.invoice, ...state.invoices],
          isCreating: false,
        }));
        return result.invoice;
      }
      set({ isCreating: false });
      return null;
    } catch (error) {
      console.error("Error creating invoice:", error);
      set({ isCreating: false });
      throw error;
    }
  },

  updateInvoice: async (id: string, updates: Partial<Invoice>) => {
    try {
      const updated = await db.updateInvoice(id, updates);
      if (updated) {
        set((state) => ({
          invoices: state.invoices.map((inv) =>
            inv.id === id ? { ...inv, ...updated } : inv
          ),
          currentInvoice:
            state.currentInvoice?.invoice.id === id
              ? { ...state.currentInvoice, invoice: updated }
              : state.currentInvoice,
        }));
      }
    } catch (error) {
      console.error("Error updating invoice:", error);
      throw error;
    }
  },

  updateInvoiceStatus: async (id: string, status: Invoice["status"]) => {
    try {
      const updated = await db.updateInvoiceStatus(id, status);
      if (updated) {
        set((state) => ({
          invoices: state.invoices.map((inv) =>
            inv.id === id ? { ...inv, ...updated } : inv
          ),
          currentInvoice:
            state.currentInvoice?.invoice.id === id
              ? { ...state.currentInvoice, invoice: updated }
              : state.currentInvoice,
        }));
      }
    } catch (error) {
      console.error("Error updating invoice status:", error);
      throw error;
    }
  },

  deleteInvoice: async (id: string) => {
    try {
      const success = await db.deleteInvoice(id);
      if (success) {
        set((state) => ({
          invoices: state.invoices.filter((inv) => inv.id !== id),
          currentInvoice:
            state.currentInvoice?.invoice.id === id ? null : state.currentInvoice,
        }));
      }
    } catch (error) {
      console.error("Error deleting invoice:", error);
      throw error;
    }
  },

  setPendingInvoice: (invoice) => set({ pendingInvoice: invoice }),

  clearPendingInvoice: () => set({ pendingInvoice: null }),

  reset: () =>
    set({
      invoices: [],
      currentInvoice: null,
      pendingInvoice: null,
      isLoading: false,
      isCreating: false,
    }),
}));


=================================================================================
FILE: ./store/useOfflineStore.ts
=================================================================================

import { create } from "zustand";
import * as offline from "@/services/offline";

interface OfflineState {
  // Connection state
  isOnline: boolean;
  isInitialized: boolean;

  // Pending counts
  pendingUploads: number;
  pendingOperations: number;
  draftCount: number;

  // Sync state
  isSyncing: boolean;
  lastSyncTime: string | null;

  // Actions
  initialize: () => Promise<void>;
  setOnline: (online: boolean) => void;
  syncNow: () => Promise<{ uploads: number; operations: number; errors: number }>;
  refreshCounts: () => Promise<void>;

  // Draft management
  getDrafts: () => Promise<offline.DraftInvoice[]>;
  saveDraft: (draft: Omit<offline.DraftInvoice, "id" | "createdAt" | "updatedAt">) => Promise<string>;
  updateDraft: (id: string, updates: Partial<offline.DraftInvoice>) => Promise<void>;
  deleteDraft: (id: string) => Promise<void>;

  // Reset
  reset: () => void;
}

// Re-export types for convenience
export type { DraftInvoice } from "@/services/offline";

export const useOfflineStore = create<OfflineState>((set, get) => ({
  isOnline: true,
  isInitialized: false,
  pendingUploads: 0,
  pendingOperations: 0,
  draftCount: 0,
  isSyncing: false,
  lastSyncTime: null,

  initialize: async () => {
    // Initialize offline service
    await offline.initOfflineService();

    // Subscribe to connection changes
    offline.subscribeToConnectionChanges((online) => {
      set({ isOnline: online });

      // Auto-sync when coming online
      if (online) {
        get().syncNow();
      }
    });

    // Get initial counts
    const counts = await offline.getPendingCounts();
    const lastSync = await offline.getLastSyncTime();

    set({
      isInitialized: true,
      isOnline: offline.checkIsOnline(),
      pendingUploads: counts.uploads,
      pendingOperations: counts.operations,
      draftCount: counts.drafts,
      lastSyncTime: lastSync,
    });
  },

  setOnline: (online) => {
    set({ isOnline: online });
  },

  syncNow: async () => {
    if (get().isSyncing || !get().isOnline) {
      return { uploads: 0, operations: 0, errors: 0 };
    }

    set({ isSyncing: true });

    try {
      const result = await offline.syncPendingItems();

      // Refresh counts after sync
      await get().refreshCounts();

      const lastSync = await offline.getLastSyncTime();
      set({ lastSyncTime: lastSync });

      return result;
    } finally {
      set({ isSyncing: false });
    }
  },

  refreshCounts: async () => {
    const counts = await offline.getPendingCounts();
    set({
      pendingUploads: counts.uploads,
      pendingOperations: counts.operations,
      draftCount: counts.drafts,
    });
  },

  getDrafts: async () => {
    return offline.getDraftInvoices();
  },

  saveDraft: async (draft) => {
    const id = await offline.saveDraftInvoice(draft);
    await get().refreshCounts();
    return id;
  },

  updateDraft: async (id, updates) => {
    await offline.updateDraftInvoice(id, updates);
  },

  deleteDraft: async (id) => {
    await offline.deleteDraftInvoice(id);
    await get().refreshCounts();
  },

  reset: () => {
    set({
      isOnline: true,
      isInitialized: false,
      pendingUploads: 0,
      pendingOperations: 0,
      draftCount: 0,
      isSyncing: false,
      lastSyncTime: null,
    });
  },
}));


=================================================================================
FILE: ./store/useProfileStore.ts
=================================================================================

import { create } from "zustand";
import { Profile, ProfileUpdate } from "@/types/database";
import * as db from "@/services/database";

interface ProfileState {
  // Data
  profile: Profile | null;

  // Loading states
  isLoading: boolean;
  isSaving: boolean;

  // Actions
  fetchProfile: () => Promise<void>;
  updateProfile: (updates: ProfileUpdate) => Promise<void>;
  uploadLogo: (uri: string) => Promise<string | null>;

  // Reset
  reset: () => void;
}

export const useProfileStore = create<ProfileState>((set, get) => ({
  profile: null,
  isLoading: false,
  isSaving: false,

  fetchProfile: async () => {
    set({ isLoading: true });
    try {
      const profile = await db.getProfile();
      set({ profile, isLoading: false });
    } catch (error) {
      console.error("Error fetching profile:", error);
      set({ isLoading: false });
    }
  },

  updateProfile: async (updates: ProfileUpdate) => {
    set({ isSaving: true });
    try {
      const updated = await db.updateProfile(updates);
      if (updated) {
        set({ profile: updated, isSaving: false });
      } else {
        set({ isSaving: false });
      }
    } catch (error) {
      console.error("Error updating profile:", error);
      set({ isSaving: false });
      throw error;
    }
  },

  uploadLogo: async (uri: string) => {
    try {
      const fileName = `logo-${Date.now()}.jpg`;
      const logoUrl = await db.uploadLogo(uri, fileName);

      if (logoUrl) {
        // Update profile with new logo URL
        await get().updateProfile({ logo_url: logoUrl });
        return logoUrl;
      }
      return null;
    } catch (error) {
      console.error("Error uploading logo:", error);
      throw error;
    }
  },

  reset: () =>
    set({
      profile: null,
      isLoading: false,
      isSaving: false,
    }),
}));


=================================================================================
FILE: ./store/useReminderStore.ts
=================================================================================

import { create } from "zustand";
import { ReminderSettings, ReminderSettingsInsert } from "@/types/database";
import * as db from "@/services/database";

interface ReminderState {
  // Data
  settings: ReminderSettings | null;
  isLoading: boolean;
  isSaving: boolean;

  // Actions
  fetchSettings: () => Promise<void>;
  updateSettings: (updates: Partial<ReminderSettingsInsert>) => Promise<void>;
  toggleEnabled: () => Promise<void>;
  toggleSMS: () => Promise<void>;
  toggleEmail: () => Promise<void>;
  setDayIntervals: (intervals: number[]) => Promise<void>;
  setMessageTemplate: (template: string) => Promise<void>;

  // Reset
  reset: () => void;
}

const DEFAULT_SETTINGS: Omit<ReminderSettingsInsert, "user_id"> = {
  enabled: false,
  day_intervals: [3, 7, 14],
  email_enabled: true,
  sms_enabled: false,
  message_template:
    "This is an automated reminder for invoice {{invoice_number}} from {{business_name}}. Amount due: {{total}}. Please pay at your earliest convenience.",
};

export const useReminderStore = create<ReminderState>((set, get) => ({
  settings: null,
  isLoading: false,
  isSaving: false,

  fetchSettings: async () => {
    set({ isLoading: true });
    try {
      const settings = await db.getReminderSettings();
      set({ settings, isLoading: false });
    } catch (error) {
      console.error("Error fetching reminder settings:", error);
      set({ isLoading: false });
    }
  },

  updateSettings: async (updates) => {
    set({ isSaving: true });
    try {
      const currentSettings = get().settings;
      const newSettings = {
        ...DEFAULT_SETTINGS,
        ...currentSettings,
        ...updates,
      };

      const saved = await db.upsertReminderSettings(newSettings);
      set({ settings: saved, isSaving: false });
    } catch (error) {
      console.error("Error updating reminder settings:", error);
      set({ isSaving: false });
      throw error;
    }
  },

  toggleEnabled: async () => {
    const current = get().settings;
    await get().updateSettings({ enabled: !current?.enabled });
  },

  toggleSMS: async () => {
    const current = get().settings;
    await get().updateSettings({ sms_enabled: !current?.sms_enabled });
  },

  toggleEmail: async () => {
    const current = get().settings;
    await get().updateSettings({ email_enabled: !current?.email_enabled });
  },

  setDayIntervals: async (intervals: number[]) => {
    await get().updateSettings({ day_intervals: intervals });
  },

  setMessageTemplate: async (template: string) => {
    await get().updateSettings({ message_template: template });
  },

  reset: () =>
    set({
      settings: null,
      isLoading: false,
      isSaving: false,
    }),
}));


=================================================================================
FILE: ./supabase/functions/create-connect-account/index.ts
=================================================================================

/**
 * Edge Function: create-connect-account
 * Creates Stripe Connect onboarding link for contractors
 * Per architecture-spec.md Section 4.2
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.4";
import Stripe from "https://esm.sh/stripe@14.5.0";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, {
  apiVersion: "2023-10-16",
});

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Get user from JWT
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      throw new Error("Missing authorization header");
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Verify JWT and get user
    const token = authHeader.replace("Bearer ", "");
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      throw new Error("Invalid token");
    }

    // Get user profile
    const { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", user.id)
      .single();

    if (profileError || !profile) {
      throw new Error("Profile not found");
    }

    let stripeAccountId = profile.stripe_account_id;

    // Create Stripe Connect account if doesn't exist
    if (!stripeAccountId) {
      const account = await stripe.accounts.create({
        type: "standard",
        email: user.email,
        metadata: {
          supabase_user_id: user.id,
        },
      });

      stripeAccountId = account.id;

      // Save account ID to profile
      await supabase
        .from("profiles")
        .update({ stripe_account_id: stripeAccountId })
        .eq("id", user.id);
    }

    // Parse request body for return URLs
    const { return_url, refresh_url } = await req.json();

    // Create account link for onboarding
    const accountLink = await stripe.accountLinks.create({
      account: stripeAccountId,
      refresh_url: refresh_url || "contractorpro://stripe/refresh",
      return_url: return_url || "contractorpro://stripe/return",
      type: "account_onboarding",
    });

    return new Response(
      JSON.stringify({
        url: accountLink.url,
        account_id: stripeAccountId,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("Error creating connect account:", error);

    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});


=================================================================================
FILE: ./supabase/functions/export-quickbooks/index.ts
=================================================================================

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

/**
 * Export QuickBooks Edge Function
 * Exports invoices in QuickBooks-compatible CSV/IIF format
 * Per product-strategy.md Section 3.4
 */
serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Verify authentication
    const authHeader = req.headers.get("authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "No authorization header" }),
        { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Create Supabase client with user's JWT
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_ANON_KEY") ?? "",
      {
        global: { headers: { Authorization: authHeader } },
      }
    );

    // Get user from JWT
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: "Invalid token" }),
        { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Parse request body
    const body = await req.json().catch(() => ({}));
    const {
      format = "csv", // "csv" or "iif"
      startDate,
      endDate,
      status, // Optional filter by status
      includeItems = true,
    } = body;

    // Build query
    let query = supabase
      .from("invoices")
      .select(`
        *,
        clients (
          name,
          email,
          address
        ),
        invoice_items (
          description,
          quantity,
          unit_price,
          total
        )
      `)
      .eq("user_id", user.id)
      .order("created_at", { ascending: false });

    // Apply date filters
    if (startDate) {
      query = query.gte("created_at", startDate);
    }
    if (endDate) {
      query = query.lte("created_at", endDate);
    }
    if (status) {
      query = query.eq("status", status);
    }

    const { data: invoices, error: invoicesError } = await query;

    if (invoicesError) {
      console.error("Error fetching invoices:", invoicesError);
      throw invoicesError;
    }

    if (!invoices || invoices.length === 0) {
      return new Response(
        JSON.stringify({ error: "No invoices found for the specified criteria" }),
        { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Get user profile for business info
    const { data: profile } = await supabase
      .from("profiles")
      .select("business_name, full_name")
      .eq("id", user.id)
      .single();

    const businessName = profile?.business_name || profile?.full_name || "My Business";

    let exportContent: string;
    let contentType: string;
    let filename: string;

    if (format === "iif") {
      // QuickBooks IIF format
      exportContent = generateIIF(invoices, businessName, includeItems);
      contentType = "application/x-iif";
      filename = `invoices_export_${formatDateForFilename(new Date())}.iif`;
    } else {
      // CSV format (default)
      exportContent = generateCSV(invoices, includeItems);
      contentType = "text/csv";
      filename = `invoices_export_${formatDateForFilename(new Date())}.csv`;
    }

    return new Response(exportContent, {
      headers: {
        ...corsHeaders,
        "Content-Type": contentType,
        "Content-Disposition": `attachment; filename="${filename}"`,
      },
    });
  } catch (error: any) {
    console.error("Error in export-quickbooks function:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});

/**
 * Generate CSV export
 */
function generateCSV(invoices: any[], includeItems: boolean): string {
  const rows: string[] = [];

  if (includeItems) {
    // Header for detailed export with line items
    rows.push([
      "Invoice Number",
      "Date",
      "Due Date",
      "Client Name",
      "Client Email",
      "Status",
      "Item Description",
      "Quantity",
      "Unit Price",
      "Item Total",
      "Invoice Subtotal",
      "Tax Amount",
      "Invoice Total",
      "Currency",
      "Paid Date",
      "Notes",
    ].map(escapeCSV).join(","));

    // Data rows
    for (const invoice of invoices) {
      const baseRow = {
        invoiceNumber: invoice.invoice_number,
        date: formatDate(invoice.created_at),
        dueDate: formatDate(invoice.due_date),
        clientName: invoice.clients?.name || "",
        clientEmail: invoice.clients?.email || "",
        status: invoice.status,
        subtotal: formatCurrency(invoice.subtotal, invoice.currency),
        taxAmount: formatCurrency(invoice.tax_amount, invoice.currency),
        total: formatCurrency(invoice.total, invoice.currency),
        currency: invoice.currency || "USD",
        paidDate: invoice.paid_at ? formatDate(invoice.paid_at) : "",
        notes: invoice.notes || "",
      };

      const items = invoice.invoice_items || [];

      if (items.length > 0) {
        // One row per line item
        for (const item of items) {
          rows.push([
            baseRow.invoiceNumber,
            baseRow.date,
            baseRow.dueDate,
            baseRow.clientName,
            baseRow.clientEmail,
            baseRow.status,
            item.description || "",
            String(item.quantity || 1),
            formatCurrency(item.unit_price, invoice.currency),
            formatCurrency(item.total, invoice.currency),
            baseRow.subtotal,
            baseRow.taxAmount,
            baseRow.total,
            baseRow.currency,
            baseRow.paidDate,
            baseRow.notes,
          ].map(escapeCSV).join(","));
        }
      } else {
        // Invoice with no items
        rows.push([
          baseRow.invoiceNumber,
          baseRow.date,
          baseRow.dueDate,
          baseRow.clientName,
          baseRow.clientEmail,
          baseRow.status,
          "",
          "",
          "",
          "",
          baseRow.subtotal,
          baseRow.taxAmount,
          baseRow.total,
          baseRow.currency,
          baseRow.paidDate,
          baseRow.notes,
        ].map(escapeCSV).join(","));
      }
    }
  } else {
    // Header for summary export
    rows.push([
      "Invoice Number",
      "Date",
      "Due Date",
      "Client Name",
      "Client Email",
      "Status",
      "Subtotal",
      "Tax Amount",
      "Total",
      "Currency",
      "Paid Date",
      "Notes",
    ].map(escapeCSV).join(","));

    // Data rows
    for (const invoice of invoices) {
      rows.push([
        invoice.invoice_number,
        formatDate(invoice.created_at),
        formatDate(invoice.due_date),
        invoice.clients?.name || "",
        invoice.clients?.email || "",
        invoice.status,
        formatCurrency(invoice.subtotal, invoice.currency),
        formatCurrency(invoice.tax_amount, invoice.currency),
        formatCurrency(invoice.total, invoice.currency),
        invoice.currency || "USD",
        invoice.paid_at ? formatDate(invoice.paid_at) : "",
        invoice.notes || "",
      ].map(escapeCSV).join(","));
    }
  }

  return rows.join("\n");
}

/**
 * Generate QuickBooks IIF (Intuit Interchange Format) export
 * Reference: https://quickbooks.intuit.com/learn-support/en-us/import-export-data-files/iif-files-overview/00/186368
 */
function generateIIF(invoices: any[], businessName: string, includeItems: boolean): string {
  const lines: string[] = [];

  // IIF Header for invoices
  lines.push("!TRNS\tTRNSTYPE\tDATE\tACCNT\tNAME\tCLASS\tAMOUNT\tDOCNUM\tMEMO");
  lines.push("!SPL\tTRNSTYPE\tDATE\tACCNT\tNAME\tCLASS\tAMOUNT\tDOCNUM\tMEMO\tQNTY\tPRICE");
  lines.push("!ENDTRNS");

  for (const invoice of invoices) {
    const clientName = invoice.clients?.name || "Customer";
    const invoiceDate = formatDateIIF(invoice.created_at);
    const total = invoice.total / 100; // Convert from cents
    const items = invoice.invoice_items || [];

    // Transaction header (debit to Accounts Receivable)
    lines.push(
      `TRNS\tINVOICE\t${invoiceDate}\tAccounts Receivable\t${escapeIIF(clientName)}\t\t${total.toFixed(2)}\t${invoice.invoice_number}\t${escapeIIF(invoice.notes || "")}`
    );

    if (includeItems && items.length > 0) {
      // Split lines for each item (credit to Income)
      for (const item of items) {
        const itemTotal = (item.total || 0) / 100;
        const quantity = item.quantity || 1;
        const price = (item.unit_price || 0) / 100;

        lines.push(
          `SPL\tINVOICE\t${invoiceDate}\tSales Income\t${escapeIIF(clientName)}\t\t-${itemTotal.toFixed(2)}\t${invoice.invoice_number}\t${escapeIIF(item.description || "")}\t${quantity}\t${price.toFixed(2)}`
        );
      }
    } else {
      // Single split line for total
      lines.push(
        `SPL\tINVOICE\t${invoiceDate}\tSales Income\t${escapeIIF(clientName)}\t\t-${total.toFixed(2)}\t${invoice.invoice_number}\t\t1\t${total.toFixed(2)}`
      );
    }

    // Tax line if applicable
    if (invoice.tax_amount && invoice.tax_amount > 0) {
      const taxAmount = invoice.tax_amount / 100;
      lines.push(
        `SPL\tINVOICE\t${invoiceDate}\tSales Tax Payable\t${escapeIIF(clientName)}\t\t-${taxAmount.toFixed(2)}\t${invoice.invoice_number}\tSales Tax\t\t`
      );
    }

    lines.push("ENDTRNS");
  }

  return lines.join("\n");
}

/**
 * Helper functions
 */
function escapeCSV(value: string): string {
  if (value == null) return "";
  const str = String(value);
  // Escape quotes and wrap in quotes if contains special characters
  if (str.includes(",") || str.includes('"') || str.includes("\n")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

function escapeIIF(value: string): string {
  if (value == null) return "";
  // IIF uses tabs as delimiters, remove them from values
  return String(value).replace(/\t/g, " ").replace(/\n/g, " ");
}

function formatDate(dateString: string | null): string {
  if (!dateString) return "";
  const date = new Date(dateString);
  return date.toISOString().split("T")[0]; // YYYY-MM-DD
}

function formatDateIIF(dateString: string | null): string {
  if (!dateString) return "";
  const date = new Date(dateString);
  // IIF uses MM/DD/YYYY format
  return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
}

function formatDateForFilename(date: Date): string {
  return date.toISOString().split("T")[0].replace(/-/g, "");
}

function formatCurrency(cents: number | null, currency: string = "USD"): string {
  if (cents == null) return "0.00";
  return (cents / 100).toFixed(2);
}


=================================================================================
FILE: ./supabase/functions/generate-invoice-pdf/index.ts
=================================================================================

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

interface InvoiceData {
  id: string;
  invoice_number: string;
  client_name: string;
  client_email?: string;
  status: string;
  subtotal: number;
  tax_amount: number;
  total: number;
  currency: string;
  due_date?: string;
  created_at: string;
  notes?: string;
  items: Array<{
    description: string;
    quantity: number;
    unit_price: number;
    total: number;
  }>;
  profile: {
    business_name?: string;
    full_name?: string;
    logo_url?: string;
    tax_rate: number;
  };
}

/**
 * Generate Invoice PDF Edge Function
 *
 * Creates a PDF invoice and stores it in Supabase Storage.
 * Returns a signed URL for download/sharing.
 */
serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Verify authentication
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: "Missing authorization header" }),
        { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    const supabaseClient = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_ANON_KEY") ?? "",
      { global: { headers: { Authorization: authHeader } } }
    );

    // Get user
    const { data: { user }, error: userError } = await supabaseClient.auth.getUser();
    if (userError || !user) {
      return new Response(
        JSON.stringify({ error: "Unauthorized" }),
        { status: 401, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Parse request body
    const { invoice_id } = await req.json();
    if (!invoice_id) {
      return new Response(
        JSON.stringify({ error: "Missing invoice_id" }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Fetch invoice with items
    const { data: invoice, error: invoiceError } = await supabaseClient
      .from("invoices")
      .select(`
        *,
        invoice_items (*)
      `)
      .eq("id", invoice_id)
      .eq("user_id", user.id)
      .single();

    if (invoiceError || !invoice) {
      return new Response(
        JSON.stringify({ error: "Invoice not found" }),
        { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Fetch profile for branding
    const { data: profile } = await supabaseClient
      .from("profiles")
      .select("business_name, full_name, logo_url, tax_rate")
      .eq("id", user.id)
      .single();

    // Generate HTML for PDF
    const html = generateInvoiceHTML({
      ...invoice,
      items: invoice.invoice_items,
      profile: profile || { tax_rate: 0 },
    });

    // For now, we'll store the HTML as a simple text file
    // In production, you'd use a PDF generation service like:
    // - Puppeteer (via Deno Deploy or separate service)
    // - pdf-lib for programmatic PDF creation
    // - External API like DocRaptor, PDFShift, etc.

    // Generate PDF using external service or library
    // For MVP, we'll create a simple HTML file that can be printed to PDF
    const pdfContent = generatePrintableHTML({
      ...invoice,
      items: invoice.invoice_items,
      profile: profile || { tax_rate: 0 },
    });

    const fileName = `${user.id}/${invoice.invoice_number.replace(/\s/g, "_")}.html`;

    // Upload to storage
    const { error: uploadError } = await supabaseClient.storage
      .from("invoice-pdfs")
      .upload(fileName, pdfContent, {
        contentType: "text/html",
        upsert: true,
      });

    if (uploadError) {
      console.error("Upload error:", uploadError);
      return new Response(
        JSON.stringify({ error: "Failed to generate PDF" }),
        { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Get signed URL (valid for 1 hour)
    const { data: signedUrl } = await supabaseClient.storage
      .from("invoice-pdfs")
      .createSignedUrl(fileName, 3600);

    // Update invoice with PDF URL
    await supabaseClient
      .from("invoices")
      .update({ pdf_url: signedUrl?.signedUrl })
      .eq("id", invoice_id);

    return new Response(
      JSON.stringify({
        success: true,
        pdf_url: signedUrl?.signedUrl,
        file_name: fileName,
      }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error) {
    console.error("Error generating PDF:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});

function formatCurrency(cents: number, currency: string = "USD"): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(cents / 100);
}

function formatDate(dateString: string): string {
  return new Date(dateString).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

function generateInvoiceHTML(invoice: InvoiceData): string {
  const businessName = invoice.profile.business_name || invoice.profile.full_name || "ContractorPro";

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Invoice ${invoice.invoice_number}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #1a1a1a;
      line-height: 1.5;
      padding: 40px;
      max-width: 800px;
      margin: 0 auto;
    }
    .header { display: flex; justify-content: space-between; margin-bottom: 40px; }
    .logo { font-size: 24px; font-weight: 700; color: #00D632; }
    .invoice-number { text-align: right; }
    .invoice-number h2 { font-size: 14px; color: #666; text-transform: uppercase; }
    .invoice-number p { font-size: 20px; font-weight: 600; }
    .addresses { display: flex; justify-content: space-between; margin-bottom: 40px; }
    .address { flex: 1; }
    .address h3 { font-size: 12px; color: #666; text-transform: uppercase; margin-bottom: 8px; }
    .address p { font-size: 14px; }
    .dates { display: flex; gap: 40px; margin-bottom: 40px; }
    .date h3 { font-size: 12px; color: #666; text-transform: uppercase; margin-bottom: 4px; }
    .date p { font-size: 14px; font-weight: 500; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 24px; }
    th { text-align: left; padding: 12px 0; border-bottom: 2px solid #e5e5e5; font-size: 12px; color: #666; text-transform: uppercase; }
    td { padding: 16px 0; border-bottom: 1px solid #f0f0f0; }
    .item-desc { font-weight: 500; }
    .item-meta { font-size: 13px; color: #666; }
    .text-right { text-align: right; }
    .totals { margin-left: auto; width: 280px; }
    .total-row { display: flex; justify-content: space-between; padding: 8px 0; }
    .total-row.grand { border-top: 2px solid #1a1a1a; padding-top: 16px; margin-top: 8px; font-size: 18px; font-weight: 700; }
    .total-row.grand .amount { color: #00D632; }
    .status { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: uppercase; }
    .status-paid { background: #dcfce7; color: #166534; }
    .status-sent { background: #dbeafe; color: #1e40af; }
    .status-draft { background: #f3f4f6; color: #4b5563; }
    .status-overdue { background: #fee2e2; color: #991b1b; }
    .footer { margin-top: 60px; padding-top: 20px; border-top: 1px solid #e5e5e5; text-align: center; color: #666; font-size: 13px; }
    @media print {
      body { padding: 20px; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo">${businessName}</div>
    <div class="invoice-number">
      <h2>Invoice</h2>
      <p>${invoice.invoice_number}</p>
    </div>
  </div>

  <div class="addresses">
    <div class="address">
      <h3>Bill To</h3>
      <p><strong>${invoice.client_name}</strong></p>
      ${invoice.client_email ? `<p>${invoice.client_email}</p>` : ""}
    </div>
    <div class="address" style="text-align: right;">
      <span class="status status-${invoice.status}">${invoice.status}</span>
    </div>
  </div>

  <div class="dates">
    <div class="date">
      <h3>Issue Date</h3>
      <p>${formatDate(invoice.created_at)}</p>
    </div>
    ${invoice.due_date ? `
    <div class="date">
      <h3>Due Date</h3>
      <p>${formatDate(invoice.due_date)}</p>
    </div>
    ` : ""}
  </div>

  <table>
    <thead>
      <tr>
        <th>Description</th>
        <th class="text-right">Qty</th>
        <th class="text-right">Rate</th>
        <th class="text-right">Amount</th>
      </tr>
    </thead>
    <tbody>
      ${invoice.items.map(item => `
      <tr>
        <td class="item-desc">${item.description}</td>
        <td class="text-right">${item.quantity}</td>
        <td class="text-right">${formatCurrency(item.unit_price, invoice.currency)}</td>
        <td class="text-right">${formatCurrency(item.total, invoice.currency)}</td>
      </tr>
      `).join("")}
    </tbody>
  </table>

  <div class="totals">
    <div class="total-row">
      <span>Subtotal</span>
      <span>${formatCurrency(invoice.subtotal, invoice.currency)}</span>
    </div>
    ${invoice.tax_amount > 0 ? `
    <div class="total-row">
      <span>Tax (${invoice.profile.tax_rate}%)</span>
      <span>${formatCurrency(invoice.tax_amount, invoice.currency)}</span>
    </div>
    ` : ""}
    <div class="total-row grand">
      <span>Total Due</span>
      <span class="amount">${formatCurrency(invoice.total, invoice.currency)}</span>
    </div>
  </div>

  ${invoice.notes ? `
  <div style="margin-top: 40px; padding: 16px; background: #f9fafb; border-radius: 8px;">
    <h3 style="font-size: 12px; color: #666; text-transform: uppercase; margin-bottom: 8px;">Notes</h3>
    <p style="font-size: 14px;">${invoice.notes}</p>
  </div>
  ` : ""}

  <div class="footer">
    <p>Thank you for your business!</p>
    <p style="margin-top: 8px;">Generated by ContractorPro</p>
  </div>
</body>
</html>
  `;
}

function generatePrintableHTML(invoice: InvoiceData): string {
  // Same as generateInvoiceHTML but with print-optimized styles
  return generateInvoiceHTML(invoice);
}


=================================================================================
FILE: ./supabase/functions/generate-payment-link/index.ts
=================================================================================

/**
 * Edge Function: generate-payment-link
 * Creates Stripe Payment Intent for invoice
 * Per architecture-spec.md Section 4.3 (Direct Charges)
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.4";
import Stripe from "https://esm.sh/stripe@14.5.0";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, {
  apiVersion: "2023-10-16",
});

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Platform fee percentage (1%)
const PLATFORM_FEE_PERCENT = 0.01;

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Authenticate user
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      throw new Error("Missing authorization header");
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    const token = authHeader.replace("Bearer ", "");
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      throw new Error("Invalid token");
    }

    // Get request body
    const { invoice_id } = await req.json();

    if (!invoice_id) {
      throw new Error("invoice_id is required");
    }

    // Get invoice
    const { data: invoice, error: invoiceError } = await supabase
      .from("invoices")
      .select("*")
      .eq("id", invoice_id)
      .eq("user_id", user.id)
      .single();

    if (invoiceError || !invoice) {
      throw new Error("Invoice not found");
    }

    // Get profile with Stripe account
    const { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("stripe_account_id, charges_enabled, business_name")
      .eq("id", user.id)
      .single();

    if (profileError || !profile) {
      throw new Error("Profile not found");
    }

    if (!profile.stripe_account_id || !profile.charges_enabled) {
      throw new Error("Stripe account not connected or charges not enabled");
    }

    // Calculate platform fee
    const platformFee = Math.round(invoice.total * PLATFORM_FEE_PERCENT);

    // Create Payment Intent with Direct Charges
    // Per architecture-spec.md Section 4.3
    const paymentIntent = await stripe.paymentIntents.create(
      {
        amount: invoice.total, // Already in cents
        currency: invoice.currency.toLowerCase(),
        application_fee_amount: platformFee,
        metadata: {
          supabase_invoice_id: invoice.id,
          supabase_user_id: user.id,
          invoice_number: invoice.invoice_number,
        },
        description: `Invoice ${invoice.invoice_number} from ${profile.business_name || "Contractor"}`,
      },
      {
        stripeAccount: profile.stripe_account_id, // Direct charge
      }
    );

    // Create a Payment Link for easy sharing
    // First, create a product and price
    const product = await stripe.products.create(
      {
        name: `Invoice ${invoice.invoice_number}`,
        description: `Payment for services - ${invoice.client_name}`,
      },
      { stripeAccount: profile.stripe_account_id }
    );

    const price = await stripe.prices.create(
      {
        unit_amount: invoice.total,
        currency: invoice.currency.toLowerCase(),
        product: product.id,
      },
      { stripeAccount: profile.stripe_account_id }
    );

    const paymentLink = await stripe.paymentLinks.create(
      {
        line_items: [{ price: price.id, quantity: 1 }],
        metadata: {
          supabase_invoice_id: invoice.id,
          supabase_user_id: user.id,
        },
        application_fee_amount: platformFee,
      },
      { stripeAccount: profile.stripe_account_id }
    );

    // Update invoice with Stripe info
    await supabase
      .from("invoices")
      .update({
        stripe_payment_intent_id: paymentIntent.id,
        stripe_hosted_invoice_url: paymentLink.url,
      })
      .eq("id", invoice_id);

    return new Response(
      JSON.stringify({
        payment_intent_id: paymentIntent.id,
        payment_link_url: paymentLink.url,
        client_secret: paymentIntent.client_secret,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("Error generating payment link:", error);

    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});


=================================================================================
FILE: ./supabase/functions/send-reminders/index.ts
=================================================================================

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

/**
 * Send Reminders Edge Function
 * Per product-strategy.md "Bad Cop" system
 *
 * Scheduled to run daily via Supabase cron:
 * SELECT cron.schedule('send-reminders', '0 9 * * *', $$
 *   SELECT net.http_post(
 *     url := 'https://your-project.supabase.co/functions/v1/send-reminders',
 *     headers := '{"Authorization": "Bearer your-service-role-key"}'::jsonb
 *   ) AS request_id;
 * $$);
 */
serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Use service role key for cron jobs
    const supabaseAdmin = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    const twilioAccountSid = Deno.env.get("TWILIO_ACCOUNT_SID");
    const twilioAuthToken = Deno.env.get("TWILIO_AUTH_TOKEN");
    const twilioPhoneNumber = Deno.env.get("TWILIO_PHONE_NUMBER");

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Get all users with reminders enabled
    const { data: reminderSettings, error: settingsError } = await supabaseAdmin
      .from("reminder_settings")
      .select(`
        *,
        profiles!inner (
          id,
          business_name,
          full_name
        )
      `)
      .eq("enabled", true);

    if (settingsError) {
      console.error("Error fetching reminder settings:", settingsError);
      throw settingsError;
    }

    let remindersSent = 0;
    let remindersSkipped = 0;
    const errors: string[] = [];

    // Process each user's reminders
    for (const settings of reminderSettings || []) {
      try {
        const userId = settings.user_id;
        const dayIntervals = settings.day_intervals || [3, 7, 14];
        const businessName = settings.profiles?.business_name || settings.profiles?.full_name || "Your contractor";

        // Get overdue invoices for this user
        const { data: invoices, error: invoicesError } = await supabaseAdmin
          .from("invoices")
          .select(`
            *,
            clients!inner (
              name,
              email,
              phone
            )
          `)
          .eq("user_id", userId)
          .in("status", ["sent", "overdue"])
          .lt("due_date", today.toISOString());

        if (invoicesError) {
          console.error(`Error fetching invoices for user ${userId}:`, invoicesError);
          continue;
        }

        // Process each overdue invoice
        for (const invoice of invoices || []) {
          const dueDate = new Date(invoice.due_date);
          const daysOverdue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));

          // Check if this is a reminder day
          if (!dayIntervals.includes(daysOverdue)) {
            continue;
          }

          // Check if we already sent a reminder today for this invoice
          const { data: existingReminder } = await supabaseAdmin
            .from("reminder_logs")
            .select("id")
            .eq("invoice_id", invoice.id)
            .gte("sent_at", today.toISOString())
            .limit(1);

          if (existingReminder && existingReminder.length > 0) {
            remindersSkipped++;
            continue;
          }

          // Update invoice status to overdue if not already
          if (invoice.status !== "overdue") {
            await supabaseAdmin
              .from("invoices")
              .update({ status: "overdue" })
              .eq("id", invoice.id);
          }

          // Prepare reminder message
          const message = generateReminderMessage(
            settings.message_template || DEFAULT_TEMPLATE,
            {
              invoice_number: invoice.invoice_number,
              business_name: businessName,
              total: formatCurrency(invoice.total, invoice.currency),
              days_overdue: daysOverdue,
              payment_link: invoice.stripe_hosted_invoice_url || "",
            }
          );

          // Send SMS if enabled and phone available
          if (settings.sms_enabled && invoice.clients?.phone && twilioAccountSid) {
            const smsResult = await sendTwilioSMS(
              twilioAccountSid,
              twilioAuthToken!,
              twilioPhoneNumber!,
              invoice.clients.phone,
              message
            );

            // Log the reminder
            await supabaseAdmin.from("reminder_logs").insert({
              invoice_id: invoice.id,
              reminder_type: "sms",
              status: smsResult.success ? "sent" : "failed",
              error_message: smsResult.error,
            });

            if (smsResult.success) {
              remindersSent++;
            } else {
              errors.push(`SMS failed for ${invoice.invoice_number}: ${smsResult.error}`);
            }
          }

          // Send email if enabled and email available
          if (settings.email_enabled && invoice.clients?.email) {
            // For now, log as pending - email would use SendGrid or similar
            await supabaseAdmin.from("reminder_logs").insert({
              invoice_id: invoice.id,
              reminder_type: "email",
              status: "pending",
            });
            // TODO: Implement SendGrid email sending
          }
        }
      } catch (userError: any) {
        errors.push(`Error processing user ${settings.user_id}: ${userError.message}`);
      }
    }

    return new Response(
      JSON.stringify({
        success: true,
        remindersSent,
        remindersSkipped,
        errors: errors.length > 0 ? errors : undefined,
        processedAt: new Date().toISOString(),
      }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error: any) {
    console.error("Error in send-reminders function:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});

const DEFAULT_TEMPLATE = `This is an automated reminder for invoice {{invoice_number}} from {{business_name}}. Amount due: {{total}}. This invoice is {{days_overdue}} days overdue. Please pay at your earliest convenience.`;

function generateReminderMessage(
  template: string,
  variables: {
    invoice_number: string;
    business_name: string;
    total: string;
    days_overdue: number;
    payment_link: string;
  }
): string {
  let message = template;

  message = message.replace(/\{\{invoice_number\}\}/g, variables.invoice_number);
  message = message.replace(/\{\{business_name\}\}/g, variables.business_name);
  message = message.replace(/\{\{total\}\}/g, variables.total);
  message = message.replace(/\{\{days_overdue\}\}/g, String(variables.days_overdue));

  if (variables.payment_link) {
    message = message.replace(/\{\{payment_link\}\}/g, variables.payment_link);
    message += `\n\nPay now: ${variables.payment_link}`;
  }

  return message;
}

function formatCurrency(cents: number, currency: string = "USD"): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(cents / 100);
}

async function sendTwilioSMS(
  accountSid: string,
  authToken: string,
  fromNumber: string,
  toNumber: string,
  body: string
): Promise<{ success: boolean; messageId?: string; error?: string }> {
  try {
    const url = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
    const auth = btoa(`${accountSid}:${authToken}`);

    // Format phone number
    const formattedTo = formatPhoneNumber(toNumber);

    const response = await fetch(url, {
      method: "POST",
      headers: {
        Authorization: `Basic ${auth}`,
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: new URLSearchParams({
        To: formattedTo,
        From: fromNumber,
        Body: body,
      }).toString(),
    });

    const data = await response.json();

    if (response.ok) {
      return { success: true, messageId: data.sid };
    } else {
      return { success: false, error: data.message || "Failed to send SMS" };
    }
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

function formatPhoneNumber(phone: string): string {
  const cleaned = phone.replace(/\D/g, "");
  if (cleaned.length === 10) {
    return `+1${cleaned}`;
  }
  if (cleaned.length > 10 && !cleaned.startsWith("+")) {
    return `+${cleaned}`;
  }
  return phone;
}


=================================================================================
FILE: ./supabase/functions/stripe-webhook/index.ts
=================================================================================

/**
 * Edge Function: stripe-webhook
 * Handles Stripe webhook events for payment reconciliation
 * Per architecture-spec.md Section 4.4
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.4";
import Stripe from "https://esm.sh/stripe@14.5.0";

const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, {
  apiVersion: "2023-10-16",
});

const STRIPE_WEBHOOK_SECRET = Deno.env.get("STRIPE_WEBHOOK_SECRET")!;
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

serve(async (req) => {
  try {
    // Get raw body for signature verification
    const body = await req.text();
    const signature = req.headers.get("stripe-signature");

    if (!signature) {
      return new Response("Missing signature", { status: 400 });
    }

    // Verify webhook signature
    let event: Stripe.Event;
    try {
      event = stripe.webhooks.constructEvent(
        body,
        signature,
        STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.error("Webhook signature verification failed:", err);
      return new Response(`Webhook Error: ${err.message}`, { status: 400 });
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Check for idempotency - prevent duplicate processing
    // Per architecture-spec.md Section 4.4
    const { data: existingEvent } = await supabase
      .from("webhook_events")
      .select("id")
      .eq("id", event.id)
      .single();

    if (existingEvent) {
      console.log(`Event ${event.id} already processed, skipping`);
      return new Response(JSON.stringify({ received: true }), { status: 200 });
    }

    // Log event for idempotency
    await supabase.from("webhook_events").insert({
      id: event.id,
      event_type: event.type,
      payload: event.data,
    });

    // Handle specific events
    switch (event.type) {
      case "payment_intent.succeeded": {
        const paymentIntent = event.data.object as Stripe.PaymentIntent;
        console.log("PaymentIntent succeeded:", paymentIntent.id);

        // Extract invoice ID from metadata
        const invoiceId = paymentIntent.metadata?.supabase_invoice_id;

        if (invoiceId) {
          // Update invoice status to paid
          const { error } = await supabase
            .from("invoices")
            .update({
              status: "paid",
              paid_at: new Date().toISOString(),
            })
            .eq("id", invoiceId);

          if (error) {
            console.error("Error updating invoice:", error);
          } else {
            console.log(`Invoice ${invoiceId} marked as paid`);
          }
        }
        break;
      }

      case "payment_intent.payment_failed": {
        const paymentIntent = event.data.object as Stripe.PaymentIntent;
        console.log("PaymentIntent failed:", paymentIntent.id);

        const invoiceId = paymentIntent.metadata?.supabase_invoice_id;
        if (invoiceId) {
          // Could log failed payment attempt
          console.log(`Payment failed for invoice ${invoiceId}`);
        }
        break;
      }

      case "account.updated": {
        // Connected account was updated
        const account = event.data.object as Stripe.Account;
        console.log("Account updated:", account.id);

        // Update profile with account status
        const { error } = await supabase
          .from("profiles")
          .update({
            charges_enabled: account.charges_enabled,
            payouts_enabled: account.payouts_enabled,
          })
          .eq("stripe_account_id", account.id);

        if (error) {
          console.error("Error updating profile:", error);
        }
        break;
      }

      case "checkout.session.completed": {
        // Payment via Payment Link completed
        const session = event.data.object as Stripe.Checkout.Session;
        console.log("Checkout session completed:", session.id);

        const invoiceId = session.metadata?.supabase_invoice_id;

        if (invoiceId) {
          const { error } = await supabase
            .from("invoices")
            .update({
              status: "paid",
              paid_at: new Date().toISOString(),
            })
            .eq("id", invoiceId);

          if (error) {
            console.error("Error updating invoice:", error);
          } else {
            console.log(`Invoice ${invoiceId} marked as paid via checkout`);
          }
        }
        break;
      }

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return new Response(JSON.stringify({ received: true }), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });
  } catch (error) {
    console.error("Webhook error:", error);
    return new Response(`Webhook Error: ${error.message}`, { status: 500 });
  }
});


=================================================================================
FILE: ./supabase/functions/transcribe-and-parse/index.ts
=================================================================================

/**
 * Edge Function: transcribe-and-parse
 * Universal Translator for voice-to-invoice processing
 * Per architecture-spec.md Section 2.2
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.4";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

// OpenAI API configuration
const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY");
const OPENAI_API_URL = "https://api.openai.com/v1";

// Supabase configuration
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

/**
 * Universal Translator System Prompt
 * Per architecture-spec.md Section 2.2.2
 */
function getSystemPrompt(glossaryTerms: string, userTrade: string, currentDate: string): string {
  return `# Role
You are "ContractorAI," a senior construction administrator and linguistic expert specialized in the invoicing workflows of independent contractors. You possess deep knowledge of construction terminology in English, Spanish, and Portuguese, including regional dialects, slang, and "Spanglish/Portuol" hybridizations (e.g., "rufa" for roof, "trozas" for trusses, "chirok" for sheetrock).

# Objective
Your task is to analyze a raw audio transcript provided by a contractor and extract structured financial data to generate a valid Invoice or Quote. You must normalize all colloquial terms into professional English suitable for a formal business document.

# Input Context
* The input is a raw transcript from OpenAI Whisper.
* It may contain background noise artifacts, hesitation markers ("um," "uh"), and non-standard grammar.
* The speaker may switch languages mid-sentence (Code-Switching).
* Current Date: ${currentDate}
* User Trade: ${userTrade || "General Contractor"}

# Construction Glossary Reference
${glossaryTerms}

# Critical Rules & Logic

1. **Intent Detection**: Determine if the user is describing completed work ("INVOICE") or future work ("QUOTE"). Look for temporal markers (past tense vs. future tense/conditional). If ambiguous, default to "INVOICE" but flag low confidence.

2. **Linguistic Normalization**:
   * Identify "Spanglish" or "Portuol" terms and translate them to their Standard English professional equivalents.
   * Example: Input "Instalamos la carpeta en el master bedroom" -> Output Description "Carpet Installation - Master Bedroom"
   * Example: Input "Fixeamos la liqueo" -> Output Description "Leak Repair"
   * Example: Input "Consertamos o telhado" -> Output Description "Roof Repair"

3. **Entity Extraction**:
   * Extract quantity, unit, unit_price, and total.
   * If a total is mentioned that contradicts (quantity * unit_price), trust the unit calculation but add a warning flag.
   * If no price is mentioned, mark unit_price as 0 and requires_review as true.
   * Extract client name if mentioned.

4. **Currency Logic**: Default to USD unless specific currency markers (Pesos, Reais, ) are present.

5. **Output Format**: You must output ONLY valid JSON adhering to the schema below. Do not output conversational text.

# JSON Output Schema
{
  "meta": {
    "intent": "INVOICE" | "QUOTE",
    "confidence": <number between 0 and 1>,
    "language_detected": "<string: en, es, pt, or mixed>",
    "currency": "USD" | "BRL" | "MXN" | "EUR"
  },
  "client": {
    "name": "<string or null>",
    "contact_inferred": "<string or null - phone/email if mentioned>"
  },
  "line_items": [
    {
      "description": "<Professional English description>",
      "quantity": <number>,
      "unit_price": <number in cents>,
      "total": <number in cents>,
      "original_transcript_segment": "<exact substring from transcript>",
      "requires_review": <boolean>
    }
  ],
  "notes": "<Any specialized instructions or context found in transcript>"
}`;
}

/**
 * Transcribe audio using OpenAI Whisper
 */
async function transcribeAudio(audioBlob: Blob): Promise<string> {
  const formData = new FormData();
  formData.append("file", audioBlob, "audio.m4a");
  formData.append("model", "whisper-1");
  // Let Whisper auto-detect language for code-switching support
  formData.append("response_format", "text");

  const response = await fetch(`${OPENAI_API_URL}/audio/transcriptions`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${OPENAI_API_KEY}`,
    },
    body: formData,
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Whisper API error: ${error}`);
  }

  return await response.text();
}

/**
 * Parse transcript using GPT-4o with Universal Translator prompt
 */
async function parseTranscript(
  transcript: string,
  systemPrompt: string
): Promise<any> {
  const response = await fetch(`${OPENAI_API_URL}/chat/completions`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${OPENAI_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: transcript },
      ],
      response_format: { type: "json_object" },
      temperature: 0.3, // Lower temperature for more consistent parsing
      max_tokens: 2000,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GPT-4o API error: ${error}`);
  }

  const data = await response.json();
  const content = data.choices[0]?.message?.content;

  if (!content) {
    throw new Error("No content returned from GPT-4o");
  }

  return JSON.parse(content);
}

/**
 * Fetch glossary terms from database
 */
async function getGlossaryTerms(supabase: any): Promise<string> {
  const { data, error } = await supabase
    .from("glossary_terms")
    .select("term, standard_english, category")
    .limit(200);

  if (error || !data) {
    console.error("Error fetching glossary:", error);
    return "No glossary available.";
  }

  // Format glossary for prompt injection
  const grouped = data.reduce((acc: any, term: any) => {
    const category = term.category || "general";
    if (!acc[category]) acc[category] = [];
    acc[category].push(`"${term.term}" -> ${term.standard_english}`);
    return acc;
  }, {});

  return Object.entries(grouped)
    .map(([category, terms]) => `## ${category}\n${(terms as string[]).join("\n")}`)
    .join("\n\n");
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Validate OpenAI API key
    if (!OPENAI_API_KEY) {
      throw new Error("OPENAI_API_KEY not configured");
    }

    // Create Supabase client with service role
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Parse request body
    const { voice_note_id, storage_path } = await req.json();

    if (!storage_path) {
      throw new Error("storage_path is required");
    }

    // 1. Fetch audio file from storage
    const { data: audioData, error: downloadError } = await supabase.storage
      .from("voice-evidence")
      .download(storage_path);

    if (downloadError || !audioData) {
      throw new Error(`Failed to download audio: ${downloadError?.message}`);
    }

    // 2. Transcribe audio with Whisper
    console.log("Transcribing audio...");
    const transcript = await transcribeAudio(audioData);
    console.log("Transcript:", transcript);

    // 3. Fetch glossary terms
    const glossaryTerms = await getGlossaryTerms(supabase);

    // 4. Get user profile for trade info (optional)
    let userTrade = "General Contractor";
    // Could fetch from profiles table if needed

    // 5. Build system prompt
    const currentDate = new Date().toISOString().split("T")[0];
    const systemPrompt = getSystemPrompt(glossaryTerms, userTrade, currentDate);

    // 6. Parse transcript with GPT-4o
    console.log("Parsing with GPT-4o...");
    const parseResult = await parseTranscript(transcript, systemPrompt);
    console.log("Parse result:", JSON.stringify(parseResult, null, 2));

    // 7. Update voice note record with transcript
    if (voice_note_id) {
      await supabase
        .from("voice_notes")
        .update({
          transcript,
          detected_language: parseResult.meta?.language_detected || "en",
          confidence_score: parseResult.meta?.confidence || 0,
          processing_status: "completed",
        })
        .eq("id", voice_note_id);
    }

    // Return parsed result
    return new Response(JSON.stringify(parseResult), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 200,
    });
  } catch (error) {
    console.error("Error in transcribe-and-parse:", error);

    return new Response(
      JSON.stringify({
        error: error.message || "Unknown error",
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});


=================================================================================
FILE: ./supabase/migrations/001_create_profiles.sql
=================================================================================

-- Migration: Create profiles table
-- Extends auth.users with business profile and Stripe information
-- Per architecture-spec.md Section 3.3.1

-- Create profiles table
create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  business_name text,
  full_name text,
  email text,
  phone text,
  address text,
  logo_url text,
  stripe_account_id text unique,
  charges_enabled boolean default false,
  payouts_enabled boolean default false,
  default_currency text default 'USD',
  default_language text default 'en',
  tax_rate numeric default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable Row Level Security (CRITICAL per architecture-spec.md Section 11.1)
alter table public.profiles enable row level security;

-- RLS Policies: Users can only access their own profile
create policy "Users can view own profile"
  on public.profiles for select
  using (auth.uid() = id);

create policy "Users can insert own profile"
  on public.profiles for insert
  with check (auth.uid() = id);

create policy "Users can update own profile"
  on public.profiles for update
  using (auth.uid() = id);

-- Create updated_at trigger
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger on_profiles_updated
  before update on public.profiles
  for each row execute procedure public.handle_updated_at();

-- Index for Stripe account lookups
create index profiles_stripe_account_id_idx on public.profiles(stripe_account_id);

comment on table public.profiles is 'User business profiles with Stripe Connect integration';


=================================================================================
FILE: ./supabase/migrations/002_create_clients.sql
=================================================================================

-- Migration: Create clients table
-- Stores contractor's customers (CRM data)
-- Per architecture-spec.md Section 3.2

create table public.clients (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  name text not null,
  email text,
  phone text,
  address jsonb,
  notes text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable Row Level Security
alter table public.clients enable row level security;

-- RLS Policies: Users can only access their own clients
create policy "Users can view own clients"
  on public.clients for select
  using (auth.uid() = user_id);

create policy "Users can insert own clients"
  on public.clients for insert
  with check (auth.uid() = user_id);

create policy "Users can update own clients"
  on public.clients for update
  using (auth.uid() = user_id);

create policy "Users can delete own clients"
  on public.clients for delete
  using (auth.uid() = user_id);

-- Trigger for updated_at
create trigger on_clients_updated
  before update on public.clients
  for each row execute procedure public.handle_updated_at();

-- Indexes for common queries
create index clients_user_id_idx on public.clients(user_id);
create index clients_name_idx on public.clients(user_id, name);

comment on table public.clients is 'Contractor customer records';


=================================================================================
FILE: ./supabase/migrations/003_create_invoices.sql
=================================================================================

-- Migration: Create invoices table
-- Core financial document with Stripe integration
-- Per architecture-spec.md Section 3.3.2

-- Create invoice status enum
create type invoice_status as enum ('draft', 'sent', 'paid', 'void', 'overdue');

create table public.invoices (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  client_id uuid references public.clients(id) on delete set null,
  invoice_number text not null,

  -- Client info snapshot (in case client is deleted)
  client_name text not null,
  client_email text,
  client_phone text,
  client_address text,

  -- Stripe integration (per architecture-spec.md Section 4)
  stripe_payment_intent_id text,
  stripe_hosted_invoice_url text,

  -- Financial data (stored in cents per architecture-spec.md)
  subtotal bigint not null default 0,
  tax_rate numeric default 0,
  tax_amount bigint not null default 0,
  total bigint not null default 0,
  currency text default 'USD',

  -- Status and dates
  status invoice_status default 'draft',
  due_date date,
  paid_at timestamptz,
  sent_at timestamptz,

  -- Additional info
  notes text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable Row Level Security
alter table public.invoices enable row level security;

-- RLS Policies: Users can only access their own invoices
create policy "Users can view own invoices"
  on public.invoices for select
  using (auth.uid() = user_id);

create policy "Users can insert own invoices"
  on public.invoices for insert
  with check (auth.uid() = user_id);

create policy "Users can update own invoices"
  on public.invoices for update
  using (auth.uid() = user_id);

create policy "Users can delete own invoices"
  on public.invoices for delete
  using (auth.uid() = user_id);

-- Trigger for updated_at
create trigger on_invoices_updated
  before update on public.invoices
  for each row execute procedure public.handle_updated_at();

-- Indexes for performance (per architecture-spec.md Section 10.2)
create index invoices_user_id_idx on public.invoices(user_id);
create index invoices_status_idx on public.invoices(user_id, status);
create index invoices_created_at_idx on public.invoices(user_id, created_at desc);
create index invoices_stripe_pi_idx on public.invoices(stripe_payment_intent_id);

-- Composite index for dashboard queries
create index idx_invoices_user_status_date
  on public.invoices(user_id, status, created_at desc);

comment on table public.invoices is 'Financial invoices with Stripe payment integration';


=================================================================================
FILE: ./supabase/migrations/004_create_invoice_items.sql
=================================================================================

-- Migration: Create invoice_items table
-- Individual line items for invoices
-- Per architecture-spec.md Section 3.2

create table public.invoice_items (
  id uuid default gen_random_uuid() primary key,
  invoice_id uuid references public.invoices(id) on delete cascade not null,
  description text not null,
  quantity numeric default 1,
  unit_price bigint not null default 0, -- Stored in cents
  total bigint not null default 0, -- Stored in cents

  -- AI traceability (per architecture-spec.md Section 2.3)
  original_transcript_segment text,

  created_at timestamptz default now()
);

-- Enable Row Level Security
alter table public.invoice_items enable row level security;

-- RLS Policies: Access through invoice ownership
-- Users can access items if they own the parent invoice
create policy "Users can view own invoice items"
  on public.invoice_items for select
  using (
    exists (
      select 1 from public.invoices
      where invoices.id = invoice_items.invoice_id
      and invoices.user_id = auth.uid()
    )
  );

create policy "Users can insert own invoice items"
  on public.invoice_items for insert
  with check (
    exists (
      select 1 from public.invoices
      where invoices.id = invoice_items.invoice_id
      and invoices.user_id = auth.uid()
    )
  );

create policy "Users can update own invoice items"
  on public.invoice_items for update
  using (
    exists (
      select 1 from public.invoices
      where invoices.id = invoice_items.invoice_id
      and invoices.user_id = auth.uid()
    )
  );

create policy "Users can delete own invoice items"
  on public.invoice_items for delete
  using (
    exists (
      select 1 from public.invoices
      where invoices.id = invoice_items.invoice_id
      and invoices.user_id = auth.uid()
    )
  );

-- Index for invoice lookups
create index invoice_items_invoice_id_idx on public.invoice_items(invoice_id);

comment on table public.invoice_items is 'Line items for invoices with AI transcript traceability';


=================================================================================
FILE: ./supabase/migrations/005_create_voice_notes.sql
=================================================================================

-- Migration: Create voice_notes table
-- Metadata for audio files stored in Supabase Storage
-- Per architecture-spec.md Section 3.4

create table public.voice_notes (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null,
  invoice_id uuid references public.invoices(id) on delete set null,

  -- Storage reference
  storage_path text not null,

  -- Transcription data
  transcript text,
  detected_language text,

  -- AI processing metadata
  confidence_score numeric,
  processing_status text default 'pending', -- pending, processing, completed, failed

  created_at timestamptz default now()
);

-- Enable Row Level Security
alter table public.voice_notes enable row level security;

-- RLS Policies: Users can only access their own voice notes
create policy "Users can view own voice notes"
  on public.voice_notes for select
  using (auth.uid() = user_id);

create policy "Users can insert own voice notes"
  on public.voice_notes for insert
  with check (auth.uid() = user_id);

create policy "Users can update own voice notes"
  on public.voice_notes for update
  using (auth.uid() = user_id);

create policy "Users can delete own voice notes"
  on public.voice_notes for delete
  using (auth.uid() = user_id);

-- Indexes
create index voice_notes_user_id_idx on public.voice_notes(user_id);
create index voice_notes_invoice_id_idx on public.voice_notes(invoice_id);

comment on table public.voice_notes is 'Voice recording metadata with AI transcription results';


=================================================================================
FILE: ./supabase/migrations/006_create_glossary_terms.sql
=================================================================================

-- Migration: Create glossary_terms table
-- Construction terminology for Spanglish/Portuol translation
-- Per architecture-spec.md Section 9.2

create table public.glossary_terms (
  id uuid default gen_random_uuid() primary key,
  term text not null,
  standard_english text not null,
  category text, -- e.g., 'roofing', 'plumbing', 'electrical', 'general'
  language text default 'es', -- 'es' for Spanish, 'pt' for Portuguese
  created_at timestamptz default now()
);

-- This table is read-only for users, managed by admins
-- No RLS needed as it's public reference data
alter table public.glossary_terms enable row level security;

-- Allow all authenticated users to read glossary
create policy "Authenticated users can view glossary"
  on public.glossary_terms for select
  using (auth.role() = 'authenticated');

-- Index for term lookups
create index glossary_terms_term_idx on public.glossary_terms(term);
create index glossary_terms_language_idx on public.glossary_terms(language);

comment on table public.glossary_terms is 'Construction Spanglish/Portuol translation glossary for AI';


=================================================================================
FILE: ./supabase/migrations/007_create_webhook_events.sql
=================================================================================

-- Migration: Create webhook_events table
-- Idempotency tracking for Stripe webhooks
-- Per architecture-spec.md Section 4.4

create table public.webhook_events (
  id text primary key, -- Stripe event ID (evt_...)
  event_type text not null,
  processed_at timestamptz default now(),
  payload jsonb
);

-- No RLS needed - this table is only accessed by Edge Functions
-- using the service role key

-- Index for cleanup queries
create index webhook_events_processed_at_idx on public.webhook_events(processed_at);

comment on table public.webhook_events is 'Stripe webhook idempotency tracking';

-- Cleanup old events (optional, can be run via cron)
-- Events older than 30 days can be safely deleted
create or replace function public.cleanup_old_webhook_events()
returns void as $$
begin
  delete from public.webhook_events
  where processed_at < now() - interval '30 days';
end;
$$ language plpgsql security definer;


=================================================================================
FILE: ./supabase/migrations/008_create_profile_trigger.sql
=================================================================================

-- Migration: Auto-create profile on user signup
-- Per architecture-spec.md - profiles extend auth.users

-- Function to create profile when user signs up
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'full_name', '')
  );
  return new;
end;
$$ language plpgsql security definer;

-- Trigger on auth.users insert
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

comment on function public.handle_new_user() is 'Auto-creates profile row when user signs up';


=================================================================================
FILE: ./supabase/migrations/009_create_reminder_settings.sql
=================================================================================

-- Migration: Create reminder settings and logs for "Bad Cop" system
-- Per product-strategy.md Section 3.3

create table public.reminder_settings (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references public.profiles(id) on delete cascade not null unique,
  enabled boolean default false,
  day_intervals integer[] default '{3, 7, 14}', -- Days after due date to send reminders
  email_enabled boolean default true,
  sms_enabled boolean default false,
  message_template text default 'This is an automated reminder for invoice {{invoice_number}} from {{business_name}}. Amount due: {{total}}. Please pay at your earliest convenience.',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Reminder logs to track what was sent
create table public.reminder_logs (
  id uuid default gen_random_uuid() primary key,
  invoice_id uuid references public.invoices(id) on delete cascade not null,
  reminder_type text not null, -- 'email' or 'sms'
  sent_at timestamptz default now(),
  status text default 'sent', -- 'sent', 'failed', 'delivered'
  error_message text
);

-- Enable Row Level Security
alter table public.reminder_settings enable row level security;
alter table public.reminder_logs enable row level security;

-- RLS Policies for reminder_settings
create policy "Users can view own reminder settings"
  on public.reminder_settings for select
  using (auth.uid() = user_id);

create policy "Users can insert own reminder settings"
  on public.reminder_settings for insert
  with check (auth.uid() = user_id);

create policy "Users can update own reminder settings"
  on public.reminder_settings for update
  using (auth.uid() = user_id);

-- RLS Policies for reminder_logs (read-only for users)
create policy "Users can view own reminder logs"
  on public.reminder_logs for select
  using (
    exists (
      select 1 from public.invoices
      where invoices.id = reminder_logs.invoice_id
      and invoices.user_id = auth.uid()
    )
  );

-- Trigger for updated_at
create trigger on_reminder_settings_updated
  before update on public.reminder_settings
  for each row execute procedure public.handle_updated_at();

-- Indexes
create index reminder_settings_user_id_idx on public.reminder_settings(user_id);
create index reminder_logs_invoice_id_idx on public.reminder_logs(invoice_id);
create index reminder_logs_sent_at_idx on public.reminder_logs(sent_at);

comment on table public.reminder_settings is 'User preferences for automated invoice reminders (Bad Cop)';
comment on table public.reminder_logs is 'History of sent invoice reminders';


=================================================================================
FILE: ./supabase/migrations/010_storage_policies.sql
=================================================================================

-- Migration: Storage bucket policies
-- Per architecture-spec.md Section 3.4

-- Note: Buckets must be created via Supabase Dashboard or CLI
-- This migration sets up the RLS policies for storage

-- Policy for voice-evidence bucket
-- Users can only access files in their own folder (folder name = user ID)
create policy "Users can upload voice evidence"
  on storage.objects for insert
  with check (
    bucket_id = 'voice-evidence'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can view own voice evidence"
  on storage.objects for select
  using (
    bucket_id = 'voice-evidence'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can delete own voice evidence"
  on storage.objects for delete
  using (
    bucket_id = 'voice-evidence'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

-- Policy for logos bucket
create policy "Users can upload logos"
  on storage.objects for insert
  with check (
    bucket_id = 'logos'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can view own logos"
  on storage.objects for select
  using (
    bucket_id = 'logos'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can update own logos"
  on storage.objects for update
  using (
    bucket_id = 'logos'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can delete own logos"
  on storage.objects for delete
  using (
    bucket_id = 'logos'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

-- Policy for invoice-pdfs bucket
create policy "Users can upload invoice PDFs"
  on storage.objects for insert
  with check (
    bucket_id = 'invoice-pdfs'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can view own invoice PDFs"
  on storage.objects for select
  using (
    bucket_id = 'invoice-pdfs'
    and (storage.foldername(name))[1] = auth.uid()::text
  );

create policy "Users can delete own invoice PDFs"
  on storage.objects for delete
  using (
    bucket_id = 'invoice-pdfs'
    and (storage.foldername(name))[1] = auth.uid()::text
  );


=================================================================================
FILE: ./supabase/migrations/011_seed_glossary.sql
=================================================================================

-- Seed: Construction Spanglish and Portuguese glossary
-- Per architecture-spec.md Section 9.1-9.2

-- Spanish/Spanglish construction terms
insert into public.glossary_terms (term, standard_english, category, language) values
  -- Roofing
  ('rufa', 'Roof', 'roofing', 'es'),
  ('roofa', 'Roof', 'roofing', 'es'),
  ('trozas', 'Trusses', 'roofing', 'es'),
  ('tejas', 'Shingles', 'roofing', 'es'),
  ('canalon', 'Gutter', 'roofing', 'es'),
  ('canaleta', 'Gutter', 'roofing', 'es'),

  -- Drywall/Walls
  ('shirok', 'Drywall', 'drywall', 'es'),
  ('chirok', 'Drywall', 'drywall', 'es'),
  ('sheetrock', 'Drywall', 'drywall', 'es'),
  ('placa', 'Drywall', 'drywall', 'es'),
  ('tablaroca', 'Drywall', 'drywall', 'es'),
  ('yeso', 'Plaster', 'drywall', 'es'),
  ('mud', 'Joint Compound', 'drywall', 'es'),
  ('tape', 'Drywall Tape', 'drywall', 'es'),

  -- Framing
  ('freiming', 'Framing', 'framing', 'es'),
  ('framing', 'Framing', 'framing', 'es'),
  ('estud', 'Stud', 'framing', 'es'),
  ('studs', 'Studs', 'framing', 'es'),
  ('viga', 'Beam', 'framing', 'es'),
  ('joist', 'Joist', 'framing', 'es'),

  -- Plumbing
  ('liqueo', 'Leak', 'plumbing', 'es'),
  ('lique', 'Leak', 'plumbing', 'es'),
  ('tubo', 'Pipe', 'plumbing', 'es'),
  ('pipa', 'Pipe', 'plumbing', 'es'),
  ('llave', 'Faucet', 'plumbing', 'es'),
  ('faucet', 'Faucet', 'plumbing', 'es'),
  ('drenaje', 'Drain', 'plumbing', 'es'),
  ('drain', 'Drain', 'plumbing', 'es'),
  ('toilet', 'Toilet', 'plumbing', 'es'),
  ('inodoro', 'Toilet', 'plumbing', 'es'),
  ('water heater', 'Water Heater', 'plumbing', 'es'),
  ('calentador', 'Water Heater', 'plumbing', 'es'),

  -- Electrical
  ('breaker', 'Circuit Breaker', 'electrical', 'es'),
  ('brekera', 'Circuit Breaker', 'electrical', 'es'),
  ('outlet', 'Electrical Outlet', 'electrical', 'es'),
  ('enchufe', 'Electrical Outlet', 'electrical', 'es'),
  ('switch', 'Light Switch', 'electrical', 'es'),
  ('suiche', 'Light Switch', 'electrical', 'es'),
  ('wiring', 'Electrical Wiring', 'electrical', 'es'),
  ('cableado', 'Electrical Wiring', 'electrical', 'es'),
  ('panel', 'Electrical Panel', 'electrical', 'es'),

  -- Painting
  ('pintura', 'Paint', 'painting', 'es'),
  ('primer', 'Primer', 'painting', 'es'),
  ('brocha', 'Brush', 'painting', 'es'),
  ('rodillo', 'Roller', 'painting', 'es'),
  ('trim', 'Trim Work', 'painting', 'es'),
  ('moldura', 'Molding', 'painting', 'es'),

  -- Flooring
  ('carpeta', 'Carpet', 'flooring', 'es'),
  ('carpet', 'Carpet', 'flooring', 'es'),
  ('tile', 'Tile', 'flooring', 'es'),
  ('baldosa', 'Tile', 'flooring', 'es'),
  ('piso', 'Flooring', 'flooring', 'es'),
  ('hardwood', 'Hardwood Flooring', 'flooring', 'es'),
  ('laminate', 'Laminate Flooring', 'flooring', 'es'),
  ('vinyl', 'Vinyl Flooring', 'flooring', 'es'),

  -- HVAC
  ('aire', 'Air Conditioning', 'hvac', 'es'),
  ('AC', 'Air Conditioning', 'hvac', 'es'),
  ('furnace', 'Furnace', 'hvac', 'es'),
  ('calefaccion', 'Heating', 'hvac', 'es'),
  ('ducto', 'Duct', 'hvac', 'es'),
  ('vent', 'Vent', 'hvac', 'es'),

  -- General/Verbs (morphological adaptations)
  ('fixear', 'Repair', 'general', 'es'),
  ('fixeamos', 'Repaired', 'general', 'es'),
  ('instalamos', 'Installed', 'general', 'es'),
  ('instalar', 'Install', 'general', 'es'),
  ('removemos', 'Removed', 'general', 'es'),
  ('remover', 'Remove', 'general', 'es'),
  ('reemplazar', 'Replace', 'general', 'es'),
  ('limpiar', 'Clean', 'general', 'es'),
  ('reparar', 'Repair', 'general', 'es'),
  ('materiales', 'Materials', 'general', 'es'),
  ('labor', 'Labor', 'general', 'es'),
  ('mano de obra', 'Labor', 'general', 'es'),

  -- Landscaping
  ('yarda', 'Yard', 'landscaping', 'es'),
  ('cesped', 'Lawn', 'landscaping', 'es'),
  ('grass', 'Grass/Lawn', 'landscaping', 'es'),
  ('zacate', 'Grass/Lawn', 'landscaping', 'es'),
  ('cerca', 'Fence', 'landscaping', 'es'),
  ('fence', 'Fence', 'landscaping', 'es'),
  ('deck', 'Deck', 'landscaping', 'es'),
  ('patio', 'Patio', 'landscaping', 'es'),

  -- Concrete
  ('concreto', 'Concrete', 'concrete', 'es'),
  ('cemento', 'Cement', 'concrete', 'es'),
  ('slab', 'Concrete Slab', 'concrete', 'es'),
  ('losa', 'Concrete Slab', 'concrete', 'es'),
  ('sidewalk', 'Sidewalk', 'concrete', 'es'),
  ('banqueta', 'Sidewalk', 'concrete', 'es'),
  ('driveway', 'Driveway', 'concrete', 'es'),
  ('entrada', 'Driveway', 'concrete', 'es'),

  -- Rooms
  ('master bedroom', 'Master Bedroom', 'rooms', 'es'),
  ('recamara principal', 'Master Bedroom', 'rooms', 'es'),
  ('cocina', 'Kitchen', 'rooms', 'es'),
  ('kitchen', 'Kitchen', 'rooms', 'es'),
  ('bano', 'Bathroom', 'rooms', 'es'),
  ('bathroom', 'Bathroom', 'rooms', 'es'),
  ('sala', 'Living Room', 'rooms', 'es'),
  ('living room', 'Living Room', 'rooms', 'es'),
  ('garage', 'Garage', 'rooms', 'es'),
  ('sotano', 'Basement', 'rooms', 'es'),
  ('basement', 'Basement', 'rooms', 'es'),
  ('atico', 'Attic', 'rooms', 'es'),
  ('attic', 'Attic', 'rooms', 'es');

-- Portuguese/Portuol construction terms
insert into public.glossary_terms (term, standard_english, category, language) values
  -- Roofing
  ('telhado', 'Roof', 'roofing', 'pt'),
  ('telha', 'Shingle/Tile', 'roofing', 'pt'),
  ('calha', 'Gutter', 'roofing', 'pt'),

  -- Drywall/Walls
  ('drywall', 'Drywall', 'drywall', 'pt'),
  ('gesso', 'Plaster/Drywall', 'drywall', 'pt'),
  ('parede', 'Wall', 'drywall', 'pt'),

  -- Plumbing
  ('vazamento', 'Leak', 'plumbing', 'pt'),
  ('cano', 'Pipe', 'plumbing', 'pt'),
  ('torneira', 'Faucet', 'plumbing', 'pt'),
  ('ralo', 'Drain', 'plumbing', 'pt'),
  ('vaso', 'Toilet', 'plumbing', 'pt'),
  ('aquecedor', 'Water Heater', 'plumbing', 'pt'),

  -- Electrical
  ('disjuntor', 'Circuit Breaker', 'electrical', 'pt'),
  ('tomada', 'Electrical Outlet', 'electrical', 'pt'),
  ('interruptor', 'Light Switch', 'electrical', 'pt'),
  ('fiacao', 'Wiring', 'electrical', 'pt'),

  -- Painting
  ('pintura', 'Paint/Painting', 'painting', 'pt'),
  ('tinta', 'Paint', 'painting', 'pt'),
  ('pincel', 'Brush', 'painting', 'pt'),
  ('rolo', 'Roller', 'painting', 'pt'),

  -- Flooring
  ('carpete', 'Carpet', 'flooring', 'pt'),
  ('piso', 'Floor/Flooring', 'flooring', 'pt'),
  ('azulejo', 'Tile', 'flooring', 'pt'),
  ('madeira', 'Hardwood', 'flooring', 'pt'),

  -- General
  ('consertar', 'Repair', 'general', 'pt'),
  ('consertamos', 'Repaired', 'general', 'pt'),
  ('instalar', 'Install', 'general', 'pt'),
  ('instalamos', 'Installed', 'general', 'pt'),
  ('remover', 'Remove', 'general', 'pt'),
  ('removemos', 'Removed', 'general', 'pt'),
  ('trocar', 'Replace', 'general', 'pt'),
  ('limpar', 'Clean', 'general', 'pt'),
  ('materiais', 'Materials', 'general', 'pt'),
  ('mao de obra', 'Labor', 'general', 'pt'),

  -- Landscaping
  ('quintal', 'Yard', 'landscaping', 'pt'),
  ('grama', 'Grass/Lawn', 'landscaping', 'pt'),
  ('cerca', 'Fence', 'landscaping', 'pt'),
  ('deck', 'Deck', 'landscaping', 'pt'),

  -- Rooms
  ('quarto principal', 'Master Bedroom', 'rooms', 'pt'),
  ('cozinha', 'Kitchen', 'rooms', 'pt'),
  ('banheiro', 'Bathroom', 'rooms', 'pt'),
  ('sala', 'Living Room', 'rooms', 'pt'),
  ('garagem', 'Garage', 'rooms', 'pt'),
  ('porao', 'Basement', 'rooms', 'pt');


=================================================================================
FILE: ./supabase/seed/glossary.sql
=================================================================================

-- Seed: Construction Spanglish and Portuguese glossary
-- Per architecture-spec.md Section 9.1-9.2

-- Spanish/Spanglish construction terms
insert into public.glossary_terms (term, standard_english, category, language) values
  -- Roofing
  ('rufa', 'Roof', 'roofing', 'es'),
  ('roofa', 'Roof', 'roofing', 'es'),
  ('trozas', 'Trusses', 'roofing', 'es'),
  ('tejas', 'Shingles', 'roofing', 'es'),
  ('canalon', 'Gutter', 'roofing', 'es'),
  ('canaleta', 'Gutter', 'roofing', 'es'),

  -- Drywall/Walls
  ('shirok', 'Drywall', 'drywall', 'es'),
  ('chirok', 'Drywall', 'drywall', 'es'),
  ('sheetrock', 'Drywall', 'drywall', 'es'),
  ('placa', 'Drywall', 'drywall', 'es'),
  ('tablaroca', 'Drywall', 'drywall', 'es'),
  ('yeso', 'Plaster', 'drywall', 'es'),
  ('mud', 'Joint Compound', 'drywall', 'es'),
  ('tape', 'Drywall Tape', 'drywall', 'es'),

  -- Framing
  ('freiming', 'Framing', 'framing', 'es'),
  ('framing', 'Framing', 'framing', 'es'),
  ('estud', 'Stud', 'framing', 'es'),
  ('studs', 'Studs', 'framing', 'es'),
  ('viga', 'Beam', 'framing', 'es'),
  ('joist', 'Joist', 'framing', 'es'),

  -- Plumbing
  ('liqueo', 'Leak', 'plumbing', 'es'),
  ('lique', 'Leak', 'plumbing', 'es'),
  ('tubo', 'Pipe', 'plumbing', 'es'),
  ('pipa', 'Pipe', 'plumbing', 'es'),
  ('llave', 'Faucet', 'plumbing', 'es'),
  ('faucet', 'Faucet', 'plumbing', 'es'),
  ('drenaje', 'Drain', 'plumbing', 'es'),
  ('drain', 'Drain', 'plumbing', 'es'),
  ('toilet', 'Toilet', 'plumbing', 'es'),
  ('inodoro', 'Toilet', 'plumbing', 'es'),
  ('water heater', 'Water Heater', 'plumbing', 'es'),
  ('calentador', 'Water Heater', 'plumbing', 'es'),

  -- Electrical
  ('breaker', 'Circuit Breaker', 'electrical', 'es'),
  ('brekera', 'Circuit Breaker', 'electrical', 'es'),
  ('outlet', 'Electrical Outlet', 'electrical', 'es'),
  ('enchufe', 'Electrical Outlet', 'electrical', 'es'),
  ('switch', 'Light Switch', 'electrical', 'es'),
  ('suiche', 'Light Switch', 'electrical', 'es'),
  ('wiring', 'Electrical Wiring', 'electrical', 'es'),
  ('cableado', 'Electrical Wiring', 'electrical', 'es'),
  ('panel', 'Electrical Panel', 'electrical', 'es'),

  -- Painting
  ('pintura', 'Paint', 'painting', 'es'),
  ('primer', 'Primer', 'painting', 'es'),
  ('brocha', 'Brush', 'painting', 'es'),
  ('rodillo', 'Roller', 'painting', 'es'),
  ('trim', 'Trim Work', 'painting', 'es'),
  ('moldura', 'Molding', 'painting', 'es'),

  -- Flooring
  ('carpeta', 'Carpet', 'flooring', 'es'),
  ('carpet', 'Carpet', 'flooring', 'es'),
  ('tile', 'Tile', 'flooring', 'es'),
  ('baldosa', 'Tile', 'flooring', 'es'),
  ('piso', 'Flooring', 'flooring', 'es'),
  ('hardwood', 'Hardwood Flooring', 'flooring', 'es'),
  ('laminate', 'Laminate Flooring', 'flooring', 'es'),
  ('vinyl', 'Vinyl Flooring', 'flooring', 'es'),

  -- HVAC
  ('aire', 'Air Conditioning', 'hvac', 'es'),
  ('AC', 'Air Conditioning', 'hvac', 'es'),
  ('furnace', 'Furnace', 'hvac', 'es'),
  ('calefaccion', 'Heating', 'hvac', 'es'),
  ('ducto', 'Duct', 'hvac', 'es'),
  ('vent', 'Vent', 'hvac', 'es'),

  -- General/Verbs (morphological adaptations)
  ('fixear', 'Repair', 'general', 'es'),
  ('fixeamos', 'Repaired', 'general', 'es'),
  ('instalamos', 'Installed', 'general', 'es'),
  ('instalar', 'Install', 'general', 'es'),
  ('removemos', 'Removed', 'general', 'es'),
  ('remover', 'Remove', 'general', 'es'),
  ('reemplazar', 'Replace', 'general', 'es'),
  ('limpiar', 'Clean', 'general', 'es'),
  ('reparar', 'Repair', 'general', 'es'),
  ('materiales', 'Materials', 'general', 'es'),
  ('labor', 'Labor', 'general', 'es'),
  ('mano de obra', 'Labor', 'general', 'es'),

  -- Landscaping
  ('yarda', 'Yard', 'landscaping', 'es'),
  ('cesped', 'Lawn', 'landscaping', 'es'),
  ('grass', 'Grass/Lawn', 'landscaping', 'es'),
  ('zacate', 'Grass/Lawn', 'landscaping', 'es'),
  ('cerca', 'Fence', 'landscaping', 'es'),
  ('fence', 'Fence', 'landscaping', 'es'),
  ('deck', 'Deck', 'landscaping', 'es'),
  ('patio', 'Patio', 'landscaping', 'es'),

  -- Concrete
  ('concreto', 'Concrete', 'concrete', 'es'),
  ('cemento', 'Cement', 'concrete', 'es'),
  ('slab', 'Concrete Slab', 'concrete', 'es'),
  ('losa', 'Concrete Slab', 'concrete', 'es'),
  ('sidewalk', 'Sidewalk', 'concrete', 'es'),
  ('banqueta', 'Sidewalk', 'concrete', 'es'),
  ('driveway', 'Driveway', 'concrete', 'es'),
  ('entrada', 'Driveway', 'concrete', 'es'),

  -- Rooms
  ('master bedroom', 'Master Bedroom', 'rooms', 'es'),
  ('recamara principal', 'Master Bedroom', 'rooms', 'es'),
  ('cocina', 'Kitchen', 'rooms', 'es'),
  ('kitchen', 'Kitchen', 'rooms', 'es'),
  ('bano', 'Bathroom', 'rooms', 'es'),
  ('bathroom', 'Bathroom', 'rooms', 'es'),
  ('sala', 'Living Room', 'rooms', 'es'),
  ('living room', 'Living Room', 'rooms', 'es'),
  ('garage', 'Garage', 'rooms', 'es'),
  ('sotano', 'Basement', 'rooms', 'es'),
  ('basement', 'Basement', 'rooms', 'es'),
  ('atico', 'Attic', 'rooms', 'es'),
  ('attic', 'Attic', 'rooms', 'es');

-- Portuguese/Portuol construction terms
insert into public.glossary_terms (term, standard_english, category, language) values
  -- Roofing
  ('telhado', 'Roof', 'roofing', 'pt'),
  ('telha', 'Shingle/Tile', 'roofing', 'pt'),
  ('calha', 'Gutter', 'roofing', 'pt'),

  -- Drywall/Walls
  ('drywall', 'Drywall', 'drywall', 'pt'),
  ('gesso', 'Plaster/Drywall', 'drywall', 'pt'),
  ('parede', 'Wall', 'drywall', 'pt'),

  -- Plumbing
  ('vazamento', 'Leak', 'plumbing', 'pt'),
  ('cano', 'Pipe', 'plumbing', 'pt'),
  ('torneira', 'Faucet', 'plumbing', 'pt'),
  ('ralo', 'Drain', 'plumbing', 'pt'),
  ('vaso', 'Toilet', 'plumbing', 'pt'),
  ('aquecedor', 'Water Heater', 'plumbing', 'pt'),

  -- Electrical
  ('disjuntor', 'Circuit Breaker', 'electrical', 'pt'),
  ('tomada', 'Electrical Outlet', 'electrical', 'pt'),
  ('interruptor', 'Light Switch', 'electrical', 'pt'),
  ('fiacao', 'Wiring', 'electrical', 'pt'),

  -- Painting
  ('pintura', 'Paint/Painting', 'painting', 'pt'),
  ('tinta', 'Paint', 'painting', 'pt'),
  ('pincel', 'Brush', 'painting', 'pt'),
  ('rolo', 'Roller', 'painting', 'pt'),

  -- Flooring
  ('carpete', 'Carpet', 'flooring', 'pt'),
  ('piso', 'Floor/Flooring', 'flooring', 'pt'),
  ('azulejo', 'Tile', 'flooring', 'pt'),
  ('madeira', 'Hardwood', 'flooring', 'pt'),

  -- General
  ('consertar', 'Repair', 'general', 'pt'),
  ('consertamos', 'Repaired', 'general', 'pt'),
  ('instalar', 'Install', 'general', 'pt'),
  ('instalamos', 'Installed', 'general', 'pt'),
  ('remover', 'Remove', 'general', 'pt'),
  ('removemos', 'Removed', 'general', 'pt'),
  ('trocar', 'Replace', 'general', 'pt'),
  ('limpar', 'Clean', 'general', 'pt'),
  ('materiais', 'Materials', 'general', 'pt'),
  ('mao de obra', 'Labor', 'general', 'pt'),

  -- Landscaping
  ('quintal', 'Yard', 'landscaping', 'pt'),
  ('grama', 'Grass/Lawn', 'landscaping', 'pt'),
  ('cerca', 'Fence', 'landscaping', 'pt'),
  ('deck', 'Deck', 'landscaping', 'pt'),

  -- Rooms
  ('quarto principal', 'Master Bedroom', 'rooms', 'pt'),
  ('cozinha', 'Kitchen', 'rooms', 'pt'),
  ('banheiro', 'Bathroom', 'rooms', 'pt'),
  ('sala', 'Living Room', 'rooms', 'pt'),
  ('garagem', 'Garage', 'rooms', 'pt'),
  ('porao', 'Basement', 'rooms', 'pt');


=================================================================================
FILE: ./tailwind.config.js
=================================================================================

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./app/**/*.{js,jsx,ts,tsx}", "./components/**/*.{js,jsx,ts,tsx}"],
  presets: [require("nativewind/preset")],
  theme: {
    extend: {
      colors: {
        primary: "#00D632",
        alert: "#FF9500",
      },
    },
  },
  plugins: [],
};


=================================================================================
FILE: ./tsconfig.json
=================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "types": [
      "nativewind/types"
    ]
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "nativewind-env.d.ts"
  ]
}


=================================================================================
FILE: ./types/database.ts
=================================================================================

/**
 * Database types for Supabase
 * Per architecture-spec.md schema definitions
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export type InvoiceStatus = 'draft' | 'sent' | 'paid' | 'void' | 'overdue';

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string;
          business_name: string | null;
          full_name: string | null;
          email: string | null;
          phone: string | null;
          address: string | null;
          logo_url: string | null;
          stripe_account_id: string | null;
          charges_enabled: boolean;
          payouts_enabled: boolean;
          default_currency: string;
          default_language: string;
          tax_rate: number;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id: string;
          business_name?: string | null;
          full_name?: string | null;
          email?: string | null;
          phone?: string | null;
          address?: string | null;
          logo_url?: string | null;
          stripe_account_id?: string | null;
          charges_enabled?: boolean;
          payouts_enabled?: boolean;
          default_currency?: string;
          default_language?: string;
          tax_rate?: number;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          business_name?: string | null;
          full_name?: string | null;
          email?: string | null;
          phone?: string | null;
          address?: string | null;
          logo_url?: string | null;
          stripe_account_id?: string | null;
          charges_enabled?: boolean;
          payouts_enabled?: boolean;
          default_currency?: string;
          default_language?: string;
          tax_rate?: number;
          updated_at?: string;
        };
      };
      clients: {
        Row: {
          id: string;
          user_id: string;
          name: string;
          email: string | null;
          phone: string | null;
          address: Json | null;
          notes: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          name: string;
          email?: string | null;
          phone?: string | null;
          address?: Json | null;
          notes?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          name?: string;
          email?: string | null;
          phone?: string | null;
          address?: Json | null;
          notes?: string | null;
          updated_at?: string;
        };
      };
      invoices: {
        Row: {
          id: string;
          user_id: string;
          client_id: string | null;
          invoice_number: string;
          client_name: string;
          client_email: string | null;
          client_phone: string | null;
          client_address: string | null;
          stripe_payment_intent_id: string | null;
          stripe_hosted_invoice_url: string | null;
          subtotal: number; // in cents
          tax_rate: number;
          tax_amount: number; // in cents
          total: number; // in cents
          currency: string;
          status: InvoiceStatus;
          due_date: string | null;
          paid_at: string | null;
          sent_at: string | null;
          notes: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          client_id?: string | null;
          invoice_number: string;
          client_name: string;
          client_email?: string | null;
          client_phone?: string | null;
          client_address?: string | null;
          stripe_payment_intent_id?: string | null;
          stripe_hosted_invoice_url?: string | null;
          subtotal?: number;
          tax_rate?: number;
          tax_amount?: number;
          total?: number;
          currency?: string;
          status?: InvoiceStatus;
          due_date?: string | null;
          paid_at?: string | null;
          sent_at?: string | null;
          notes?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          client_id?: string | null;
          invoice_number?: string;
          client_name?: string;
          client_email?: string | null;
          client_phone?: string | null;
          client_address?: string | null;
          stripe_payment_intent_id?: string | null;
          stripe_hosted_invoice_url?: string | null;
          subtotal?: number;
          tax_rate?: number;
          tax_amount?: number;
          total?: number;
          currency?: string;
          status?: InvoiceStatus;
          due_date?: string | null;
          paid_at?: string | null;
          sent_at?: string | null;
          notes?: string | null;
          updated_at?: string;
        };
      };
      invoice_items: {
        Row: {
          id: string;
          invoice_id: string;
          description: string;
          quantity: number;
          unit_price: number; // in cents
          total: number; // in cents
          original_transcript_segment: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          invoice_id: string;
          description: string;
          quantity?: number;
          unit_price?: number;
          total?: number;
          original_transcript_segment?: string | null;
          created_at?: string;
        };
        Update: {
          id?: string;
          invoice_id?: string;
          description?: string;
          quantity?: number;
          unit_price?: number;
          total?: number;
          original_transcript_segment?: string | null;
        };
      };
      voice_notes: {
        Row: {
          id: string;
          user_id: string;
          invoice_id: string | null;
          storage_path: string;
          transcript: string | null;
          detected_language: string | null;
          confidence_score: number | null;
          processing_status: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          invoice_id?: string | null;
          storage_path: string;
          transcript?: string | null;
          detected_language?: string | null;
          confidence_score?: number | null;
          processing_status?: string;
          created_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          invoice_id?: string | null;
          storage_path?: string;
          transcript?: string | null;
          detected_language?: string | null;
          confidence_score?: number | null;
          processing_status?: string;
        };
      };
      glossary_terms: {
        Row: {
          id: string;
          term: string;
          standard_english: string;
          category: string | null;
          language: string;
          created_at: string;
        };
        Insert: {
          id?: string;
          term: string;
          standard_english: string;
          category?: string | null;
          language?: string;
          created_at?: string;
        };
        Update: {
          id?: string;
          term?: string;
          standard_english?: string;
          category?: string | null;
          language?: string;
        };
      };
      webhook_events: {
        Row: {
          id: string;
          event_type: string;
          processed_at: string;
          payload: Json | null;
        };
        Insert: {
          id: string;
          event_type: string;
          processed_at?: string;
          payload?: Json | null;
        };
        Update: {
          id?: string;
          event_type?: string;
          processed_at?: string;
          payload?: Json | null;
        };
      };
      reminder_settings: {
        Row: {
          id: string;
          user_id: string;
          enabled: boolean;
          day_intervals: number[];
          email_enabled: boolean;
          sms_enabled: boolean;
          message_template: string;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          enabled?: boolean;
          day_intervals?: number[];
          email_enabled?: boolean;
          sms_enabled?: boolean;
          message_template?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          enabled?: boolean;
          day_intervals?: number[];
          email_enabled?: boolean;
          sms_enabled?: boolean;
          message_template?: string;
          updated_at?: string;
        };
      };
      reminder_logs: {
        Row: {
          id: string;
          invoice_id: string;
          reminder_type: string;
          sent_at: string;
          status: string;
          error_message: string | null;
        };
        Insert: {
          id?: string;
          invoice_id: string;
          reminder_type: string;
          sent_at?: string;
          status?: string;
          error_message?: string | null;
        };
        Update: {
          id?: string;
          invoice_id?: string;
          reminder_type?: string;
          sent_at?: string;
          status?: string;
          error_message?: string | null;
        };
      };
    };
    Enums: {
      invoice_status: InvoiceStatus;
    };
  };
}

// Convenience type aliases
export type Profile = Database['public']['Tables']['profiles']['Row'];
export type ProfileInsert = Database['public']['Tables']['profiles']['Insert'];
export type ProfileUpdate = Database['public']['Tables']['profiles']['Update'];

export type Client = Database['public']['Tables']['clients']['Row'];
export type ClientInsert = Database['public']['Tables']['clients']['Insert'];
export type ClientUpdate = Database['public']['Tables']['clients']['Update'];

export type Invoice = Database['public']['Tables']['invoices']['Row'];
export type InvoiceInsert = Database['public']['Tables']['invoices']['Insert'];
export type InvoiceUpdate = Database['public']['Tables']['invoices']['Update'];

export type InvoiceItem = Database['public']['Tables']['invoice_items']['Row'];
export type InvoiceItemInsert = Database['public']['Tables']['invoice_items']['Insert'];
export type InvoiceItemUpdate = Database['public']['Tables']['invoice_items']['Update'];

export type VoiceNote = Database['public']['Tables']['voice_notes']['Row'];
export type VoiceNoteInsert = Database['public']['Tables']['voice_notes']['Insert'];
export type VoiceNoteUpdate = Database['public']['Tables']['voice_notes']['Update'];

export type GlossaryTerm = Database['public']['Tables']['glossary_terms']['Row'];

export type ReminderSettings = Database['public']['Tables']['reminder_settings']['Row'];
export type ReminderSettingsInsert = Database['public']['Tables']['reminder_settings']['Insert'];
export type ReminderSettingsUpdate = Database['public']['Tables']['reminder_settings']['Update'];

export type ReminderLog = Database['public']['Tables']['reminder_logs']['Row'];


=================================================================================
FILE: ./types/index.ts
=================================================================================

/**
 * Application Types
 * Re-exports database types and defines app-specific types
 */

// Re-export all database types
export * from "./database";

// Re-export ParsedInvoice from store (used before saving to DB)
export type { ParsedInvoice } from "@/store/useInvoiceStore";

// Recording state for voice capture
export interface RecordingState {
  isRecording: boolean;
  duration: number;
  audioUri?: string;
}

// AI parsing result (from Edge Function)
export interface AIParseResult {
  meta: {
    intent: "INVOICE" | "QUOTE";
    confidence: number;
    language_detected: string;
    currency: "USD" | "BRL" | "MXN" | "EUR";
  };
  client: {
    name: string | null;
    contact_inferred: string | null;
  };
  line_items: Array<{
    description: string;
    quantity: number;
    unit_price: number;
    total: number;
    original_transcript_segment: string;
    requires_review: boolean;
  }>;
  notes: string | null;
}

// Dashboard statistics
export interface DashboardStats {
  totalRevenue: number; // in cents
  pendingAmount: number; // in cents
  invoiceCount: number;
  paidCount: number;
  overdueCount: number;
}

// Stripe account status
export interface StripeAccountStatus {
  isConnected: boolean;
  chargesEnabled: boolean;
  payoutsEnabled: boolean;
  accountId: string | null;
}

// Invoice with items (combined for display)
export interface InvoiceWithItems {
  invoice: import("./database").Invoice;
  items: import("./database").InvoiceItem[];
}

// Helper type for amounts (convert between cents and dollars)
export type CentsAmount = number & { readonly __brand: "cents" };
export type DollarsAmount = number & { readonly __brand: "dollars" };

// Utility functions for amount conversion
export const toCents = (dollars: number): number => Math.round(dollars * 100);
export const toDollars = (cents: number): number => cents / 100;

// Format currency for display
export const formatCurrency = (cents: number, currency: string = "USD"): string => {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency,
  }).format(toDollars(cents));
};

// Format relative date
export const formatRelativeDate = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffTime = date.getTime() - now.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays === 0) return "Today";
  if (diffDays === 1) return "Tomorrow";
  if (diffDays === -1) return "Yesterday";
  if (diffDays > 0 && diffDays <= 7) return `In ${diffDays} days`;
  if (diffDays < 0 && diffDays >= -7) return `${Math.abs(diffDays)} days ago`;

  return new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "numeric",
    year: date.getFullYear() !== now.getFullYear() ? "numeric" : undefined,
  }).format(date);
};

